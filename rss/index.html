<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[tl;dr]]></title><description><![CDATA[Software design. Craftsmanship. And lots of JavaScript. üôå]]></description><link>https://jonathanleemartin.com/</link><image><url>https://jonathanleemartin.com/favicon.png</url><title>tl;dr</title><link>https://jonathanleemartin.com/</link></image><generator>Ghost 2.27</generator><lastBuildDate>Wed, 23 Oct 2019 12:13:58 GMT</lastBuildDate><atom:link href="https://jonathanleemartin.com/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[05. Exception Composition]]></title><description><![CDATA[üé¨ How do you safely handle runtime errors without a mess of try‚Ä¶catch and if‚Ä¶else? üò∑ Why, function composition of course!]]></description><link>https://jonathanleemartin.com/tldr/05-exception-composition/</link><guid isPermaLink="false">5daf5eada054730c1ccd8438</guid><category><![CDATA[tl;dr]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[Design Pattern]]></category><category><![CDATA[Web]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Wed, 23 Oct 2019 12:00:00 GMT</pubDate><media:content url="https://jonathanleemartin.com/content/images/2019/10/05-exception-composition.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://jonathanleemartin.com/content/images/2019/10/05-exception-composition.png" alt="05. Exception Composition"><p>How do you handle runtime errors without a mess of try‚Ä¶catch and if‚Ä¶else statements? Let‚Äôs see how higher-order functions and composition can help on today‚Äôs episode of <a href="https://www.youtube.com/channel/UCol-gOYBawJGqUn2AhwxhNg">TL;DR</a>, the JavaScript codecast series that teaches working web developers to craft exceptional software in 5 minutes a week.</p>
<iframe src="https://www.youtube.com/embed/kzYjAfSoyBk" allow="autoplay; encrypted-media" allowfullscreen width="16" height="9"></iframe>
<h3 id="transcript">Transcript</h3>
<p>Last episode we saw how Custom Errors can often make our code worse, but Custom Exceptions can help by allowing intermediary functions to focus only on the feature‚Äôs happy path. If you‚Äôre just now joining us, hop back to the <a href="https://jonathanleemartin.com/tldr/04-custom-exceptions/">previous episode on Custom Exceptions</a>.</p>
<p>Exceptions are useful when they eliminate if‚Ä¶else statements from calling functions, but at some point an Exception needs to be caught and handled, and that‚Äôs where the try‚Ä¶catch statement tends to make a mess of things.</p>
<p>Today we‚Äôre continuing to refactor a tiny chatbot we started <a href="https://jonathanleemartin.com/tldr/02-router-pattern/">a few episodes ago</a> that helps outdoor enthusiasts find great trails to hike.</p>
<pre><code class="language-javascript">let chatbot = (message) =&gt; {
  return viewHike(message);
};

chatbot('view hike mirror lake');
// =&gt; 'Details about &lt;mirror lake&gt;'
chatbot('view hike lost lake');
// =&gt; üí• NotFound: lost lake
chatbot('show hike blue ridge');
// =&gt; üí• ValidationError: show hike blue ridge
</code></pre>
<p>Like last time, our chatbot only understands one command, <code>view hike</code>. Most of the time this command replies with details about the hike, but when users ask for a hike that isn‚Äôt in the database or their syntax is a bit off, the <code>viewHike()</code> function will throw a custom exception like a <code>NotFound</code> error or a <code>ValidationError</code>.</p>
<p>In either case, the chatbot shouldn‚Äôt blow up and stop running, so we started by wrapping a try‚Ä¶catch statement around the problematic code.</p>
<pre><code class="language-javascript">let chatbot = (message) =&gt; {
  try {
    return viewHIke(message);
  } catch (error) {
    return `No such hike.`;
  }
};

chatbot('view hike mirror lake');
// =&gt; 'No such hike.'
chatbot('view hike lost lake');
// =&gt; 'No such hike.'
chatbot('show hike blue ridge');
// =&gt; 'No such hike.'
</code></pre>
<p>But we quickly realized that every use of try‚Ä¶catch takes a substantial amount of boilerplate to keep from introducing a catch-all bug, like accidentally suppressing a <code>ReferenceError</code>.</p>
<p>To make sure we only rescued a particular error type, we introduced a simple utility called <code>rescue()</code>: a guard clause which rethrows the error if the type differs from what we intended to catch.</p>
<pre><code class="language-javascript">let chatbot = (message) =&gt; {
  try {
    return viewHIke(message);
  } catch (error) {
    rescue(error, NotFound);
    return `No such hike.`;
  }
};

chatbot('view hike mirror lake');
// =&gt; üí• ReferenceError: viewHIke is not defined
</code></pre>
<pre><code class="language-diff"> let chatbot = (message) =&gt; {
   try {
-   return viewHIke(message);
+   return viewHike(message);
   } catch (error) {
     rescue(error, NotFound);
     return `No such hike.`;
   }
 };
</code></pre>
<pre><code class="language-javascript">chatbot('view hike mirror lake');
// =&gt; 'Details about &lt;mirror lake&gt;'
chatbot('view hike lost lake');
// =&gt; 'No such hike.'
chatbot('show hike blue ridge');
// =&gt; üí• ValidationError: show hike blue ridge
</code></pre>
<p>The problem with <code>rescue()</code> is that it only helps us catch one type of error at a time. So how do we handle both a <code>NotFound</code> error and <code>ValidationError</code>? We could make the <code>rescue()</code> function accept multiple error types, but then we couldn‚Äôt customize the fallback message based on the error type.</p>
<p>So do we have to give up the <code>rescue()</code> utility altogether and use cascading if‚Ä¶else statements to uniquely handle different error types? Maybe not if we factor a little further.</p>
<p>Our remaining try‚Ä¶catch boilerplate is starting to turn into an obvious pattern: if we were to reuse this try‚Ä¶catch in another part of the codebase, all that changes is the function to invoke, what type of error to rescue, and what to return if there is an error.</p>
<p>Let‚Äôs extract this formula into a function called <code>swallow()</code>, which takes the error type to swallow, a fallback function, and a function that will potentially throw an error.</p>
<pre><code class="language-javascript">let swallow = (type, fail, fn) =&gt; {
  try {
    return fn();
  } catch (error) {
    rescue(error, type);
    return fail(error);
  }
};
</code></pre>
<p>Now we‚Äôll use <code>swallow()</code> to create a new version of <code>viewHike()</code> that is safe from <code>NotFound</code> errors.</p>
<pre><code class="language-javascript">let safeViewHike = (message) =&gt;
  swallow(NotFound, () =&gt; `No such hike.`,
    () =&gt; viewHike(message)
  )
;

let chatbot = safeViewHike;
</code></pre>
<p>It seems to work as before! But this code is still pretty verbose, and some might argue it‚Äôs more cryptic than simply writing a try‚Ä¶catch with cascading if‚Ä¶else statements. Well, if we just change the signature of <code>swallow()</code> a bit to take advantage of currying, we can eliminate a lot of the extra function calls and argument gathering.</p>
<pre><code class="language-diff">-let swallow = (type, fail, fn) =&gt; {
+let swallow = (type) =&gt; (fail) =&gt; (fn) =&gt; (...args) =&gt; {
   try {
-    return fn();
+    return fn(...args);
   } catch (error) {
     rescue(error, type);
     return fail(error);
   }
 };
</code></pre>
<pre><code class="language-javascript">let safeViewHike =
  swallow(NotFound)(() =&gt; `No such hike.`)(
    viewHike
  );
</code></pre>
<p>Whoah, look at <code>swallow()</code> now! It‚Äôs a <a href="https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99">Higher-Order Function</a>: it takes in an unsafe function that throws a particular kind of error, and returns a safe version of the function.</p>
<p>Because <code>swallow()</code> returns a function that is safe from the <code>NotFound</code> error type, there‚Äôs no reason we can‚Äôt pass that function into <code>swallow()</code> again to make it safe from a <code>ValidationError</code> too!</p>
<pre><code class="language-javascript">let safeViewHike =
  swallow(ValidationError)(() =&gt; `Invalid format.`)(
    swallow(NotFound)(() =&gt; `No such hike.`)(
      viewHike
    )
  );
</code></pre>
<pre><code class="language-javascript">chatbot('view hike mirror lake');
// =&gt; 'Details about &lt;mirror lake&gt;'
chatbot('view hike lost lake');
// =&gt; 'No such hike.'
chatbot('show hike blue ridge');
// =&gt; 'Invalid format.'
</code></pre>
<p>That nesting is a bit nasty, but this is just the sort of thing the <code>compose()</code> utility is for:</p>
<pre><code class="language-javascript">let compose = (...fns) =&gt; x =&gt; fns.reduceRight((v, f) =&gt; f(v), x);
</code></pre>
<p>Instead of nesting <code>swallow()</code>s inside each other, we can list them out from top to bottom and feed the original <code>viewHike()</code> function at the very end. It works exactly the same way as manually feeding the results of each <code>swallow()</code> into the other, but it‚Äôs much easier to read and maintain.</p>
<pre><code class="language-javascript">let safeViewHike = compose(
  swallow(ValidationError)(() =&gt; `Invalid format.`),
  swallow(NotFound)(() =&gt; `No such hike.`),
)(viewHike);
</code></pre>
<p>This style of creating functions without first gathering and passing around all their arguments is called <a href="https://wiki.haskell.org/Pointfree">Point-free style</a>, and it‚Äôs a big part of what makes functional programming so elegant.</p>
<p>It took us some time to arrive at this design, and many of the intermediate steps seemed a lot worse off than just using try‚Ä¶catch. But just like the <a href="https://jonathanleemartin.com/tldr/03-enforcer-pattern/">Enforcer pattern</a> we covered in an earlier episode, the best way to combine behaviors is through composition. Rather than cascading if-else statements, complex multiple error handling logic, or experimental catch syntax, we handled two kinds of errors through composition.</p>
<p>If you aren‚Äôt already in love with function composition, hang tight until the next episode: we‚Äôll use error composition to put a functional twist on a popular Object-Oriented Programming pattern called the Null Object Pattern.</p>
<p>Today, look for try‚Ä¶catch statements in your codebase, and break down the parent function until you can replace the try‚Ä¶catch altogether with <code>swallow()</code>. And if you need to handle multiple error types, just layer them with <code>compose()</code>.</p>
<p>That‚Äôs it for today. Want to keep leveling up your craft? Don‚Äôt forget to <a href="https://www.youtube.com/channel/UCol-gOYBawJGqUn2AhwxhNg">subscribe to the channel</a> for more rapid codecasts on design patterns, refactoring and development approaches.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[04. Custom Exceptions]]></title><description><![CDATA[üé¨ Spooked out by errors and stack traces? üò± With solid error handling patterns, Custom Exceptions can help us eliminate if‚Ä¶else statements!]]></description><link>https://jonathanleemartin.com/tldr/04-custom-exceptions/</link><guid isPermaLink="false">5da744d92aa23c2d8579b64d</guid><category><![CDATA[tl;dr]]></category><category><![CDATA[JavaScript]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Wed, 16 Oct 2019 16:28:24 GMT</pubDate><media:content url="https://jonathanleemartin.com/content/images/2019/10/04-custom-exceptions.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://jonathanleemartin.com/content/images/2019/10/04-custom-exceptions.png" alt="04. Custom Exceptions"><p>Do you get spooked by runtime errors? They can be a pain to deal with, but we‚Äôll see just how much solid error handling strategies can help in our crusade against if‚Ä¶else statements on today‚Äôs episode of <a href="https://www.youtube.com/channel/UCol-gOYBawJGqUn2AhwxhNg">TL;DR</a>, the JavaScript codecast series that teaches working web developers to craft exceptional software in 5 minutes a week.</p>
<iframe src="https://www.youtube.com/embed/d5eyTy0QOgg" allow="autoplay; encrypted-media" allowfullscreen width="16" height="9"></iframe>
<h3 id="transcript">Transcript</h3>
<p>When you invoke a function, what might happen? Most of the time we get back a simple return value, but there‚Äôs another kind of result a function can produce: an <code>Error</code>.</p>
<p>An <code>Error</code> typically makes us think we did something wrong, but errors are just another feedback mechanism for a program, and unlike returning a value, throwing an <code>Error</code> has a peculiar superpower: it automatically propagates up the caller stack ‚Äî interrupting the caller functions as it propagates ‚Äî until it‚Äôs caught. This propagation behavior makes <code>throw</code> and try‚Ä¶catch statements a powerful control flow construct.</p>
<p>But handling errors correctly can quickly turn elegant functions into a hot mess of try‚Ä¶catch statements and nested if‚Ä¶else statements ‚Äî exactly <a href="https://jonathanleemartin.com/tldr/01-nested-ternaries/">the sort of thing</a> we‚Äôve <a href="https://jonathanleemartin.com/tldr/02-router-pattern/">been obliterating</a> in the <a href="https://jonathanleemartin.com/tldr/03-enforcer-pattern/">last few episodes</a>.</p>
<p>Today we‚Äôre working on a tiny version of the chatbot we started a couple episodes back that helps outdoor enthusiasts find great trails to hike.</p>
<pre><code class="language-javascript">let chatbot = (message) =&gt; {
  return viewHike(message);
};

chatbot('view hike mirror lake');
// =&gt; 'Details about &lt;mirror lake&gt;'
chatbot('view hike lost lake');
// =&gt; üí• NotFound: lost lake
chatbot('show hike blue ridge');
// =&gt; üí• ValidationError: show hike blue ridge
</code></pre>
<p>We‚Äôve cut down the chatbot code from the last couple episodes: it only understands one command, <code>view hike</code>, which shows details about a hike. But sometimes users ask for a hike that isn‚Äôt in the database or their syntax is a bit off. To simulate these edge cases, the <code>viewHike()</code> function uses a few custom error types:</p>
<pre><code class="language-javascript">class NotFound extends Error {
  constructor(message) {
    super(message);
    this.name = 'NotFound';
  }
}

class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
  }
}
</code></pre>
<p><code>viewHike()</code> throws a <code>NotFound</code> error if the hike has the word ‚Äúlost‚Äù, and a <code>ValidationError</code> if the format of the message is off.</p>
<pre><code class="language-javascript">let viewHike = (message) =&gt; {
  let match = /^view hike (.+)$/.exec(message);
  let hike = match &amp;&amp; match[1];

  return (
    !hike ?
      raise(new ValidationError(message))
  : hike.includes('lost') ?
      raise(new NotFound(hike))
  :
      `Details about &lt;${hike}&gt;`
  );
};
</code></pre>
<p>Like <code>return</code> and <code>continue</code>, <code>throw</code> is a statement, so to use it in a <a href="https://jonathanleemartin.com/tldr/01-nested-ternaries/">nested ternary</a>, we wrote a simple helper called <code>raise()</code>.</p>
<pre><code class="language-javascript">let raise = (error) =&gt; { throw error; };
</code></pre>
<p>There‚Äôs a <a href="https://github.com/tc39/proposal-throw-expressions">stage 2 proposal</a> for an expression-friendly version of <code>throw</code> in the works, but until it lands it‚Äôs easy enough to make our own. So all told, the <code>viewHike()</code> function can result in one of two things: a return value, or a thrown <code>Error</code>.</p>
<p>Our chatbot is terse, but it already has some issues. We definitely don‚Äôt want the chatbot to blow up and stop running if a <code>NotFound</code> error is thrown, so let‚Äôs wrap the call with a try‚Ä¶catch statement to instead return a safe fallback message:</p>
<pre><code class="language-javascript">let chatbot = (message) =&gt; {
  try {
    return viewHIke(message);
  } catch (error) {
    return `No such hike.`;
  }
};

chatbot('view hike mirror lake');
// =&gt; 'No such hike.'
chatbot('view hike lost lake');
// =&gt; 'No such hike.'
chatbot('show hike blue ridge');
// =&gt; 'No such hike.'
</code></pre>
<p>Wait, why is our chatbot always responding with ‚ÄúNo such hike‚Äù now? That first command definitely worked before. Let‚Äôs comment out the try‚Ä¶catch statement to see what‚Äôs happening.</p>
<pre><code class="language-javascript">let chatbot = (message) =&gt; {
  // try {
    return viewHIke(message);
  // } catch (error) {
  //   return `No such hike.`;
  // }
};

chatbot('view hike mirror lake');
// =&gt; üí• ReferenceError: viewHIke is not defined
chatbot('view hike lost lake');
// =&gt;
chatbot('show hike blue ridge');
// =&gt;
</code></pre>
<p>It looks like we were swallowing a <code>ReferenceError</code>. Well that would be a horrible bug to deploy to production!</p>
<p>We just made the cardinal mistake of error handling: <strong>a catch all.</strong> The try‚Ä¶catch statement will swallow any error ‚Äî including errors we didn‚Äôt mean to catch.</p>
<p>It may sound obvious now, but just about any open source framework you‚Äôve used probably has a catch-all bug in the codebase, from frontend frameworks like Ember.js to backend libraries like Passport and Jekyll. A catch-all ranks in the top 5 most frustrating bugs a library can make because it suppresses important errors unrelated to the library that the developer would otherwise see in the logs.</p>
<p>So it‚Äôs up to us to whitelist the type of error we want to handle, and otherwise rethrow it. Since we made custom error subclasses, we can use the <code>instanceof</code> operator to guarantee we‚Äôre catching an error we can handle. Otherwise, we‚Äôll rethrow it.</p>
<pre><code class="language-javascript">let chatbot = (message) =&gt; {
  try {
    return viewHike(message);
  } catch (error) {
    if (error instanceof NotFound) {
      return `No such hike.`;
    } else {
      throw error;
    }
  }
};

chatbot('view hike mirror lake');
// =&gt; 'Details about &lt;mirror lake&gt;'
chatbot('view hike lost lake');
// =&gt; 'No such hike.'
chatbot('show hike blue ridge');
// =&gt; üí• ValidationError: show hike blue ridge
</code></pre>
<p>To rescue a <code>ValidationError</code>, we add another else-if case.</p>
<pre><code class="language-diff"> let chatbot = (message) =&gt; {
   try {
     return viewHike(message);
   } catch (error) {
     if (error instanceof NotFound) {
       return `No such hike.`;
+    } else if (error instanceof ValidationError) {
+      return `Invalid format.`;
     } else {
       throw error;
     }
   }
 };
 
 chatbot('show hike blue ridge');
 // =&gt; 'Invalid format.'
</code></pre>
<p>The chatbot is behaving well and not blowing up, but handling an error correctly looks awful. We definitely can‚Äôt leave these checks out, but a try‚Ä¶catch is a branching construct just like an if‚Ä¶else, so these are essentially nested, cascading if‚Ä¶else statements all over again. And we‚Äôll have to repeat this boilerplate each time we need to handle an error correctly.</p>
<p>It really doesn‚Äôt seem like custom errors are making our code any better ‚Äî in fact, it seems to be getting much worse!</p>
<p>That‚Äôs why you should never be too quick to sprinkle custom errors throughout your codebase. Because throw statements are fundamentally a control flow construct, they can often fight against everything we‚Äôve been working towards in the previous episodes.</p>
<p>So when, if ever, should you use custom errors? Well, I prefer the alternative name <strong>‚ÄúCustom Exceptions‚Äù</strong> because it tells us exactly when to use them: for unusual, exceptional cases that most of our codebase shouldn‚Äôt care about, like a <code>NetworkError</code>. These are cases that one or two functions in the codebase will handle with the same response: on the backend, a <code>NotFound</code> error thrown from any route should just generate a 404 response.</p>
<p>Used sparingly, custom exceptions can actually eliminate branching logic: since the rest of our functions can assume the happy path, they don‚Äôt need an if‚Ä¶else statement to check for an unusual return value, like a null check.</p>
<p>So a custom exception is worthwhile when it eliminates edge cases and if‚Ä¶else statements from calling functions, and throwing custom exceptions makes sense when the function would blow up anyway with a useless generic runtime error, like a <code>TypeError</code>.</p>
<p>Let‚Äôs see if we can find an error handling solution that cuts down if‚Ä¶else statements and common typos. Throwing an error triggers an early exit, even from a catch clause. Let‚Äôs shuffle the error checking code so it looks more like a <a href="https://jonathanleemartin.com/tldr/03-enforcer-pattern/">guard clause</a>:</p>
<pre><code class="language-javascript">let chatbot = (message) =&gt; {
  try {
    return viewHike(message);
  } catch (error) {
    if (error instanceof NotFound) {
      throw error;
    }
    return `No such hike.`;
  }
};
</code></pre>
<p>Now there‚Äôs nothing stopping us from extracting this entire guard clause into a function! Let‚Äôs call it <code>rescue()</code>.</p>
<pre><code class="language-javascript">let rescue = (error, type) =&gt;
  error instanceof type
    ? error
    : raise(error)
;
</code></pre>
<p>Now when using a try‚Ä¶catch, we just need to make sure we precede the catch code with <code>rescue()</code>. This behaves much better than what we started with, and it only added one line to our naive catch-all version.</p>
<pre><code class="language-javascript">let chatbot = (message) =&gt; {
  try {
    return viewHike(message);
  } catch (error) {
    rescue(error, NotFound);
    return `No such hike.`;
  }
};

chatbot('view hike mirror lake');
// =&gt; 'Details about &lt;mirror lake&gt;'
chatbot('view hike lost lake');
// =&gt; 'No such hike.'
chatbot('show hike blue ridge');
// =&gt; üí• ValidationError: show hike blue ridge
</code></pre>
<p>Unfortunately, we can‚Äôt just stack invocations of <code>rescue()</code>, so how do we also handle a <code>ValidationError</code>? Hang tight and we‚Äôll address this problem on the next episode of TL;DR. Till then, search for try‚Ä¶catch statements in your codebase and enforce good error handling practices with <code>rescue()</code>.</p>
<p>That‚Äôs it for today. Want to keep leveling up your craft? Don‚Äôt forget to <a href="https://www.youtube.com/channel/UCol-gOYBawJGqUn2AhwxhNg">subscribe to the channel</a> for more rapid codecasts on design patterns, refactoring and development approaches.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[03. Enforcer Pattern]]></title><description><![CDATA[üé¨ Find yourself copy-pasting small if-else statements across several functions? üíÇ‚Äç‚ôÇÔ∏è With higher-order functions and the enforcer pattern, you can compose guard behaviors!]]></description><link>https://jonathanleemartin.com/tldr/03-enforcer-pattern/</link><guid isPermaLink="false">5d9e1d61ed2f711a7b1a0136</guid><category><![CDATA[tl;dr]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[Design Pattern]]></category><category><![CDATA[Web]]></category><category><![CDATA[React]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Wed, 09 Oct 2019 17:49:05 GMT</pubDate><media:content url="https://jonathanleemartin.com/content/images/2019/10/03-enforcers.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://jonathanleemartin.com/content/images/2019/10/03-enforcers.png" alt="03. Enforcer Pattern"><p>How can you cut down small if-else statements that recur across several functions? Let‚Äôs cover another pattern for nuking if-else statements on today‚Äôs episode of <a href="https://www.youtube.com/channel/UCol-gOYBawJGqUn2AhwxhNg">TL;DR</a>, the JavaScript codecast series that teaches working web developers to craft exceptional software in 5 minutes a week.</p>
<iframe src="https://www.youtube.com/embed/H-L6BMD4hN8" allow="autoplay; encrypted-media" allowfullscreen width="16" height="9"></iframe>
<h3 id="transcript">Transcript</h3>
<p>Over the past few episodes, we‚Äôve been covering design patterns to help cut down the size and depth of if-else statements. If you‚Äôre new to this vendetta against if-else statements, hop back to the episode on <a href="https://jonathanleemartin.com/tldr/01-nested-ternaries/">nested ternaries</a> to get up to speed.</p>
<p>Nested ternaries and the <a href="https://jonathanleemartin.com/tldr/02-router-pattern/">Router design pattern</a> have helped us reduce the size and depth of cascading if-else statements, but we haven‚Äôt dealt with terse, non-cascading if-else statements that get copy-pasted across functions. These if-else statements often appear at the beginning of the function as a guard clause. They‚Äôre innocent and short, but like a weed they reproduce with each new feature, and the duplication is tricky to eradicate.</p>
<p>Today we‚Äôre continuing to work on a chatbot that helps outdoor enthusiasts find great trails to hike. This chatbot can respond to simple text commands, like <code>list hikes</code>, <code>add hike</code> and <code>delete hike</code>. If it doesn‚Äôt understand the command, it replies with a fallback message.</p>
<pre><code class="language-javascript">responder('list hikes');
// =&gt; 'Lost Lake, Canyon Creek Meadows'
responder('add hike Mirror Lake');
// =&gt; 'Added Mirror Lake!'
responder('delete hike Mirror Lake');
// =&gt; 'Removed Mirror Lake!'
responder('where is Mirror Lake');
// =&gt; &quot;Sorry, I don't understand.&quot;
</code></pre>
<p>The code is a few steps forward from what we had last time: the responder function still follows the Router pattern, but we lifted the individual routes into functions to make the list of responses easier to read.</p>
<pre><code class="language-javascript">let hikes = [
  'Lost Lake',
  'Canyon Creek Meadows',
];

let listHikes = () =&gt;
  hikes.join(', ');

let addHike = ([hike]) =&gt; {
  hikes.push(hike);
  return `Added ${hike}!`;
};

let deleteHike = ([hike]) =&gt; {
  hikes.splice(hikes.indexOf(hike), 1);
  return `Removed ${hike}!`;
};

let fallback = () =&gt;
  `Sorry, I don't understand.`;

let responses = [
  { command: /^list hikes$/,
    response: listHikes },
  { command: /^add hike (.+)$/,
    response: addHike },
  { command: /^delete hike (.+)$/,
    response: deleteHike },
  { command: /^(.*)$/,
    response: fallback },
];

let responder = (message) =&gt; {
  let { command, response } = responses
    .find(({ command, response }) =&gt;
      command.test(message)
    );
  return response(
    command.exec(message).slice(1)
  );
};
</code></pre>
<p>The responder function searches through the list of responses for a command that matches the chat message, then invokes the corresponding response function.</p>
<pre><code class="language-javascript">let responder = (message) =&gt; {
  let { command, response } = responses
    .find(({ command, response }) =&gt;
      command.test(message)
    );
  return response(
    command.exec(message).slice(1)
  );
};
</code></pre>
<p>Today, we want to enforce that the <code>add hike</code> and <code>delete hike</code> commands are executed with the word ‚Äúsudo‚Äù to prevent any accidental changes. Only some commands need sudo, and if the user forgets sudo, we want to provide feedback. So we can‚Äôt just add the word ‚Äúsudo‚Äù directly to the regular expressions.</p>
<pre><code class="language-javascript">responder('list hikes');
// =&gt; 'Lost Lake, Canyon Creek Meadows'
responder('sudo add hike Mirror Lake');
// =&gt; &quot;Sorry, I don't understand.&quot;
responder('sudo delete hike Mirror Lake');
// =&gt; &quot;Sorry, I don't understand.&quot;
responder('where is Mirror Lake');
// =&gt; &quot;Sorry, I don't understand.&quot;
</code></pre>
<p>We can make the regular expressions a little more lenient so the command is at least recognized:</p>
<pre><code class="language-diff"> let responses = [
-  { command: /^list hikes$/,
+  { command: /list hikes$/,
   ...
-  { command: /^add hike (.+)$/,
+  { command: /add hike (.+)$/,
   ...
-  { command: /^delete hike (.+)$/,
+  { command: /delete hike (.+)$/,
   ...
 ];
</code></pre>
<p>But how should we enforce the use of sudo for these admin commands?</p>
<p>One tempting way to support a new, shared behavior like this is to add a new property to each response object: we‚Äôll call it <code>adminOnly</code>.</p>
<pre><code class="language-diff"> let responses = [
   ...
   { command: /add hike (.+)$/,
+    adminOnly: true,
     response: addHike },
   { command: /delete hike (.+)$/,
+    adminOnly: true,
     response: deleteHike },
   ...
 ];
</code></pre>
<p>Then in the responder, we‚Äôll add a guard clause that checks if the route requires ‚Äúsudo‚Äù, and if the word is missing, we‚Äôll respond with ‚ÄúNot allowed.‚Äù</p>
<pre><code class="language-diff"> let responder = (message) =&gt; {
-  let { command, response } = responses
+  let { command, adminOnly, response } = responses
     .find(({ command, response }) =&gt;
       command.test(message)
     );
+  if (adminOnly &amp;&amp; !message.startsWith('sudo')) {
+    return 'Not allowed!';
+  }
   return response(
     command.exec(message).slice(1)
   );
 };
</code></pre>
<p>When faced with this kind of feature request ‚Äî that is, supporting a new behavior that can be generalized for related functions ‚Äî many developers would probably do what we did and insert that behavior logic into the responder function. It‚Äôs quick, keeps the code <a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">DRY</a>, and it just feels nice. But it‚Äôs also a premature abstraction that conflates responsibilities: the responder function has become responsible for routing and authorization logic.</p>
<p>Every time a feature requires a new qualifier, the responder will be edited. It won‚Äôt be long before there are several short if-else statements in the responder ‚Äî which is precisely what the Router pattern was intended to help us demolish.</p>
<p>From a testing perspective, we can‚Äôt unit test the authorization logic for individual chat commands without going through the responder. We can only write integration tests for authorization.</p>
<p>Whenever you‚Äôre tempted to alter terse, single responsibility functions to incorporate a new behavior, take a step back and identify the most naive solution that still satisfies the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a>.</p>
<p>For example, what if we added this admin enforcement logic directly to the <code>addHike()</code> and <code>deleteHike()</code> response functions instead of the responder?</p>
<p>Let‚Äôs undo our changes. For the response functions to determine if sudo was used, we need to pass the full chat message:</p>
<pre><code class="language-diff"> let responder = (message) =&gt; {
   ...
   return response(
-    command.exec(message).slice(1)
+    { message,
+      match: command.exec(message).slice(1) }
   );
 };
</code></pre>
<p>In <code>addHike()</code>, we can add a guard clause that checks if the message starts with ‚Äúsudo‚Äù and returns ‚ÄúNot allowed‚Äù if it doesn‚Äôt. We can copy-paste this guard clause to <code>deleteHike()</code>.</p>
<pre><code class="language-javascript">let addHike = ({ match: [hike], message }) =&gt; {
  if (!message.startsWith('sudo')) {
    return 'Not allowed!';
  }
  hikes.push(hike);
  return `Added ${hike}!`;
};

let deleteHike = ({ match: [hike], message }) =&gt; {
  if (!message.startsWith('sudo')) {
    return 'Not allowed!';
  }
  hikes.splice(hikes.indexOf(hike), 1);
  return `Removed ${hike}!`;
};
</code></pre>
<p>This naive solution is feature complete and leaves the responder function focused on one responsibility. But now one if-else statement has multiplied into two in our response functions. So how are we any better off? Well, by letting the naive solution play out, we‚Äôre equipped to build an abstraction that solves a concrete problem: the duplicated guard clause.</p>
<p>This guard clause represents a behavior, which we could call <code>adminOnly</code>. When you hear the word ‚Äúbehavior‚Äù or ‚Äútrait‚Äù, we‚Äôre referring to a cross-cutting concern that can be shared across several functions, even if they do completely different things. The <code>addHike()</code> and <code>deleteHike()</code> response functions have different jobs, but they share a similar behavior.</p>
<p>A great way to share behavior in a language that supports functional programming is through function composition.</p>
<p>Suppose we had a function, called <code>adminOnly()</code>, that receives an unprotected function like <code>addHike()</code>, and returns a new version of <code>addHike()</code> that enforces the use of the ‚Äúsudo‚Äù keyword:</p>
<pre><code class="language-diff"> let responses = [
   ...
   { command: /add hike (.+)$/,
-    response: addHike },
+    response: adminOnly(addHike) },
   { command: /delete hike (.+)$/,
-    response: deleteHike },
+    response: adminOnly(deleteHike) },
   ...
 ];
</code></pre>
<p><code>adminOnly()</code> is easy to code up once you get the parameter signature right. If the message contains the word ‚Äúsudo‚Äù, it invokes the route it received as an argument. Otherwise, it returns the failure message.</p>
<pre><code class="language-javascript">let adminOnly = (route) =&gt; (request) =&gt;
  request.message.split(' ').includes('sudo')
    ? route(request)
    : 'Not allowed!'
;
</code></pre>
<p>I like to call this kind of behavior function an <strong>Enforcer</strong>: it‚Äôs a <a href="https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99">Higher-Order Function</a> with a guard clause that enforces some authorization rule, like requiring the word ‚Äúsudo‚Äù or checking if the current user is an admin.</p>
<p>The <code>add hike</code> and <code>delete hike</code> commands behave exactly as they did in our first solution. But this time, we didn‚Äôt have to edit existing functions to support the new behavior: we only added new functions and composed them. It‚Äôs as though we‚Äôre writing immutable code, and like immutable data structures, this style of coding has great design benefits and prevents regressions. None of our existing unit tests will change, and the new code already follows the single responsibility principle.</p>
<p>We can even add new enforcement behaviors.</p>
<p>Suppose we want to enforce that the <code>list hikes</code> command include the word ‚Äúplease‚Äù with a new behavior called <code>askNicely()</code>. All we need to do is duplicate the <code>adminOnly()</code> behavior, then change the keyword and failure message:</p>
<pre><code class="language-javascript">let askNicely = (route) =&gt; (request) =&gt;
  request.message.split(' ').includes('please')
    ? route(request)
    : 'You should ask nicely.'
;

let responses = [
  { command: /list hikes$/,
    response: askNicely(listHikes) },
  ...
];
</code></pre>
<p>And because these enforcers are built through function composition, they layer without additional work. To make the <code>delete hike</code> command require ‚Äúsudo‚Äù and ‚Äúplease‚Äù, we just compose the behaviors.</p>
<pre><code class="language-diff"> let responses = [
   ...
   { command: /delete hike (.+)$/,
-    response: adminOnly(deleteHike) },
+    response: adminOnly(askNicely(deleteHike)) },
   ...
 ];
</code></pre>
<p>But what about the duplication between these behaviors? Other than a different keyword and failure message, they look exactly the same. We can DRY them up into an enforcer factory called <code>requireKeyword()</code> that returns a new behavior based on a customizable keyword and failure message.</p>
<pre><code class="language-javascript">let requireKeyword = (word, fail) =&gt; (route) =&gt; (request) =&gt;
  request.message.split(' ').includes(word)
    ? route(request)
    : fail
;
</code></pre>
<p>Now the <code>adminOnly()</code> and <code>askNicely()</code> behaviors can be replaced with partial invocations of the <code>requireKeyword()</code> enforcer factory!</p>
<pre><code class="language-javascript">let adminOnly = requireKeyword('sudo', 'Not allowed!');
let askNicely = requireKeyword('please', 'You should ask nicely.');
</code></pre>
<p>We‚Äôve landed on a solution that satisfies the single responsibility principle, didn‚Äôt change existing functions, and produces descriptive code.</p>
<pre><code class="language-javascript">responder('list hikes');
// =&gt; 'You should ask nicely.'
responder('please list hikes');
// =&gt; 'Lost Lake, Canyon Creek Meadows'
responder('add hike Mirror Lake');
// =&gt; 'Not allowed!'
responder('sudo add hike Mirror Lake');
// =&gt; 'Added Mirror Lake!'
responder('sudo please delete hike Mirror Lake');
// =&gt; 'Removed Mirror Lake!'
</code></pre>
<p>The enforcer pattern pops up in other places, like guarding authenticated pages in a React web app:</p>
<pre><code class="language-javascript">let requireLogin = (Component) =&gt; (props) =&gt;
  props.currentUser
    ? &lt;Component {...props} /&gt;
    : &lt;Redirect to=&quot;/login&quot; /&gt;

let ActivityPage = ({ notifications }) =&gt;
  &lt;section&gt;
    &lt;h2&gt;Recent Activity&lt;/h2&gt;
    &lt;Notifications notifications={notifications} /&gt;
  &lt;/section&gt;

export default requireLogin(ActivityPage);

</code></pre>
<p>Or rendering a loading indicator while an API request finishes:</p>
<pre><code class="language-javascript">let withLoader = (msg) =&gt; (Component) =&gt; (props) =&gt;
  props.loading
    ? &lt;LoadingIndicator message={message} /&gt;
    : &lt;Component {...props} /&gt;

let ProfileScreen = ({ stories, user }) =&gt;
  &lt;div&gt;
    &lt;h2&gt;Stories from {user.name}&lt;/h2&gt;
    &lt;StoryList stories={stories} /&gt;
  &lt;/div&gt;

export default withLoader('Wait‚Ä¶')(ProfileScreen);

</code></pre>
<p>Or protecting backend routes based on the current user:</p>
<pre><code class="language-javascript">let listAllUsers = (req, res) =&gt; {
  res.send(users);
};

let adminOnly = (req, res, next) =&gt;
  req.user &amp;&amp; req.user.isAdmin
    ? next()
    : res.sendStatus(401);

app.get(
  adminOnly,
  listAllUsers,
);

</code></pre>
<p>But we wouldn‚Äôt have discovered this pattern without writing the naive copy-paste solution first and letting the repetition guide the refactor.</p>
<p>So don‚Äôt try to prevent copy-paste prematurely: instead, let the code be duplicated, then DRY up the duplication through function composition. The naive copy-paste solution will lead you to a resilient abstraction that won‚Äôt be outgrown by the next feature.</p>
<p>Today, look for short, repeated if-else statements near the beginning of the function that guard the rest of the function, and try extracting them into an enforcer function.</p>
<p>That‚Äôs it for today. Want to keep leveling up your craft? Don‚Äôt forget to <a href="https://www.youtube.com/channel/UCol-gOYBawJGqUn2AhwxhNg">subscribe to the channel</a> for more rapid codecasts on design patterns, refactoring and development approaches.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[5 JavaScript Books You Should Add to Your Reading List]]></title><description><![CDATA[ü§î How can you keep growing as a developer? Why, a good book of course! Books often provide perspectives you‚Äôd be hard pressed to find in an online course. üìñ Here are my top 5 reads for JavaScript.]]></description><link>https://jonathanleemartin.com/blog/javascript-books-you-should-read/</link><guid isPermaLink="false">5d8cfaa7eeb0921572d7fc81</guid><category><![CDATA[JavaScript]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Thu, 26 Sep 2019 17:57:02 GMT</pubDate><media:content url="https://jonathanleemartin.com/content/images/2019/09/javascripts-books-you-should-read.jpg" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://jonathanleemartin.com/content/images/2019/09/javascripts-books-you-should-read.jpg" alt="5 JavaScript Books You Should Add to Your Reading List"><p><small><em>This post originally appeared as a guest blog on <a href="https://www.coursereport.com/blog/5-javascript-books-you-should-add-to-your-reading-list">Course Report</a>.</em></small></p>
<p>Ah, books‚Äîthe time-tested technique for ingesting knowledge. Programming literature may not be as engaging as Codecademy or <a href="https://codecombat.com/">CodeCombat</a>, but it will help reinforce concepts and provide perspectives you‚Äôd be hard pressed to find in an online course.</p>
<p>Here are five books you should read as you begin your journey as a web developer. Keep in mind that these books won‚Äôt teach you to code, so they‚Äôre not substitutes for an online course or a coding bootcamp‚Äîbut they are excellent supplements!</p>
<h2 id="1javascriptallong">1.  <a href="https://www.amazon.com/Javascript-Allong%C3%A9-Reginald-Braithwaite-ebook/dp/B00FLKRCVO?tag=nybblr08-20">JavaScript Allong√©</a></h2>
<p><img src="https://jonathanleemartin.com/content/images/2019/09/javascript-allonge.jpg" alt="5 JavaScript Books You Should Add to Your Reading List"></p>
<p>Thanks to frameworks like React and Elm, Functional Programming (FP) has made a <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0">huge resurgence</a> in the development community. Yet very few developers understand the basics of Functional Programming beyond the <code>.map()</code> and <code>.forEach()</code> methods.</p>
<p>JavaScript is foremost a functional language, so you can stand out from the crowd of junior developers and improve your problem solving skills with an FP primer. The free <a href="https://leanpub.com/javascript-allonge/read">JavaScript Allong√©</a> eBook is a fun and elegant way to learn the essential concepts of Functional Programming from a JavaScript perspective. You‚Äôll be a <a href="https://jonathanleemartin.com/destroy-all-classes-turn-react-components-inside-out-with-functional-programming/">shoe-in for React</a> and Elm projects.</p>
<h2 id="2grokkingalgorithms">2. <a href="https://www.amazon.com/Grokking-Algorithms-illustrated-programmers-curious/dp/1617292230?tag=nybblr08-20">Grokking Algorithms</a></h2>
<p><img src="https://jonathanleemartin.com/content/images/2019/09/grokking-algorithms.jpg" alt="5 JavaScript Books You Should Add to Your Reading List"></p>
<p>More individuals than ever are joining the developer workforce from a background outside of Computer Science. While you don‚Äôt need a CS degree to be a great developer, a grounding in Computer Science can foster a love of clever problem solving and design patterns to help you write smarter code.</p>
<p>It‚Äôs unlikely you‚Äôll learn CS basics in a coding bootcamp, but you don‚Äôt need to sacrifice four years of your life and $150k on a degree!</p>
<p><a href="https://www.amazon.com/Grokking-Algorithms-illustrated-programmers-curious/dp/1617292230?tag=nybblr08-20">Grokking Algorithms</a> is a delightfully unpretentious introduction to hallmark algorithms in Computer Science.  The easy-to-follow explanations and colorful illustrations have made it a favorite with my students and mentees.</p>
<p><img src="https://dpzbhybb2pdcj.cloudfront.net/bhargava/Figures/004fig03.jpg" alt="5 JavaScript Books You Should Add to Your Reading List"></p>
<p>This is a book you shouldn‚Äôt just read. Instead, I recommend scribbling on a whiteboard and pulling up a text editor to implement the algorithm as you read. Better yet, you can code it up with a <a href="https://en.wikipedia.org/wiki/Test-driven_development">Test Driven Development</a> (TDD) approach: write tests first, then code up the solution to make the tests pass! Here‚Äôs an excellent <a href="https://github.com/dwyl/learn-tdd">introduction to TDD from the folks at dwyl</a>.</p>
<p>Grokking Algorithms is surprisingly comprehensive, but if you find algorithms as fun as my mentees have, you‚Äôll quickly run out. <a href="https://medium.com/basecs">Vaidehi Joshi‚Äôs basecs</a> project features illustrated guides to a growing list of algorithms, and was recently <a href="https://www.codenewbie.org/basecs">turned into a podcast</a>.</p>
<h2 id="3javascriptthegoodparts">3. <a href="https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742?tag=nybblr08-20">JavaScript: The Good Parts</a></h2>
<p><img src="https://jonathanleemartin.com/content/images/2019/09/javascript-the-good-parts.jpg" alt="5 JavaScript Books You Should Add to Your Reading List"></p>
<p>Stack Overflow has unintentionally become the go-to source for copy-pasting <em>bad</em> example code from JavaScript‚Äôs darker recesses. For a new web developer, it can be hard to determine which parts of JavaScript are <em>good</em> to use.</p>
<p>Douglas Crockford is one of the early titans in JavaScript development. His essential guide, <a href="https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742?tag=nybblr08-20">JavaScript: The Good Parts</a>, is the traditional book that ‚Äúevery JavaScript developer must read,‚Äù especially impressionable newcomers to the web community. As the title suggests, this book is not exhaustive‚ÄîCrockford focuses only on the <em>good</em> parts of JavaScript, leaving older JavaScript features to rot in cobwebby corners.</p>
<h2 id="4youdontknowjs">4. <a href="https://www.amazon.com/You-Dont-Know-JS-Going/dp/1491924462/?tag=nybblr08-20">You Don‚Äôt Know JS</a></h2>
<p><img src="https://jonathanleemartin.com/content/images/2019/09/you-dont-know-javascript.jpg" alt="5 JavaScript Books You Should Add to Your Reading List"></p>
<p>On the other side of the spectrum, <a href="https://github.com/getify/You-Dont-Know-JS">You Don‚Äôt Know JS</a> is a free and fairly comprehensive book series for learning modern JavaScript in its entirety. It‚Äôs still not a replacement for a dedicated coding bootcamp, but of all the reads, it requires the least prior experience in web programming.</p>
<p>For hardcore bookworms, Kyle Simpson also sells a <a href="https://www.amazon.com/You-Dont-Know-JS-Going/dp/1491924462/?tag=nybblr08-20">hard copy</a>.</p>
<h2 id="5mozilladevelopernetworktutorials">5. Mozilla Developer Network Tutorials</h2>
<p>These books focus on core JavaScript and algorithms, but don‚Äôt specifically address programming in the browser. Mozilla Developer Network (MDN) has amassed an exceptional <a href="https://developer.mozilla.org/en-US/docs/Learn">collection of guides</a> for programming in the browser. Though not strictly a book, the guides are rich with examples and links to references for the many APIs built into web browsers. The MDN guides make a fabulous supplement to any web course or bootcamp!</p>
<p>And of course, MDN is the authoritative source for <a href="https://developer.mozilla.org/en-US/docs/Web/Guide">reference documentation</a> on any browser web API.</p>
<h2 id="honorablementioneloquentjavascript">Honorable Mention: <a href="https://www.amazon.com/Eloquent-JavaScript-3rd-Introduction-Programming/dp/1593279507/?tag=nybblr08-20">Eloquent JavaScript</a></h2>
<p><img src="https://jonathanleemartin.com/content/images/2019/09/eloquent-javascript.jpg" alt="5 JavaScript Books You Should Add to Your Reading List"></p>
<p>The third edition of <a href="https://www.amazon.com/Eloquent-JavaScript-3rd-Introduction-Programming/dp/1593279507/?tag=nybblr08-20">Eloquent JavaScript</a> is out, and I‚Äôve heard nothing but praise from my students. And the <a href="https://eloquentjavascript.net/">online version</a> is free! I haven‚Äôt yet read through it, so I can‚Äôt recommend it firsthand. But at a glance, I‚Äôm impressed by Marijn Haverbeke‚Äôs elegant teaching style for some fairly complex topics.</p>
<h2 id="6booksbydeadpeople">6. Books by Dead People</h2>
<p>Reading is one of the best ways to cultivate your brain powers, so why stop with programming literature? We are continuously bombarded with the news and opinions of our time, but classic literature provides a chance to step back and glean wisdom from our collective past.</p>
<p>So read books by dead people! Here are some of my favorite classics:</p>
<ul>
<li>A Tale of Two Cities by Charles Dickens</li>
<li>War and Peace by Leo Tolstoy</li>
<li>Sense and Sensibility by Jane Austen</li>
<li>Lord of the Rings by J. R. R. Tolkein</li>
<li>Agatha Christie‚Äôs mysteries featuring Hercule Poirot</li>
</ul>
<p>Pick <em>good</em> literature to <a href="https://www.goodreads.com/quotes/227359-i-consider-that-a-man-s-brain-originally-is-like-a">fill your brain attic</a> with. If the last time you read was in high school, delight yourself with just how many subtleties you missed in your English classes. You just might watch Netflix (a little) less thanks to your newly-developed craving for reading.</p>
<hr>
<p>P.S. I wrote a book too! If you want to learn functional design patterns for Node.js backends, you can read a sample of my book, <a href="https://jonathanleemartin.com/books/">Functional Design Patterns for Express.js</a>.</p>
<p><img src="https://jonathanleemartin.com/content/images/2019/09/express-js-book.jpg" alt="5 JavaScript Books You Should Add to Your Reading List"></p>
<p>You can also check out <a href="https://www.youtube.com/channel/UCol-gOYBawJGqUn2AhwxhNg">TL;DR</a>, the JavaScript codecast series that teaches working web developers to craft exceptional software in 5 minutes a week. We cover design patterns, refactoring and development approaches at the speed of vim!</p>
<p><img src="https://jonathanleemartin.com/content/images/2019/09/tldr-javascript-screencasts.png" alt="5 JavaScript Books You Should Add to Your Reading List"></p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[02. Router Pattern]]></title><description><![CDATA[üé¨ How do you tame if-else or switch statements that grow with every feature request? üò¨ Let the Router design pattern turn your code inside out!]]></description><link>https://jonathanleemartin.com/tldr/02-router-pattern/</link><guid isPermaLink="false">5d7aa4fd07e7f908d4d4f739</guid><category><![CDATA[tl;dr]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[Design Pattern]]></category><category><![CDATA[Web]]></category><category><![CDATA[React]]></category><category><![CDATA[Node]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Wed, 18 Sep 2019 16:00:00 GMT</pubDate><media:content url="https://jonathanleemartin.com/content/images/2019/09/02-router-pattern-1.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://jonathanleemartin.com/content/images/2019/09/02-router-pattern-1.png" alt="02. Router Pattern"><p>How do you tame a group of if-else or switch statements that grows with every feature request? Let‚Äôs continue obliterating if-else statements on today‚Äôs episode of <a href="https://www.youtube.com/channel/UCol-gOYBawJGqUn2AhwxhNg">TL;DR</a>, the JavaScript codecast series that teaches working web developers to craft exceptional software in 5 minutes a week.</p>
<iframe src="https://www.youtube.com/embed/wjzl3M7-Wpw" allow="autoplay; encrypted-media" allowfullscreen width="16" height="9"></iframe>
<h3 id="transcript">Transcript</h3>
<p>Last episode we covered nested ternaries. Nested ternaries are a great replacement for if-else statements when we need the power of a conditional, but can afford to replace statements with expressions. But sometimes the number of cases just gets longer and longer.</p>
<p>Even if you extracted each case to a separate function, the function wrapping around the if-else or switch statement will continue to grow unbounded.</p>
<p>Especially in codebases that change hands often, this promotes a sloppy, inconsistent boundary between the individual cases and the mapping logic that decides which case to run.</p>
<p>Today we‚Äôre refactoring some code for a chatbot that helps outdoor enthusiasts find great trails to hike.</p>
<pre><code class="language-javascript">console.log( responder('list hikes') );
// =&gt; Lost Lake
// =&gt; Canyon Creek Meadows
console.log( responder('recommend hike') );
// =&gt; I recommend Mirror Lake.
console.log( responder('add hike Mirror Lake') );
// =&gt; Added Mirror Lake!
console.log( responder('where is Mirror Lake') );
// =&gt; Sorry, I don‚Äôt understand that.
</code></pre>
<p>So far this chatbot can respond to a few basic commands, like ‚Äúlist hikes‚Äù, ‚Äúrecommend hike‚Äù, and ‚Äúadd hike‚Äù. If you ask the chatbot something it doesn‚Äôt understand ‚Äî like ‚Äúwhere is Mirror Lake‚Äù ‚Äî it responds with a fallback message.</p>
<p>At the moment, all of this logic lives in the responder function. Our chatbot currently has 4 behaviors, so there are 3 if-else cases and one fallback return statement.</p>
<pre><code class="language-javascript">let hikes = [
  'Lost Lake',
  'Canyon Creek Meadows',
];

let randomHike = () =&gt;
  hikes[Math.floor(Math.random() * hikes.length)];

let responder = (message) =&gt; {
  if (message === 'list hikes') {
    return hikes.join('\n');
  } else if (message === 'recommend hike') {
    return `I recommend ${randomHike()}`;
  } else if (message.startsWith('add hike')) {
    let hike = message.slice(9);
    hikes.push(hike);
    return `Added ${hike}!`;
  }

  return &quot;Sorry, I don't understand that.&quot;;
};
</code></pre>
<p>This code is short right now, but that‚Äôs because our chatbot only supports 3 commands so far. It will need to understand many more commands, and each new command will add another if-else case.</p>
<p>Ballooning if-else or switch statements are a code smell that suggest the responder function might have too many responsibilities.</p>
<p>So how could we eliminate these cascading if-else statements before they grow to hundreds of cases?</p>
<p>Enter the Router. The Router is a design pattern that helps us turn a giant if-else or switch statement inside out by decoupling the responsibility of routing logic from the business logic of the individual cases.</p>
<p>The Router pattern is particularly nice because we can follow a step-by-step procedure to refactor the code, and at each step the code should still run.</p>
<p>The first step is to extract each case into a separate function and list them in a data structure, like a plain ol‚Äô JavaScript object. Let‚Äôs move the code for the 3 chatbot commands into an object called ‚Äúresponses‚Äù, using the command as the key.</p>
<pre><code class="language-javascript">let responses = {
  'list hikes': () =&gt;
    hikes.join('\n'),
  'recommend hike': () =&gt;
    `I recommend ${randomHike()}`,
  'add hike': (message) =&gt; {
    let hike = message.slice(9);
    hikes.push(hike);
    return `Added ${hike}!`;
  },
};
</code></pre>
<p>Now that we‚Äôve moved each command into responses, we can replace the cases by looking up the appropriate response function and invoking it. At this point, our code should still work exactly as before.</p>
<pre><code class="language-javascript">let responder = (message) =&gt; {
  if (message === 'list hikes') {
    return responses['list hikes']();
  } else if (message === 'recommend hike') {
    return responses['recommend hike']();
  } else if (message.startsWith('add hike')) {
    return responses['add hike'](message);
  }

  return &quot;Sorry, I don't understand that.&quot;;
};
</code></pre>
<p>We‚Äôve finished the first step ‚Äî it‚Äôs usually pretty mechanical, but it often spawns other refactors as you discover subtle side effects and hidden dependencies that need to be passed as an argument. For example, we quickly realized that the ‚Äúadd hike‚Äù command needs the rest of the chat message so it can extract the name of the hike.</p>
<p>Now for step 2: let‚Äôs collapse the cascading if-else statements. Since each response is listed with its corresponding command in the responses object, we can use the message to directly look up the appropriate response function.</p>
<pre><code class="language-javascript">let responder = (message) =&gt; {
  let response = responses[message];
  if (response) {
    return response(message);
  }

  return &quot;Sorry, I don't understand that.&quot;;
};
</code></pre>
<p>If a matching response function is found, we‚Äôll invoke it. Also, since one of our chatbot commands needs the message, we‚Äôll pass it as an argument. You‚Äôll need to find a parameter signature that works for any of your response functions, so this may take some additional refactoring. But it‚Äôs okay if a response function ignores those arguments, as the ‚Äúlist hikes‚Äù and ‚Äúrecommend hike‚Äù commands do.</p>
<p>Nice, we collapsed a 3 case if-else statement into one! In step 3 we‚Äôll eliminate the if-else statement altogether by extracting the fallback behavior into a function of its own. If no response function matched, we‚Äôll use the double pipe operator to insert the fallback response. Now that we know the response variable will always contain a function, we can invoke it unconditionally.</p>
<pre><code class="language-javascript">let fallback = () =&gt;
  &quot;Sorry, I don't understand that.&quot;;

let responder = (message) =&gt; {
  let response = responses[message] || fallback;
  return response(message);
};
</code></pre>
<p>And that‚Äôs it! The Router pattern helped us turn an if-else statement with several cases inside out. And now the responder function, which was destined to grow without bound, is a simple shell that just dispatches the message to the appropriate response function. In backend terminology, we call the responder function a ‚Äúrouter,‚Äù and the commands are called ‚Äúroutes.‚Äù</p>
<p>Unfortunately, we broke the ‚Äúadd hike‚Äù command that expects the message to include the name of the hike after the command, so our simple property lookup isn‚Äôt flexible enough.</p>
<p>To fix this, we‚Äôll convert responses to a list and use the <code>find</code> Array method to see which command the message starts with.</p>
<pre><code class="language-javascript">let responder = (message) =&gt; {
  let [command, response] = Object.entries(responses)
    .find(([command, response]) =&gt;
      message.startsWith(command)
    );
  return response(message);
};
</code></pre>
<p>Now that we‚Äôve switched to <code>startsWith</code>, we can move the fallback code to the responses object, and use an empty string as the key! We just need to make sure it comes last. Now we‚Äôve eliminated conditionals from the responder function entirely!</p>
<pre><code class="language-javascript">let responses = {
  'list hikes': ... ,
  'recommend hike': ... ,
  'add hike': ... ,
  '': () =&gt;
    &quot;Sorry, I don't understand that.&quot;
};
</code></pre>
<p>See how control flow got replaced by a data structure? That‚Äôs a recurring theme in software design: many problems that are traditionally solved with algorithmic code can be described much more elegantly with a data structure, which is easier to debug, extend and reason about.</p>
<p>In the Router pattern, the mapping data structure doesn‚Äôt even have to be an object. We could turn the responses object into an array of objects, with one object per command!</p>
<pre><code class="language-javascript">let responses = [
  {
    command: 'list hikes',
    response: () =&gt; hikes.join('\n')
  },
  {
    command: 'recommend hike',
    response: () =&gt; `I recommend ${randomHike()}`
  },
  {
    command: 'add hike',
    response: (message) =&gt; {
      let hike = message.slice(9);
      hikes.push(hike);
      return `Added ${hike}!`;
    }
  },
  {
    command: '',
    response: () =&gt;
      &quot;Sorry, I don't understand that.&quot;
  }
];
</code></pre>
<p>This format gives us flexibility: to define more complex commands, we can easily switch from strings to regular expressions, and even define capture groups for the response function to receive as an argument!</p>
<pre><code class="language-javascript">let responses = [
  {
    command: /^list hikes$/,
    response: () =&gt; hikes.join('\n')
  },
  {
    command: /^recommend hike$/,
    response: () =&gt; `I recommend ${randomHike()}`
  },
  {
    command: /^add hike (.+)$/,
    response: ([hike]) =&gt; {
      hikes.push(hike);
      return `Added ${hike}!`;
    }
  },
  {
    command: /^(.*)$/,
    response: ([message]) =&gt;
      `Sorry, I don't understand &quot;${message}&quot;.`
  }
];

let responder = (message) =&gt; {
  let { command, response } = responses
    .find(({ command, response }) =&gt;
      command.test(message)
    );
  return response(
    command.exec(message).slice(1)
  );
};
</code></pre>
<p>Not only did that simplify the code for ‚Äúadd hike‚Äù, but it provides new team members with a template for adding new commands. It‚Äôs pretty straightforward to add ‚Äúwhere is‚Äù by using ‚Äúadd hike‚Äù as a starting point.</p>
<pre><code class="language-javascript">let responses = [
  ...
  {
    command: /^where is (.+)$/,
    response: ([hike]) =&gt;
      `${hike}? Do I look like a GPS receiver?`
  },
  ...
];
</code></pre>
<p>The Router pattern helps us discover common needs across if-else cases and provide a flexible interface to DRY them up. Because the routing logic is backed by a data structure, we can do things that were previously impossible with hard-wired if-else or switch statements, like dynamically enabling particular commands at runtime.</p>
<p>And with each case extracted into a function, we can unit test each response without going through the routing logic first!</p>
<p>The Router pattern helps solve the same problems in Functional Programming that polymorphism does in Object Oriented Programming. And it pops up everywhere: in React you might use this pattern to select which component to render, on the backend you could decide which handler function to invoke for a webhook, in a Redux reducer you can delegate state updates to smaller reducers, and of course on the backend you can define routes for a particular URL.</p>
<p>Today, scan through your codebase for switch and if-else statements that tend to grow with each feature request, and use the Router pattern to turn it inside out.</p>
<p>That‚Äôs it for today. Want to keep leveling up your craft? Don‚Äôt forget to <a href="https://www.youtube.com/channel/UCol-gOYBawJGqUn2AhwxhNg">subscribe to the channel</a> for more rapid codecasts on design patterns, refactoring and development approaches.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[01. Nested Ternaries]]></title><description><![CDATA[üé¨ How many times does ‚Äúelse if‚Äù appear in your codebase? üò¨ Here‚Äôs one way you can cut down on if-else statements: nested ternary expressions!]]></description><link>https://jonathanleemartin.com/tldr/01-nested-ternaries/</link><guid isPermaLink="false">5d4888c77227345a6e4ad414</guid><category><![CDATA[tl;dr]]></category><category><![CDATA[JavaScript]]></category><category><![CDATA[Design Pattern]]></category><category><![CDATA[React]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Wed, 11 Sep 2019 16:00:00 GMT</pubDate><media:content url="https://jonathanleemartin.com/content/images/2019/09/01-nested-ternaries.png" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://jonathanleemartin.com/content/images/2019/09/01-nested-ternaries.png" alt="01. Nested Ternaries"><p>How many times does ‚Äúelse if‚Äù appear in your codebase? Let‚Äôs examine one way you can cut down on if-else statements in today‚Äôs episode of <a href="https://www.youtube.com/channel/UCol-gOYBawJGqUn2AhwxhNg">TL;DR</a>, the JavaScript codecast series that teaches working web developers to craft exceptional software in 5 minutes a week.</p>
<iframe src="https://www.youtube.com/embed/oAEfKLI8iKk" allow="autoplay; encrypted-media" allowfullscreen width="16" height="9"></iframe>
<h3 id="transcript">Transcript</h3>
<p>The if-else statement is probably the first control flow construct you learned as a programmer. And yet few things are as terrifying as diving into a legacy codebase swimming in nested, cascading if-else statements.</p>
<p>Code with fewer if-else statements is generally less complex because it has fewer edge cases that need to be tested, and code with fewer statements tends to have a more predictable program flow. A program without any if-else statements or other conditional constructs is incredibly straightforward to reason about, because data will always flow through the program in the same way, even when the inputs and output change.</p>
<p>Now it‚Äôs unlikely you could eliminate all if-else statements from a program without making readability worse off. But a lot of if-else statements is a code smell, because they unnecessarily increase the complexity and surface area for bugs.</p>
<p>So in the next few episodes of TL;DR we‚Äôll cover some design patterns to cut down on if-else statements.</p>
<p>Today we‚Äôre examining some recursive code with several cascading if-else statements.</p>
<pre><code class="language-javascript">resolve({
  user: {
    firstName: 'Jonathan',
    lastName: 'Martin',
    favoritePlaces: () =&gt; [
      'Alps',
      'PNW'
    ]
  }
});

/*
 * Spits out:
 */
{
  user: {
    firstName: 'Jonathan',
      lastName: 'Martin',
      favoritePlaces: [
        'Alps',
        'PNW'
      ]
  }
};
</code></pre>
<p>This resolve function walks through an object with nested objects, arrays and functions. Given a deeply nested structure like this, it returns a similar structure, but where the functions ‚Äî like this one for the property favoritePlaces, which was originally a function ‚Äî have been invoked and replaced with their return value.</p>
<p>Now the logic for the resolve function is pretty terse: if the current structure is an array or object, it recurses over the children. If it‚Äôs a function, it invokes it and recurses over the return value. Otherwise, it will just return the structure as-is.</p>
<pre><code class="language-javascript">let resolve = (node) =&gt; {
  if (isFunction(node)) {
    return resolve(node());
  } else if (isArray(node)) {
    return node.map(resolve);
  } else if (isObject(node)) {
    return mapValues(node, resolve);
  }
  return node;
};
</code></pre>
<p>Now these if-else statements aren‚Äôt complex per se, in fact it almost looks like it could be a switch statement instead. The problem is the testing conditions ‚Äî that is, whether the data is a function, array or object ‚Äî can‚Äôt be described with strict equality, which we would need to use a switch statement. Hence, we had to stick with if-else statements instead.</p>
<p>So if the test condition is too complex for a switch statement, is there an alternative that might at least move us away from if-else statements?</p>
<p>Well, the ternary operator is essentially an if-else expression. While an if-else statement runs statements but doesn‚Äôt return anything, a ternary expression evaluates and returns the value of one of the two expressions. Let‚Äôs write a new version of the resolve function and convert the first if-else case to a ternary: if the node is a function, the ternary evaluates to this case on the left, but otherwise it will evaluate to the case on the right, that is, the node. Like an if-else statement, only code in the matching case is evaluated ‚Äî the other is completely ignored.</p>
<p>Because JavaScript developers don‚Äôt often see ternaries used in production codebases, there is a stigma that ternaries are brittle and have finicky syntax rules. But ternaries are actually more robust than an equivalent if-else statement because you can only embed expressions, and not statements. That makes it harder to sneak a side effect in, like setting a variable or forcing an early return.</p>
<p>The main frustration for many developers is reading another developer‚Äôs one-liner ternary, so it‚Äôs essential to space them out just like you would an if-else statement.</p>
<pre><code class="language-javascript">let resolve = (node) =&gt; {
  return isFunction(node)
    ? resolve(node())
    : node;
};
</code></pre>
<p>So instead of putting all this on one line, you should indent each case like this. You‚Äôll find this convention popular in the React community for switching between components. With a little practice, a ternary becomes easier to read than the equivalent if-else statement.</p>
<p>But what about those cascading else-ifs we had before? Well since ternaries are just expressions, we can nest else-ifs in the last part of the ternary!</p>
<pre><code class="language-javascript">let resolve = (node) =&gt; {
  return isFunction(node)
    ? resolve(node())
    : (isArray(node) ? node.map(resolve) : node);
};
</code></pre>
<p>Well this is pretty awful to read, let‚Äôs fix that with some indentation. Ternaries are designed to cascade, so the parentheses are actually unnecessary. Next, let‚Äôs insert a new line after the question marks instead of before. Then unindent each line that starts with a colon so it lines up with the first line.</p>
<p>And for the final else case, the colon will be on a line by itself.</p>
<pre><code class="language-javascript">let resolve = (node) =&gt; {
  return isFunction(node) ?
    resolve(node())
  : isArray(node) ?
    node.map(resolve)
  :
    node;
};
</code></pre>
<p>Let‚Äôs practice reading this: if the node is a function, it returns the result of this line, otherwise if node is an array, it returns the result of this line, and finally if the node is neither a function nor an array, node is returned.</p>
<p>Wait a minute, we forgot to add a case for when the node is an object! Well to add it, we can just insert it before the final else.</p>
<pre><code class="language-javascript">let resolve = (node) =&gt; {
  return isFunction(node) ?
    resolve(node())
  : isArray(node) ?
    node.map(resolve)
  : isObject(node) ?
    mapValues(node, resolve)
  :
    node;
};
</code></pre>
<p>By formatting our ternaries like this, we can easily add and rearrange cases without changing other lines or fretting about nested parentheses!</p>
<p>And now that resolve is only one statement, we can drop the curlies and return keyword to make resolve an implicit returning arrow function. In this style, I like to unindent the testing conditions one more level. Now all of the test cases line up in one column, and all of the possible return values line up in another.</p>
<pre><code class="language-javascript">let resolve = (node) =&gt;
  isFunction(node) ?
    resolve(node())
: isArray(node) ?
    node.map(resolve)
: isObject(node) ?
    mapValues(node, resolve)
:
    node;
</code></pre>
<p>From a control flow perspective, we‚Äôve achieved the holy grail: the resolve function has no variables, no early returns and no statements.</p>
<p>Now you might feel that this exercise of switching from if-else statements to ternary expressions was purely aesthetic, but syntax is just a nice side benefit of the real benefits:</p>
<p>Whereas if-else statements are popular in imperative programming, which is built on control flow, ternary expressions help us think about data flow and produce more declarative code. Functions with a lot of statements tend to have several entry and exit points that new team members need to parse through to keep from introducing a bug. But functions composed of expressions tend to flow in the same way for any inputs.</p>
<p>Today, look through your codebase for cascading if-else statements where each case is roughly the same, like returning a value or setting a variable, and try swapping the if-else for nested ternaries. And in the future, I would encourage you to default to nested ternaries, and make if-else statements the exception. You‚Äôll find they force you to design your code better to begin with.</p>
<p>That‚Äôs it for today. Want to keep leveling up your craft? Don‚Äôt forget to <a href="https://www.youtube.com/channel/UCol-gOYBawJGqUn2AhwxhNg">subscribe to the channel</a> for more rapid codecasts on design patterns, refactoring and development approaches.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Don‚Äôt Over React! Render Binary Data with Class.]]></title><description><![CDATA[Eventually, your React web app will accept file uploads. JavaScript has exceptional APIs for handling chunks of binary data, but the interaction with React can cause some major performance hiccups. Discover the performance implications of 5 different ways to work with user-submitted binary data!]]></description><link>https://jonathanleemartin.com/blog/dont-over-react/</link><guid isPermaLink="false">5d476ef72ee5ff3d4aa3caf0</guid><category><![CDATA[React]]></category><category><![CDATA[JavaScript]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Tue, 05 Dec 2017 12:00:00 GMT</pubDate><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><p><small><em>This post first appeared on the <a href="https://www.bignerdranch.com/blog/dont-over-react/">Big Nerd Ranch blog</a>.</em></small></p>
<p>Sooner or later, your React web app will probably accept file uploads‚Äîperhaps to change out a user‚Äôs avatar or share images on a social site.</p>
<p>In modern browsers, the story for <a href="https://jonathanleemartin.com/blog/encore-javascript-create-an-mp3-reader-with-dataviews-textdecoder/">working with binary data is downright impressive</a> thanks to objects like <code>File</code>, <code>Blob</code> and <code>ArrayBuffer</code>. You can even store large complex binary data directly in the browser with <code>IndexedDB</code>!</p>
<p>But working with binary data in a sandboxed tab is different from how a backend or native desktop app handles it. If you read in a 5MB image to a <code>String</code>, you will probably crash the tab. Read in 10 images simultaneously and you may crash the browser!</p>
<p>Luckily, JavaScript exposes natively implemented APIs to handle chunks of binary data. With some creativity, you can have the user‚Äôs browser pull its own weight, like <a href="https://gist.github.com/nybblr/d6073b742976104113a0597fbf159e0b">resizing images on the front-end before upload</a>. But before you create your own React-powered Hipstergram, it‚Äôs important to understand the performance implications of binary data in a web app.</p>
<h2 id="recapfileobjectsandblobs">Recap: File Objects and Blobs</h2>
<p>The browser can‚Äôt directly access the file system for security reasons, but users can drop files into the browser with drag-and-drop.</p>
<p>Here‚Äôs a barebones React component that accepts a file, like an image:</p>
<pre><code class="language-jsx">let Drop = () =&gt;
  &lt;div onDragOver={e =&gt; e.preventDefault()}
       onDrop={e =&gt; {
         e.preventDefault()
         let file = e.dataTransfer.files[0]
         console.log(file)
       } }
  &gt;
    ...
  &lt;/div&gt;
</code></pre>
<p>Once the user drags-and-drops an image onto this <code>&lt;Drop&gt;</code> component, they probably expect to see a thumbnail-sized preview in the browser. The browser provides access to read in the file contents in a few formats like a <code>String</code> or <code>ArrayBuffer</code>, but each image could be 5 MB; drop 10 in the browser and you have 50 MB strings in memory!</p>
<p>So instead of directly returning a <code>String</code> or <code>ArrayBuffer</code>, the browser returns a <code>Blob</code> object. A <code>Blob</code> is essentially a pointer to a data source‚Äîit could point to a file on disk, an <code>ArrayBuffer</code>, streaming data, etc. Specifically, the <code>e.dataTransfer.files</code> array holds one or more <code>File</code> objects, which are <code>Blob</code>s with some extra metadata. <code>File</code> objects come with a few more properties, like the source file‚Äôs name.</p>
<p>To display the image in the DOM, e.g. with an <code>&lt;img /&gt;</code> tag, you can ask the browser for an ephemeral URL to the <code>Blob</code> object. This URL will only be valid while the tab is open:</p>
<pre><code class="language-jsx">...
let file = e.dataTransfer.files[0]
let url = URL.createObjectURL(file)
console.log(url)
// =&gt; &quot;blob:http://localhost:3000/266c0711-76dd-4a24-af1f-46a8014204ff&quot;
</code></pre>
<p>You can use a <code>blob:</code> URL wherever you would put any other URL‚Äîlike <code>http://localhost:3000/images/logo.png</code>‚Äîand it just works!</p>
<h2 id="thetroublewithjustrerender">The Trouble with ‚ÄúJust Rerender‚Äù</h2>
<p>How do you use <code>blob:</code> URLs in React? Here‚Äôs a simple React app that accepts a dropped image and renders it on screen:</p>
<pre><code class="language-jsx">class App extends Component {
  state = { file: null }

  onDrag = event =&gt; {
    event.preventDefault()
  }

  onDrop = event =&gt; {
    event.preventDefault()
    let file = event.dataTransfer.files[0]
    this.setState({ file })
  }

  render() {
    let { file } = this.state
    let url = file &amp;&amp; URL.createObjectURL(file)

    return (
      &lt;div onDragOver={this.onDrag} onDrop={this.onDrop}&gt;
        &lt;p&gt;Drop an image!&lt;/p&gt;
        &lt;img src={url} /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>The <code>App</code> component starts without any file; when an image file is dropped onto the <code>&lt;div&gt;</code> element, it updates the state and rerenders with a <code>Blob</code> URL. Easy peasy!</p>
<p>But what happens if this component‚Äôs props or state changes? Let‚Äôs add a counter that changes 10 times a second:</p>
<pre><code class="language-diff"> class App extends Component {
-  state = { file: null }
+  state = { file: null, counter: 0 }

+  refresh = () =&gt; {
+    this.setState(({ counter }) =&gt; ({ counter: counter + 1 }))
+  }

+  componentDidMount() {
+    this.timer = setInterval(this.refresh, 100)
+  }

+  componentWillUnmount() {
+    clearInterval(this.timer)
+  }

   onDrag = event =&gt; {
     event.preventDefault()
   }

   onDrop = event =&gt; {
     event.preventDefault()
     let file = event.dataTransfer.files[0]
     this.setState({ file })
   }

   render() {
     let { file } = this.state
     let url = file &amp;&amp; URL.createObjectURL(file)

     return (
       &lt;div onDragOver={this.onDrag} onDrop={this.onDrop}&gt;
         &lt;p&gt;Drop an image!&lt;/p&gt;
         &lt;img src={url} /&gt;
       &lt;/div&gt;
     )
   }
 }
</code></pre>
<p>This forces React to rerender the <code>&lt;App&gt;</code> component 10 times a second. That‚Äôs fine since React is designed to handle this well, but there‚Äôs a problem: the <code>blob:</code> URL changes on every rerender! We can confirm this from the Sources panel in Chrome:</p>
<p><img src="https://jonathanleemartin.com/content/images/2017/12/blob-blob-blob.png" alt="A long list of duplicate blob: URLs"></p>
<p>It seems the inline call to <code>URL.createObjectURL()</code> creates tons of extra <code>blob:</code> URLs that never get cleaned up: we‚Äôre leaking memory! Changing the URL every single rerender also causes the DOM to change, so sometimes the image will flicker since the browser‚Äôs caching mechanism doesn‚Äôt know the old and new <code>blob:</code> URLs point to the same image.</p>
<p><img src="https://jonathanleemartin.com/content/images/2017/12/high-cpu.png" alt="High CPU usage"></p>
<p>At a rerender rate of just 10 times a second, CPU usage explodes to an entire core and bloats memory usage. Eventually garbage collection will catch up, but at the cost of even more CPU usage.</p>
<h2 id="solution1memoizeinclasscomponent">Solution #1: Memoize in Class Component</h2>
<p>For our trivial example, we can introduce an easy fix: just create the <code>Blob</code> URL once and store it in the <code>&lt;App&gt;</code> component‚Äôs state:</p>
<pre><code class="language-diff"> class App extends Component {
-  state = { file: null, counter: 0 }
+  state = { url: '', counter: 0 }

   ...

   onDrop = event =&gt; {
     event.preventDefault()
     let file = event.dataTransfer.files[0]
-    this.setState({ file })
+    this.setState({ url: URL.createObjectURL(file) })
   }

   render() {
-    let { file } = this.state
-    let url = file &amp;&amp; URL.createObjectURL(file)
+    let { url } = this.state

     return (
       ...
     )
   }
 }
</code></pre>
<p>That totally works, but only if you plan to do nothing else with the data. After the file is dropped, you will likely need to pass the original <code>Blob</code> object around to other React components, perhaps to store it in <code>IndexedDB</code> or upload it with <code>FormData</code>.</p>
<h2 id="solution2itsjustanobjectaddaproperty">Solution #2: It‚Äôs Just an Object, Add a Property!</h2>
<p>What if we just passed around the immutable <code>Blob</code> object, but added a <code>url</code> property to it with the memoized <code>Blob</code> URL?</p>
<pre><code class="language-diff"> class App extends Component {
   ...

   render() {
     let { file } = this.state
-    let url = file &amp;&amp; URL.createObjectURL(file)
+    let url = file &amp;&amp; blobUrl(file)

     return (
       ...
     )
   }
 }
</code></pre>
<pre><code class="language-jsx">let blobUrl = blob =&gt; {
  if (!blob.url) {
    blob.url = URL.createObjectURL(blob)
  }
  return blob.url
}
</code></pre>
<p>That one change brings down CPU usage to near zero! But‚Ä¶ we <a href="https://jonathanleemartin.com/blog/dont-over-react/TODO/josh-justice-link-to-principle">violated a design principle</a> by modifying an object‚Äîthe <code>Blob</code> object‚Äîfrom an API that we don‚Äôt own.</p>
<h2 id="solution3globalvariable">Solution #3: Global Variable</h2>
<p>What if we passed around the <code>Blob</code> object, but instead of modifying it, we stored the generated <code>Blob</code> URL in a big lookup table that only the <code>blobUrl()</code> function can access?</p>
<p>Sounds like a global variable, right?</p>
<pre><code class="language-jsx">let hash = file =&gt; `${file.name}:${file.type}:${file.size}`

let urls = {}
let blobUrl = blob =&gt; {
  let key = hash(blob)
  if (!urls[key]) {
    urls[key] = URL.createObjectURL(blob)
  }
  return urls[key]
}
</code></pre>
<p>It‚Äôs a great idea, but difficult to execute because the keys in a Plain Ol‚Äô JavaScript Object must be strings, so we can only make a best effort at creating a collision-resistant key per <code>Blob</code> object.</p>
<p>While this will likely work for <code>File</code> objects, it won‚Äôt do for <code>Blob</code> objects: they don't have a <code>.name</code> property, so the likelihood of a key collision would be much higher.</p>
<p>The only real way to create a unique hash per <code>Blob</code> object is to tag each <code>Blob</code> object with a unique ID, but then we‚Äôre back to modifying the <code>Blob</code> object. However, we‚Äôre on the right track.</p>
<h2 id="solution4es2015maps">Solution #4: ES2015 Maps</h2>
<p>We need a map type that accepts objects as keys. The POJO won‚Äôt do that, but the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code> datatype</a> introduced in ES2015 will! Each object has a unique identity because it has its own pointer (place in memory). The <code>Map</code> datatype uses that pointer as the key, so entries are guaranteed to be collision-free!</p>
<pre><code class="language-jsx">let urls = new Map()

let blobUrl = blob =&gt; {
  if (urls.has(blob)) {
    return urls.get(blob)
  } else {
    let url = URL.createObjectURL(blob)
    urls.set(blob, url)
    return url
  }
}
</code></pre>
<p>Boom! But we introduced a subtle problem: <strong>we‚Äôre leaking memory.</strong></p>
<p>That‚Äôs right! In JavaScript we normally don‚Äôt manually manage memory, but that doesn‚Äôt ‚Äúfree‚Äù you from thinking about memory management!</p>
<p>JavaScript employs several strategies and heuristics for efficient garbage collection (like <a href="https://en.wikipedia.org/wiki/Reference_counting">reference counting</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management">generational garbage collection</a>), but we can assume that objects are garbage collected when they are no longer ‚Äúreachable.‚Äù</p>
<p>The <code>urls</code> local variable is in scope and reachable during the app‚Äôs entire lifetime. All keys and values in a <code>Map</code> stick around explicitly until removed. So unless we explicitly delete entries from the <code>Map</code>, the <code>Blob</code> objects <em>and</em> <code>blob:</code> URLs will always be reachable‚Äîthey‚Äôll never be garbage collected. We‚Äôre leaking memory!</p>
<h2 id="solution5es2015weakmaps">Solution #5: ES2015 WeakMaps</h2>
<p>What if we had a <code>Map</code> datatype that doesn‚Äôt prevent the keys from being garbage collected, and automatically deletes the key-value pair once the object becomes unreachable?</p>
<p>That‚Äôs precisely what a <code>WeakMap</code> does! It allows us to associate data with an object, but without modifying the original object. A <code>WeakMap</code> behaves like <a href="https://en.wikipedia.org/wiki/Weak_reference">weak references</a> do in Swift and Objective C. Think of them as a noncommittal friend: ‚ÄúIf no one needs you, neither do I.‚Äù</p>
<pre><code class="language-diff">-let urls = new Map()
+let urls = new WeakMap()

 let blobUrl = blob =&gt; {
   if (urls.has(blob)) {
     return urls.get(blob)
   } else {
     let url = URL.createObjectURL(blob)
     urls.set(blob, url)
     return url
   }
 }
</code></pre>
<p><code>WeakMap</code>s are a great way for third-party libraries to ‚Äútag‚Äù external objects without modifying them. They‚Äôre especially useful for adding application-wide memoization.</p>
<p>Here‚Äôs the final solution for performant, flicker-free <code>Blob</code> previews:</p>
<pre><code class="language-jsx">let urls = new WeakMap()

let blobUrl = blob =&gt; {
  if (urls.has(blob)) {
    return urls.get(blob)
  } else {
    let url = URL.createObjectURL(blob)
    urls.set(blob, url)
    return url
  }
}

class App extends Component {
  state = { file: null, counter: 0 }

  refresh = () =&gt; {
    this.setState(({ counter }) =&gt; ({ counter: counter + 1 }))
  }

  componentDidMount() {
    this.timer = setInterval(this.refresh, 100)
  }

  componentWillUnmount() {
    clearInterval(this.timer)
  }

  onDrag = event =&gt; {
    event.preventDefault()
  }

  onDrop = event =&gt; {
    event.preventDefault()
    let file = event.dataTransfer.files[0]
    this.setState({ file })
  }

  render() {
    let { file } = this.state
    let url = file &amp;&amp; blobUrl(file)

    return (
      &lt;div onDragOver={this.onDrag} onDrop={this.onDrop}&gt;
        &lt;p&gt;Drop an image!&lt;/p&gt;
        &lt;img src={url} /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>To reuse <code>blob:</code> URLs throughout your React application, just extract <code>blobUrl()</code> to its own utility file and invoke it directly from any component‚Äôs <code>render()</code> method! Or better yet, <a href="https://www.bignerdranch.com/blog/destroy-all-classes-turn-react-components-inside-out-with-functional-programming/">use stateless functional components</a>.</p>
<h2 id="wrapup">Wrap-Up</h2>
<p>JavaScript is well-equipped to deal efficiently with large chunks of memory, but you have to determine the best way to represent them. When possible, it‚Äôs best to use <code>Blob</code> URLs to keep them outside the JavaScript VM‚Äôs memory. Objects stored in global variables will never be garbage collected, but <code>WeakMap</code>s are a great solution to <a href="https://en.wikipedia.org/wiki/Reference_counting#reference_cycle">break reference cycles</a>.</p>
<p>ES2015 data structures like <code>WeakMap</code>s and <a href="https://www.bignerdranch.com/blog/cross-stitching-elegant-concurrency-patterns-for-javascript/">ES2017 async functions</a> highlight just how dedicated the JavaScript language is to high-performance modern application development!</p>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[DESTROY ALL CLASSES: Turn React Components Inside Out with Functional Programming]]></title><description><![CDATA[With React's stateless functional components you can create ambitious apps that are 98% plain ol' JavaScript. In this real-world example, we'll use functional programming and higher-order components to turn class-based React Components into stateless functional components.]]></description><link>https://jonathanleemartin.com/blog/destroy-all-classes-turn-react-components-inside-out-with-functional-programming/</link><guid isPermaLink="false">5d476ef72ee5ff3d4aa3caf9</guid><category><![CDATA[React]]></category><category><![CDATA[JavaScript]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Wed, 19 Jul 2017 12:00:00 GMT</pubDate><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><p><small><em>This post first appeared on the <a href="https://www.bignerdranch.com/blog/destroy-all-classes-turn-react-components-inside-out-with-functional-programming/">Big Nerd Ranch blog</a>.</em></small></p>
<p><em>A real-world example of refactoring a class-based component from a React Native app into stateless functional components and higher-order components, in 5 steps.</em></p>
<p><a href="https://facebook.github.io/react/">React</a> is pretty awesome, and with <a href="https://facebook.github.io/react/docs/components-and-props.html#functional-and-class-components">stateless functional components</a> you can create ambitious apps that are 98% plain ol' JavaScript (optionally JSX), and are very <em>lightly</em> coupled to the framework.</p>
<p>Minimizing the surface area between React and your codebase has amazing benefits:</p>
<ol>
<li>Framework updates will have little effect on your code.</li>
<li>You can easily write isolated unit tests, instead of UI integration tests.</li>
</ol>
<p>There's an important catch to stateless functional components: you can't use state or lifecycle hooks. However, this design encourages component purity and makes it trivial to test our components ‚Äî after all, it's just a function that maps data to virtual DOM!</p>
<blockquote>
<p>‚ÄúGreat, but I'm not building a static page ‚Äî I need state, so I can‚Äôt use stateless functional components!‚Äù</p>
</blockquote>
<p>In a well-written React app, stateless functional components will cover most of your UI code, but an app's complexity typically relates to state management. To help bug-proof the remainder of our codebase, we are going to turn class-based React Components into stateless functional components with <strong>functional programming</strong> and <strong>higher-order components</strong> (HOC) to isolate state from our pure components.</p>
<p>If you aren't familiar with higher-order components, you may want to check out <a href="https://facebook.github.io/react/docs/higher-order-components.html">the official React guides</a> first.</p>
<h2 id="whatarethebenefits">What are the benefits?</h2>
<p>Why will destroying all classes with functional programming and higher-order components improve your codebase?</p>
<p>Imagine an app where all state is isolated, the rest of your app is a pure function of that state, and each layer of your component tree is trivial to debug directly from the React DevTools. Relish the thought of reliable hot module reloading in your React Native app.</p>
<p>Higher-order components are the ultimate incarnation of <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">composition over inheritance</a>, and in the process of turning our class components inside-out, subtle dependencies and nasty bugs pop right to the surface.</p>
<p>By avoiding classes, we can prevent a super common source of bugs: <strong>hidden state.</strong> We‚Äôll also find testing gets easier as the software boundaries become self-evident.</p>
<p>Because higher-order components add behavior through composition, you can reuse complex state logic across different UIs and test it in isolation! For example, you can share a data fetching higher-order component between your React web app and React Native app.</p>
<h2 id="examplerefactoringareactnativecomponent">Example: Refactoring a React Native component</h2>
<p>Let's look at a real-world example from a React Native project. The <code>VideoPage</code> component is a screen in the mobile app that fetches videos from a backend API and displays them as a list. The component has been tidied up a bit to remove distractions, but is unchanged structurally.</p>
<pre><code class="language-jsx">import React, { Component } from 'react'
import { ScrollView, Text, View } from 'react-native'

import Loading from 'components/loading'
import Video from 'components/video'
import API from 'services/api'

class VideoPage extends Component {
  constructor(props) {
    super(props)
    this.state = { data: null }
  }

  async fetchData(id) {
    let res = await API.getVideos(id)
    let json = await res.json()
    this.setState({ data: json.videos })
  }

  componentWillMount() {
    this.fetchData(this.props.id)
  }

  renderVideo(video) {
    return (
      &lt;Video key={video.id} data={video} /&gt;
    )
  }

  renderVideoList() {
    if (this.state.data.videos.length &gt; 0) {
      return this.state.data.videos.map(video =&gt;
        this.renderVideo(video)
      )
    } else {
      return (
        &lt;View&gt;
          &lt;Text&gt;No videos found&lt;/Text&gt;
        &lt;/View&gt;
      )
    }
  }

  buildPage() {
    if (this.state.data) {
      return (
        &lt;ScrollView&gt;
          &lt;View&gt;
            &lt;Text&gt;{this.state.data.title}&lt;/Text&gt;
            { this.state.data.description ? &lt;Text&gt;{this.state.data.description}&lt;/Text&gt; : null }
          &lt;/View&gt;
          &lt;View&gt;
            {this.renderVideoList()}
          &lt;/View&gt;
        &lt;/ScrollView&gt;
      )
    } else {
      return &lt;Loading /&gt;
    }
  }

  render() {
    return this.buildPage()
  }
}

export default VideoPage
</code></pre>
<p>At 65 lines of code, the <code>VideoPage</code> component is pretty simple, but hides a lot of edge cases. Although there's some syntactic noise that could be removed to bring down the line count a bit, the deeper issue is the high branching complexity and conflation of responsibilities. This single component fetches data, branches on load status and video count, and renders the list of videos. It's tricky to test these behaviors and views in isolation, extract behaviors (like data fetching) for reuse or add performance optimizations.</p>
<p>Rather than jump to the end solution, it's more instructive to see the process. Here's our <em>five-step roadmap</em> to turn <code>VideoPage</code> inside out and <em>destroy all classes!</em></p>
<ol>
<li><strong>Turn instance methods into stateless functional components</strong></li>
<li><strong>Extract remaining instance methods to plain functions</strong></li>
<li><strong>Extract branching complexity with higher-order components</strong></li>
<li><strong>Create a data fetching higher-order component</strong></li>
<li><strong>Compose behaviors into a single <code>enhance()</code> function</strong></li>
</ol>
<h3 id="1turninstancemethodsintostatelessfunctionalcomponents">1. Turn instance methods into stateless functional components</h3>
<p>Our first step is to cut down on instance methods, so let's start by extracting <code>.buildPage()</code>, <code>.renderVideo()</code> and <code>.renderVideoList()</code> from the <code>VideoPage</code> class and make them top-level functions.</p>
<pre><code class="language-diff"> class VideoPage extends Component {
   ...

-  renderVideo(video) {
-    ...
-  }

-  renderVideoList() {
-    ...
-  }

-  buildPage() {
-    ...
-  }

   ...
 }

+let renderVideo = video =&gt; {
+  ...
+}

+let renderVideoList = () =&gt; {
+  ...
+}

+let buildPage = () =&gt; {
+  ...
+}
</code></pre>
<p>Hmm, those look like components now! Let's rename <code>renderVideoList()</code> and inline <code>renderVideo()</code>.</p>
<pre><code class="language-diff">-let renderVideo = video =&gt; { ... }

-let renderVideoList = () =&gt; {
+let VideoList = () =&gt; {
   if (this.state.data.videos.length &gt; 0) {
     return this.state.data.videos.map(video =&gt;
-      this.renderVideo(video)
+      &lt;Video key={video.id} data={video} /&gt;
     )
   } else {
</code></pre>
<p>Now that the new <code>VideoList</code> component doesn't have access to <code>this</code>, we need to directly pass the data it needs as props. A quick scan through the code shows we just need the list of <code>videos</code>.</p>
<pre><code class="language-diff">-let VideoList = () =&gt; {
+let VideoList = ({ videos }) =&gt; {
-  if (this.state.data.videos.length &gt; 0) {
+  if (videos.length &gt; 0) {
-    return this.state.data.videos.map(video =&gt;
+    return videos.map(video =&gt;
</code></pre>
<p>Hey look, we have a pure component now! Let's do the same to <code>buildPage()</code>, which is really the heart of the <code>VideoPage</code> component.</p>
<pre><code class="language-diff">-let buildPage = () =&gt; {
+let VideoPage = ({ data }) =&gt; {
-  if (this.state.data) {
+  if (data) {
     return (
       &lt;ScrollView&gt;
         &lt;View&gt;
-          &lt;Text&gt;{this.state.data.title}&lt;/Text&gt;
+          &lt;Text&gt;{data.title}&lt;/Text&gt;
-          { this.state.data.description ? &lt;Text&gt;{this.state.data.description}&lt;/Text&gt; : null }
+          { data.description ? &lt;Text&gt;{data.description}&lt;/Text&gt; : null }
         &lt;/View&gt;
         &lt;View&gt;
-          {this.renderVideoList()}
+          &lt;VideoList videos={data.videos} /&gt;
         &lt;/View&gt;
       &lt;/ScrollView&gt;
     )
</code></pre>
<p>To finish wiring things up, let's rename the original <code>VideoPage</code> class component to <code>VideoPageContainer</code> and change the <code>render()</code> method to return our new stateless functional <code>VideoPage</code> component.</p>
<pre><code class="language-diff">-class VideoPage extends Component {
+class VideoPageContainer extends Component {

   ...

   render() {
-    return this.buildPage()
+    return &lt;VideoPage data={this.state.data} /&gt;
   }
 }

-export default VideoPage
+export default VideoPageContainer
</code></pre>
<p>So far, here's what we have:</p>
<pre><code class="language-jsx">import React, { Component } from 'react'
import { ScrollView, Text, View } from 'react-native'

import Loading from 'components/loading'
import Video from 'components/video'
import API from 'services/api'

class VideoPageContainer extends Component {
  constructor(props) {
    super(props)
    this.state = { data: null }
  }

  async fetchData(id) {
    let res = await API.getVideos(id)
    let json = await res.json()
    this.setState({ data: json.videos })
  }

  componentWillMount() {
    this.fetchData(this.props.id)
  }

  render() {
    return &lt;VideoPage data={this.state.data} /&gt;
  }
}

let VideoList = ({ videos }) =&gt; {
  if (videos.length &gt; 0) {
    return videos.map(video =&gt;
      &lt;Video key={video.id} data={video} /&gt;
    )
  } else {
    return (
      &lt;View&gt;
        &lt;Text&gt;No videos found&lt;/Text&gt;
      &lt;/View&gt;
    )
  }
}

let VideoPage = ({ data }) =&gt; {
  if (data) {
    return (
      &lt;ScrollView&gt;
        &lt;View&gt;
          &lt;Text&gt;{data.title}&lt;/Text&gt;
          { data.description ? &lt;Text&gt;{data.description}&lt;/Text&gt; : null }
        &lt;/View&gt;
        &lt;View&gt;
          &lt;VideoList videos={data.videos} /&gt;
        &lt;/View&gt;
      &lt;/ScrollView&gt;
    )
  } else {
    return &lt;Loading /&gt;
  }
}

export default VideoPageContainer
</code></pre>
<p>We have successfully split the monolithic <code>VideoPage</code> component into several subcomponents, most of which are pure and stateless. This dichotomy of <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">smart vs. dumb components</a> will set the stage nicely for further refactoring.</p>
<h3 id="2extractremaininginstancemethodstoplainfunctions">2. Extract remaining instance methods to plain functions</h3>
<p>What about the remaining instance methods? Let's move the <code>.fetchData()</code> method outside the class to a top-level function and rewire <code>componentDidMount()</code> to invoke it.</p>
<pre><code class="language-diff">-  componentWillMount() {
+  async componentWillMount() {
-    this.fetchData(this.props.id)
+    this.setState({ data: await model(this.props) })
   }
 }

 ...

-async fetchData(id) {
+let model = async ({ id }) =&gt; {
   let res = await API.getVideos(id)
   let json = await res.json()
-  this.setState({ data: json.videos })
+  return json.videos
 }
</code></pre>
<p>Since we need the lifecycle hook to instantiate data fetching, we can't pull out the <code>.componentWillMount()</code> method, but at least the logic for how to fetch the data is extracted.</p>
<h3 id="3extractbranchingcomplexitywithhigherordercomponents">3. Extract branching complexity with higher-order components</h3>
<p>The <code>VideoList</code> component could stand to be broken down into subcomponents so it's easier to debug the <code>if</code> branches. Let's extract the two cases into their own stateless functional components:</p>
<pre><code class="language-diff">+let VideoListBase = ({ videos }) =&gt;
+  &lt;View&gt;
+    { videos.map(video =&gt;
+      &lt;Video key={video.id} data={video} /&gt;
+    ) }
+  &lt;/View&gt;
+
+let NoVideosFound = () =&gt;
+  &lt;View&gt;
+    &lt;Text&gt;No videos found&lt;/Text&gt;
+  &lt;/View&gt;
+
 let VideoList = ({ videos }) =&gt; {
   if (videos.length &gt; 0) {
-    return videos.map(video =&gt;
-      &lt;Video key={video.id} data={video} /&gt;
-    )
+    return &lt;VideoListBase videos={videos} /&gt;
   } else {
-    return (
-      &lt;View&gt;
-        &lt;Text&gt;No videos found&lt;/Text&gt;
-      &lt;/View&gt;
-    )
+    return &lt;NoVideosFound /&gt;
   }
 }
</code></pre>
<p>Hmm, the current <code>VideoList</code> component is nothing more than an <code>if</code> statement, which is a common component <em>behavior.</em> And thanks to functional programming, behaviors are easy to reuse through higher-order components.</p>
<p>There's a great library for reusable behavior like branching: <a href="https://github.com/acdlite/recompose">Recompose</a>. It's a <em>lightly</em> coupled utility library for creating higher-order <em>components</em> (which are really just higher-order <em>functions</em>).</p>
<p>Let's replace <code>VideoList</code> with the <code>branch</code> higher-order component.</p>
<pre><code class="language-diff">+import { branch, renderComponent } from 'recompose'

-let VideoList = ({ videos }) =&gt; {
-  if (videos.length &gt; 0) {
-    return &lt;VideoListBase videos={videos} /&gt;
-  } else {
-    return &lt;NoVideosFound /&gt;
-  }
-}
+let VideoList = branch(
+  ({ videos }) =&gt; videos.length === 0,
+  renderComponent(NoVideosFound)
+)(VideoListBase)
</code></pre>
<p>When there are no videos, the <code>branch()</code> higher-order component will render the <code>NoVideosFound</code> component. Otherwise, it will render <code>VideoListBase</code>.</p>
<p>A higher-order component is usually curried. The first invocation accepts any number of configuration arguments ‚Äî like a test function ‚Äî and the second invocation accepts only one argument: the base component to wrap. Currying doesn't seem to gain us anything yet, but later when we stack several higher-order components together, the currying convention will save us some boilerplate and make testing really elegant.</p>
<p>Take a look at some of these <a href="https://github.com/acdlite/recompose/wiki/Recipes">Recompose recipes</a> for more inspiration.</p>
<h3 id="4createadatafetchinghigherordercomponent">4. Create a data fetching higher-order component</h3>
<p>We're nearly done! <code>VideoPageContainer</code> is now a generic, reusable &quot;smart component&quot; that fetches data asynchronously and passes it as a prop to another component. Let's turn <code>VideoPageContainer</code> into our own higher-order component, called <code>withModel()</code>:</p>
<pre><code class="language-diff">+let withModel = (model, initial) =&gt; BaseComponent =&gt;
-  class VideoPageContainer extends Component {
+  class WithModel extends Component {
     constructor(props) {
       super(props)
-      this.state = { data: null }
+      this.state = { data: initial }
     }

     ...

     render() {
-      return &lt;VideoPage data={this.state.data} /&gt;
+      return &lt;BaseComponent data={this.state.data} /&gt;
     }
   }
 }
</code></pre>
<p>The function signature of <code>withModel()</code> indicates that the first invocation should provide a function for fetching the necessary data, followed by an initial value for the data while it is loading. The second invocation takes the component to wrap, and returns a brand new component with data fetching behavior.</p>
<p>To use <code>withModel()</code>, let's invoke it with the <code>VideoPage</code> stateless functional component and export the result.</p>
<pre><code class="language-diff">-export default VideoPageContainer
+export default withModel(model, null)(VideoPage)
</code></pre>
<p>The <code>withModel()</code> higher-order component will definitely be useful for other components in the app, so it should be moved to its own file!</p>
<h3 id="5composebehaviorsintoasingleenhancefunction">5. Compose behaviors into a single <code>enhance()</code> function</h3>
<p>Currying the <code>withModel()</code> higher-order component has an elegant benefit: we can stack more &quot;behaviors&quot; with Recompose utilities! Similar to our work with the <code>VideoList</code> and <code>NoVideosFound</code> components, let's extract the <code>if (data)</code> edge cases from <code>VideoPage</code> with the <code>branch()</code> higher-order component to render the <code>Loading</code> component while the data is being fetched:</p>
<pre><code class="language-diff">-import { branch, renderComponent } from 'recompose'
+import { branch, renderComponent, compose } from 'recompose'

 ...

-let VideoPage = ({ data }) =&gt; {
+let VideoPage = ({ data }) =&gt;
-  if (data) {
-    return (
   &lt;ScrollView&gt;
     ...
   &lt;/ScrollView&gt;
-    )
-  } else {
-    return &lt;Loading /&gt;
-  }
-}

+export let enhance = compose(
+  withModel(model, null),
+  branch(
+    ({ data }) =&gt; !data,
+    renderComponent(Loading)
+  )
+)

-export default withModel(model, null)(VideoPage)
+export default enhance(VideoPage)
</code></pre>
<p>The <code>compose()</code> utility saves us from deeply nested parentheses and linearizes stacked behaviors into a single function, conventionally called <code>enhance()</code>. Hurray for clean <code>git diff</code>s!</p>
<p>And now the <code>VideoPage</code> &quot;dumb component&quot; focuses solely on the happy path: when there is data and at least one video to display. By reading the <code>enhance</code> function from top to bottom, we can quickly parse out other behaviors or even add new ones, e.g. performance optimizations with <a href="https://github.com/acdlite/recompose/blob/master/docs/API.md#onlyupdateforkeys"><code>onlyUpdateForKeys()</code></a>.</p>
<h2 id="finalresult">Final result</h2>
<p>After a few more tweaks, here is the <strong>completed <code>VideoPage</code> component</strong> in 52 lines of code (also <a href="https://github.com/nybblr/destroy-all-classes">on Github</a>):</p>
<pre><code class="language-jsx">import React from 'react'
import { ScrollView, Text, View } from 'react-native'
import { compose, branch, renderComponent } from 'recompose'

import Loading from 'components/loading'
import Video from 'components/video'
import API from 'services/api'
import withModel from 'lib/with-model'

let VideoPage = ({ data }) =&gt;
  &lt;ScrollView&gt;
    &lt;View&gt;
      &lt;Text&gt;{data.title}&lt;/Text&gt;
      { data.description ? &lt;Text&gt;{data.description}&lt;/Text&gt; : null }
    &lt;/View&gt;
    &lt;View&gt;
      &lt;VideoList videos={data.videos} /&gt;
    &lt;/View&gt;
  &lt;/ScrollView&gt;

let VideoListBase = ({ videos }) =&gt;
  &lt;View&gt;
    { videos.map(video =&gt;
      &lt;Video key={video.id} data={video} /&gt;
    ) }
  &lt;/View&gt;

let NoVideosFound = () =&gt;
  &lt;View&gt;
    &lt;Text&gt;No videos found&lt;/Text&gt;
  &lt;/View&gt;

let VideoList = branch(
  ({ videos }) =&gt; videos.length === 0,
  renderComponent(NoVideosFound)
)(VideoListBase)

let model = async ({ id }) =&gt; {
  let res = await API.getVideos(id)
  let json = await res.json()
  return json.videos
}

export let enhance = compose(
  withModel(model, null),
  branch(
    ({ data }) =&gt; !data,
    renderComponent(Loading)
  )
)

export default enhance(VideoPage)
</code></pre>
<p>Not bad! At a glance, we can see the happy path for rendering <code>VideoPage</code>, how it fetches data, and how it handles the load state. When we add new behaviors in the future, we will only <em>add</em> new code instead of <em>modifying</em> existing code. So in a way, <em>functional programming helps you write immutable code!</em></p>
<p>Interestingly, every component and function (except <code>model()</code>) is an arrow function with an implied return. This isn't just about syntactic noise: the implied return makes it harder to sneak in side effects! The code looks like a strict &quot;data in, data out&quot; pipeline. The implied return also discourages you from assigning to local variables, so it is hard for ugly interfaces to hide when all destructuring must happen in the parameter list. And to add impure behaviors like performance optimization or handlers, you are naturally forced to use higher-order components.</p>
<p>We can even test the component's <code>enhance</code>r in isolation by stubbing out the <code>VideoPage</code> component:</p>
<pre><code class="language-jsx">import { enhance } from 'components/video-page'

it('renders when there is data', () =&gt; {
  let Stub = () =&gt; &lt;a&gt;TDD FTW&lt;/a&gt;

  let Enhanced = enhance(Stub)

  /* Perform assertions! */
})
</code></pre>
<p>Back when rendering was tangled up in instance methods, our only hope of extracting behaviors was through inheritance, e.g. mixins. But now we can reuse behaviors through straightforward function composition. The inside-out transformation also highlights that <code>VideoList</code> should be extracted to its own module, <code>video-list.js</code>.</p>
<h2 id="itsawraperrsandwich">It's a wrap, err, sandwich</h2>
<p>Functional programming recipes and patterns go a long way to creating elegant, resilient and test-friendly code by minimizing the surface area between our code and the framework. Whether you are creating a React web app or React Native app, higher-order components are a particularly powerful technique because they encourage <em>composition over inheritance.</em></p>
<p>With functional programming, we can build React components that resemble a tasty sandwich, where we can peel back each ingredient and debug layer-by-layer.</p>
<p>By contrast, class-based components are a burrito wrap with potato salad.</p>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Cross Stitching: Elegant Concurrency Patterns for JavaScript]]></title><description><![CDATA[You've probably heard statements like "JavaScript is a toy language, it doesn't support multithreading!" But in fact, JavaScript is tailor-made for concurrency. You'll need some patterns to write concurrent code that is performant and readable. Enter the Async IIFE.]]></description><link>https://jonathanleemartin.com/blog/cross-stitching-elegant-concurrency-patterns-for-javascript/</link><guid isPermaLink="false">5d476ef72ee5ff3d4aa3cafb</guid><category><![CDATA[JavaScript]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Thu, 01 Jun 2017 12:00:00 GMT</pubDate><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><p><small><em>This post first appeared on the <a href="https://www.bignerdranch.com/blog/cross-stitching-elegant-concurrency-patterns-for-javascript/">Big Nerd Ranch blog</a>.</em></small></p>
<p><em>&quot;JavaScript is single-threaded, so it doesn't scale. JavaScript is a toy language because it doesn't support multithreading.&quot;</em> Outside (and inside) the web community, statements like these are common.</p>
<p>And in a way, it's true: JavaScript‚Äôs event loop means your program does <strong>one thing at a time.</strong> This intentional design decision shields us from an entire class of multithreading woes, but it has also birthed the misconception that JavaScript can‚Äôt handle concurrency.</p>
<p>But in fact, JavaScript's design is well-suited for solving a plethora of concurrency problems without succumbing to the &quot;gotchas&quot; of other multithreaded languages. You might say that JavaScript is single-threaded‚Ä¶ just so it can be multithreaded!</p>
<h2 id="recapconcurrency">Recap: Concurrency</h2>
<p>You may want to do some homework if &quot;<a href="https://en.wikipedia.org/wiki/Concurrent_computing">concurrency</a>&quot; and &quot;<a href="https://en.wikipedia.org/wiki/Parallel_computing">parallelism</a>&quot; are new to your vocabulary. <strong>TL;DR:</strong> for simple programs, we usually write &quot;sequential&quot; or (&quot;serial&quot;) code: one step executes at a time, and must complete before the next step begins. If JavaScript could perform a &quot;blocking&quot; AJAX request with <code>ajaxSync()</code>, serial code might look like this:</p>
<pre><code class="language-javascript">console.log('About to make a request.');
let json = ajaxSync('https://api.google.com/search.json');
console.log(json);
console.log('Finished the request.');

/*
  =&gt; About to make a request.
  ... AJAX request runs ...
  ... a couple seconds later ...
  ... AJAX request finishes ...
  =&gt; { all: ['the', 'things'] }
  =&gt; Finished the request.
*/
</code></pre>
<p>Until the AJAX request completes, JavaScript pauses (or &quot;blocks&quot;) any lines below from executing. In contrast, concurrency is when the execution of one series of steps can overlap another series of steps. In JavaScript, concurrency is often accomplished with async Web APIs and a callback:</p>
<pre><code class="language-javascript">console.log('About to make a request.');
ajaxAsync('https://api.google.com/search.json', json =&gt; {
  console.log(json);
  console.log('Finished the request.');
});
console.log('Started the request.');

/*
  =&gt; About to make a request.
  ... AJAX request runs in the background ...
  =&gt; Started the request.
  ... a couple seconds later ...
  ... AJAX requests finishes ...
  =&gt; { all: ['the', 'things'] }
  =&gt; Finished the request.
*/
</code></pre>
<p>In this second version, the AJAX request only &quot;blocks&quot; the code <em>inside</em> the callback (logging the AJAX response), but the JavaScript runtime will go on executing lines after the AJAX request.</p>
<h2 id="recapeventloop">Recap: Event Loop</h2>
<p>The JavaScript runtime uses a mechanism, called the &quot;<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">event loop</a>,&quot; to keep track of all in-progress async operations so it can notify your program when an operation finishes. If you are unfamiliar with the event loop, check out Philip Robert's exceptional 20 minute overview from ScotlandJS: &quot;<a href="https://vimeo.com/96425312">Help, I'm stuck in an event-loop</a>.&quot;</p>
<p>Thanks to the event loop, a single thread can perform an admirable amount of work concurrently. But why not just reach for multithreading?</p>
<p>Software is harder to write (and debug) when it constantly switches between different tasks through multithreading. So unlike many languages, JavaScript finishes one thing at a time‚Äîa constraint called &quot;run-to-completion&quot;‚Äîand queues up other things to do in the background. Once the current task is done, it grabs the next chunk of work off the queue and executes to completion.</p>
<p>Since the JavaScript runtime never interrupts code that is already executing on the call stack, you can be sure that shared state (like global variables) won't randomly change mid-function‚Äî<a href="https://en.wikipedia.org/wiki/Reentrancy_(computing)">reentrancy</a> isn't even a thing! Run-to-completion makes it easy to reason about highly concurrent code, for which reason Node.js is so popular for backend programming.</p>
<p>Although your JavaScript code is single-threaded and only does one thing at a time, <em>the JavaScript Runtime and Web APIs are multithreaded!</em> When you pass a callback function to <code>setTimeout()</code> or start an AJAX request with <code>fetch()</code>, you are essentially spinning up a background thread in the runtime. Once that background thread completes, and once the current call stack finishes executing, your callback function is pushed onto the (now empty) call stack and run-to-completion. So your JavaScript code itself is single-threaded, but it <em>orchestrates</em> legions of threads!</p>
<p>However, we need some patterns to write concurrent code that is performant <em>and</em> readable.</p>
<h2 id="recappromisechaining">Recap: Promise Chaining</h2>
<p>Suppose we are building a media library app in the browser and are writing a function called <code>updateMP3Meta()</code> that will read in an MP3 file, parse out some <a href="https://jonathanleemartin.com/blog/encore-javascript-create-an-mp3-reader-with-dataviews-textdecoder/">ID3 metadata</a> (e.g. song title, composer, artist) and update a matching <code>Song</code> record in the database. Assuming the <code>read()</code>, <code>parseMP3()</code> and <code>Song.findByName()</code> functions return <code>Promise</code>s, we could implement it like this:</p>
<pre><code class="language-javascript">let read     = (path) =&gt; { ... }; // returns a Promise
let parseMP3 = (file) =&gt; { ... }; // returns a Promise
let Song = {
  findByName(name) { ... } // returns a Promise
};

let updateMP3Meta = (path) =&gt; {
  return read(path)
    .then(file =&gt; {
      return parseMP3(file).then(meta =&gt; {
        return Song.findByName(file.name).then(song =&gt; {
          Object.assign(song, meta);
          return song.save();
        });
      });
    });
};
</code></pre>
<p>It does the job, but nested <code>.then()</code> callbacks quickly turn into callback hell and obscure intent‚Ä¶ and bugs. We might try using <code>Promise</code> chaining to flatten the callback chain:</p>
<pre><code class="language-javascript">let updateMP3Meta = (path) =&gt; {
  return read(path)
    .then(file =&gt; parseMP3(file))
    .then(meta =&gt; Song.findByName(file.name))
    .then(song =&gt; {
      Object.assign(song, meta);
      return song.save();
    });
};
</code></pre>
<p>This reads nicely, but unfortunately it won't work: we can't access the <code>file</code> variable from the second <code>.then()</code> callback, nor <code>meta</code> from the third <code>.then()</code> anymore! <code>Promise</code> chaining can tame callback hell, but only by forfeiting JavaScript's closure superpowers. It's hardly ideal‚Äîlocal variables are the bread-and-butter of state management in functional programming.</p>
<h2 id="recapasyncfunctions">Recap: Async Functions</h2>
<p>Luckily, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">ES2017 <code>async</code> functions</a> merge the benefits of both approaches. Rewriting our <code>updateMP3Meta()</code> as an <code>async</code> function yields:</p>
<pre><code class="language-javascript">let updateMP3Meta = async (path) =&gt; {
  let file = await read(path);
  let meta = await parseMP3(file);
  let song = await Song.findByName(file.name);
  Object.assign(song, meta);
  return song.save();
};
</code></pre>
<p>Hurray! <code>async</code> functions give us local scoping back without descending into callback hell.</p>
<p>However, <code>updateMP3Meta()</code> unnecessarily forces some things to run serially. In particular, MP3 parsing and searching the database for a matching <code>Song</code> can actually be done in parallel; but the <code>await</code> operator forces <code>Song.findByName()</code> to run only after <code>parseMP3()</code> finishes.</p>
<h2 id="workinginparallel">Working in Parallel</h2>
<p>To get the most out of our single-threaded program, we need to invoke JavaScript's event loop superpowers. We can queue two async operations and wait for both to complete:</p>
<pre><code class="language-javascript">let updateMP3Meta = (path) =&gt; {
  return read(path)
    .then(file =&gt; {
      return Promise.all([
        parseMP3(file),
        Song.findByName(file.name)
      ]);
    })
    .then(([meta, song]) =&gt; {
      Object.assign(song, meta);
      return song.save();
    });
};
</code></pre>
<p>We used <code>Promise.all()</code> to wait for concurrent operations to finish, then aggregated the results to update the <code>Song</code>. <code>Promise.all()</code> works just fine for a few concurrent spots, but code quickly devolves when you alternate between chunks of code that can be executed concurrently and others that are serial. This intrinsic ugliness is not much improved with <code>async</code> functions:</p>
<pre><code class="language-javascript">let updateMP3Meta = async (path) =&gt; {
  let file = await read(path);
  let metaPromise = parseMP3(file);
  let songPromise = Song.findByName(file.name);

  let meta = await metaPromise;
  let song = await songPromise;

  Object.assign(song, meta);
  return song.save();
};
</code></pre>
<p>Instead of using an inline <code>await</code>, we used <code>[meta|song]Promise</code> local variables to begin an operation without blocking, then <code>await</code> both promises. While <code>async</code> functions make concurrent code easier to read, there is an underlying structural ugliness: we are manually telling JavaScript what parts can run concurrently, and when it should block for serial code. It's okay for a spot or two, but when multiple chunks of serial code can be run concurrently, it gets incredibly unruly.</p>
<p>We are essentially deriving the <a href="https://en.wikipedia.org/wiki/Dependency_graph#Deriving_an_evaluation_order">evaluation order of a dependency tree</a>‚Ä¶ and hardcoding the solution. This means &quot;minor&quot; changes, like swapping out a synchronous API for an async one, will cause drastic rewrites. That's a code smell!</p>
<h2 id="realcode">Real Code</h2>
<p>To demonstrate this underlying ugliness, let's try a more complex example. I recently worked on an <a href="https://jonathanleemartin.com/blog/encore-javascript-create-an-mp3-reader-with-dataviews-textdecoder/">MP3 importer</a> in JavaScript that involved a fair amount of async work. (Check out <a href="https://jonathanleemartin.com/blog/encore-javascript-create-an-mp3-reader-with-dataviews-textdecoder/">my blog post</a> or the <a href="https://github.com/bignerdranch/id3-meta">parser source code</a> if you're interested in working with binary data and text encodings.)</p>
<p>The main function takes in a <code>File</code> object (from drag-and-drop), loads it into an <code>ArrayBuffer</code>, parses MP3 metadata, computes the MP3's duration, creates an <code>Album</code> in <code>IndexedDB</code> if one doesn't already exist, and finally creates a new <code>Song</code>:</p>
<pre><code class="language-javascript">import parser from 'id3-meta';
import read from './file-reader';
import getDuration from './duration';
import { mapSongMeta, mapAlbumMeta } from './meta';
import importAlbum from './album-importer';
import importSong from './song-importer';

export default async (file) =&gt; {
  // Read the file
  let buffer = await read(file);

  // Parse out the ID3 metadata
  let meta = await parser(file);
  let songMeta = mapSongMeta(meta);
  let albumMeta = mapAlbumMeta(meta);

  // Compute the duration
  let duration = await getDuration(buffer);

  // Import the album
  let albumId = await importAlbum(albumMeta);

  // Import the song
  let songId = await importSong({
    ...songMeta, albumId, file, duration, meta
  });

  return songId;
};
</code></pre>
<p>This looks straightforward enough, but we're forcing some async operations to run sequentially that can be executed concurrently. In particular, we could compute <code>getDuration()</code> at the same time that we parse the MP3 and import a new album. However, both operations will need to finish before invoking <code>importSong()</code>.</p>
<p>Our first try might look like this:</p>
<pre><code class="language-javascript">export default async (file) =&gt; {
  // Read the file
  let buffer = await read(file);

  // Compute the duration
  let durationPromise = getDuration(buffer);

  // Parse out the ID3 metadata
  let metaPromise = parser(file);
  let meta = await metaPromise;

  let songMeta = mapSongMeta(meta);
  let albumMeta = mapAlbumMeta(meta);

  // Import the album
  let albumIdPromise = importAlbum(albumMeta);

  let duration = await durationPromise;
  let albumId = await albumIdPromise;

  // Import the song
  let songId = await importSong({
    ...songMeta, albumId, file, duration, meta
  });

  return songId;
};
</code></pre>
<p>That took a fair amount of brain tetris to get the order of <code>await</code>s right: if we hadn't moved <code>getDuration()</code> up a few lines in the function, we would have created a poor solution since <code>importAlbum()</code> only depends on <code>albumMeta</code>, which only depends on <code>meta</code>. But this solution is still suboptimal! <code>getDuration()</code> depends on <code>buffer</code>, but <code>parser()</code> could be executing at the same time as <code>read()</code>. To get the best solution, we would have to use <code>Promise.all()</code> and <code>.then()</code>s.</p>
<p>To solve the underlying problem without evaluating a dependency graph by hand, we need to define groups of serial steps (which execute one-by-one in a blocking fashion), and combine those groups concurrently.</p>
<p>What if there was a way to define such a dependency graph that's readable, doesn't break closures, doesn't resort to <code>.then()</code>, and doesn't require a library?</p>
<h2 id="asynciifes">Async IIFEs</h2>
<p>That's where <strong>async IIFEs</strong> come in. For every group of serial (dependent) operations, we'll wrap them up into a micro API called a &quot;task&quot;:</p>
<pre><code class="language-javascript">let myTask = (async () =&gt; {
  let other = await otherTask;
  let result = await doCompute(other.thing);
  return result;
})();
</code></pre>
<p>Since all <code>async</code> functions return a <code>Promise</code>, the <code>myTask</code> local variable contains a <code>Promise</code> that will resolve to <code>result</code>. I prefer to call these <code>*Task</code> instead of <code>*Promise</code>. Inside the async IIFE, operations are sequential, but outside we aren't blocking anything. Furthermore, inside a task we can wait on other tasks to finish, like <code>otherTask</code>, which could be another async IIFE.</p>
<p>Let's turn the <code>getDuration()</code> section into a task called <code>durationTask</code>:</p>
<pre><code class="language-javascript">let durationTask = (async () =&gt; {
  let buffer = await readTask;
  let duration = await getDuration(buffer);
  return duration;
})();
</code></pre>
<p>Since these tasks are defined inline, they have access to variables in the outer closure, including other tasks!</p>
<h2 id="refactoringintoasynctasks">Refactoring into Async Tasks</h2>
<p>Let's refactor the entire importer with async IIFEs, or &quot;tasks&quot;:</p>
<pre><code class="language-javascript">export default async (file) =&gt; {
  // Read the file
  let readTask = read(file);

  // Parse out the ID3 metadata
  let metaTask = (async () =&gt; {
    let meta = await parser(file);
    let songMeta = mapSongMeta(meta);
    let albumMeta = mapAlbumMeta(meta);
    return { meta, songMeta, albumMeta };
  })();

  // Import the album
  let albumImportTask = (async () =&gt; {
    let { albumMeta } = await metaTask;
    let albumId = await importAlbum(albumMeta);
    return albumId;
  })();

  // Compute the duration
  let durationTask = (async () =&gt; {
    let buffer = await readTask;
    let duration = await getDuration(buffer);
    return duration;
  })();

  // Import the song
  let songImportTask = (async () =&gt; {
    let albumId = await albumImportTask;
    let { meta, songMeta } = await metaTask;
    let duration = await durationTask;

    let songId = await importSong({
      ...songMeta, albumId, file, duration, meta
    });

    return songId;
  })();

  let songId = await songImportTask;

  return songId;
};
</code></pre>
<p>Now reading the file, computing duration, parsing metadata and database querying will automatically run concurrently or serially‚Äîwe were even able to leave <code>getDuration()</code> in its original spot! By declaring tasks and <code>await</code>ing them inside other tasks, we defined a dependency graph for the runtime and let it <em>discover</em> the optimal solution for us.</p>
<p>Suppose we wanted to add another step to the import process, like retrieving album artwork from a web service:</p>
<pre><code class="language-javascript">// Look up album artwork from a web service
let albumArtwork = await fetchAlbumArtwork(albumMeta);
</code></pre>
<p>Prior to the async IIFE refactor, adding this feature would have triggered a lot of changes throughout the file, but now we can add it with just a small isolated chunk of additions!</p>
<pre><code class="language-diff">+// Look up album artwork from a web service
+let artworkTask = (async () =&gt; {
+  let { albumMeta } = await metaTask;
+  let artwork = await fetchAlbumArtwork(albumMeta);
+  return artwork;
+})();

 // Import the album
 let albumImportTask = (async () =&gt; {
+  let artwork = await artworkTask;
   let { albumMeta } = await metaTask;
-  let albumId = await importAlbum(albumMeta);
+  let albumId = await importAlbum({ artwork, ...albumMeta });
   return albumId;
 })();
</code></pre>
<p>Tasks are declarative, so managing concurrent vs. serial execution order becomes an &quot;execution detail&quot; instead of an &quot;implementation detail&quot;!</p>
<p>What if we revamped our <code>parser()</code> function so it could synchronously parse an <code>ArrayBuffer</code> instead of a <code>File</code> object? Before this would have triggered a cascade of line reordering, but now the change is trivial:</p>
<pre><code class="language-diff"> // Parse out the ID3 metadata
 let metaTask = (async () =&gt; {
+  let buffer = await readTask;
-  let meta = await parser(file);
+  let meta = parser(buffer);
   let songMeta = mapSongMeta(meta);
   let albumMeta = mapAlbumMeta(meta);
   return { meta, songMeta, albumMeta };
 })();
</code></pre>
<h2 id="objections">Objections</h2>
<p>It's tempting to take shortcuts and solve the dependency graph yourself. For example, after our changes to <code>parser()</code> above, all of the tasks depend on the file being read in, so you <em>could</em> block the entire function with <code>await read(file)</code> to save a few lines. However, these areas are likely to change, and organizing into serial tasks provides other benefits: these micro APIs make it is easier to read, debug, extract and reason about a complex chunk of concurrency.</p>
<p>Since we wrapped these tasks into async IIFEs, why not extract them into dedicated functions? For the same reason we couldn't use <code>Promise</code> chaining: we have to give up nested closures and lexically scoped variables. Extracting tasks into top level functions also begs a design question: <em>if all these operations were synchronous, would we still perform this extraction?</em></p>
<p>If you find yourself extracting <code>async</code> functions (as we did with <code>importAlbum()</code> and <code>importSong()</code>) because of their complexity or reusability, bravo! But ultimately, design principles for breaking down functions should be independent of whether the code is async vs. sync.</p>
<p>Also, splitting functions or moving them too far from their context makes code harder to grasp, <a href="https://jonathanleemartin.com/blog/youre-killin-me-smalls-are-small-objects-good/">as Josh discusses in his post about extracting methods</a>.</p>
<h2 id="moretocome">More to Come</h2>
<p>Functional programming is well-suited to multithreading because it minimizes shared state and opts for local variables as the de facto state mechanism. And thanks to JavaScript's event loop, we can deal with shared state by <em>merging</em> results inside a single thread.</p>
<p>Next time, we'll examine functional patterns for throttling concurrency on a single thread, then wrap up with techniques for efficiently managing a cluster of Web Workers‚Ä¶ without worrying a shred about &quot;thread safety.&quot;</p>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Hi, I‚Äôm Node.js and I‚Äôll be your server today.]]></title><description><![CDATA[Tech stack decisions can be hard. Is Node.js the right choice for your service? Have a seat and your server will be right with you.]]></description><link>https://jonathanleemartin.com/blog/hi-im-node-js-and-ill-be-your-server-today/</link><guid isPermaLink="false">5d476ef72ee5ff3d4aa3cafe</guid><category><![CDATA[JavaScript]]></category><category><![CDATA[Node]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Wed, 12 Apr 2017 12:00:00 GMT</pubDate><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><p><small><em>This post first appeared on the <a href="https://www.bignerdranch.com/blog/hi-im-node-js-and-ill-be-your-server-today/">Big Nerd Ranch blog</a>.</em></small></p>
<p>The magical moment has arrived: your startup just got its first round of funding, and you‚Äôre ready to crunch out an MVP that will dazzle your users and make investors salivate.</p>
<p>Only, you have no clue what tech stack to use.</p>
<p>You heard that <a href="https://nodejs.org/">Node.js</a> is pretty popular for building a backend server because ‚Äúhey, it‚Äôs JavaScript on the backend!‚Äù and there‚Äôs a huge pool of full-stack developers to hire from. But weeks of Reddit-ing and Hacker News-ing later, you have an equal collection of posts that say Node is ‚Äúliterally the best‚Äù and ‚Äúdefinitely the worst.‚Äù</p>
<h2 id="optimizefortherightthings">Optimize for the Right Things‚Ñ¢</h2>
<p>In truth, your choice of tech stack will rarely make or break your company. Since a new service often starts out as an MVP-style proof-of-concept, your backend server may only see a few hundred users before it‚Äôs scrapped and rewritten (or dies if you join the <a href="https://www.quora.com/What-percentage-of-startups-fail">92% of startups that fail</a>).</p>
<p>So if you are worrying about <em>‚ÄúWill it scale to handle tons of users?‚Äù</em> you may be asking the wrong question. If you have reached a scale where your decision actually matters‚Ä¶ congratulations! But unless you are a large service with an established user base, you have time to worry about scaling later. Don‚Äôt kill your startup by prematurely optimizing your tech stack. Instead, focus on maximizing developer speed and happiness. Usually, this means leveraging what your team already knows best.</p>
<p>With that in mind, Node.js will often hit the sweet spot: it scales to huge amounts of traffic, and likely your team is already skilled in JavaScript.</p>
<h2 id="trailblazers">Trailblazers</h2>
<p>If you are ready to jump into Node.js, you‚Äôre in great company! <a href="https://www.quora.com/What-companies-are-using-Node-js-in-production">A growing list</a> of the largest retailers, banking, social media, news and media outlets have switched to Node.js and <a href="https://nodejs.org/en/foundation/case-studies/">enjoyed some wonderful results</a>:</p>
<ul>
<li><a href="https://changelog.com/podcast/116">Walmart</a></li>
<li>PayPal</li>
<li><a href="https://twitter.com/necolas/status/829128165314306048">Twitter</a></li>
<li>Netflix</li>
<li>Uber</li>
</ul>
<p>Why has Node.js worked so well for these companies?</p>
<h2 id="whatisjavascript">What is JavaScript?</h2>
<p>To answer this, it will help to understand how Node.js works. At its core, Node is a runtime for executing JavaScript code on a server. Traditionally, JavaScript was run only in the browser, but nowadays you‚Äôll find JavaScript in a <a href="https://jonathanleemartin.com/blog/ember-js-and-electron-build-desktop-apps-with-web-technologies/">lot</a> of <a href="https://tessel.io/">places</a>.</p>
<p>JavaScript is a <em>dynamic, lexically scoped, duck-typed scripting language.</em> Practically speaking, this means developers can quickly modify code without recompiling and enjoy <a href="https://en.wikipedia.org/wiki/Exploratory_programming">exploratory programming</a>, which makes debugging easier. Dynamic scripting languages have traditionally been much slower than their compiled counterparts, but thanks to the <a href="https://en.wikipedia.org/wiki/Browser_wars">browser wars</a> and the <a href="https://en.wikipedia.org/wiki/V8_(JavaScript_engine)">Google V8 engine</a>, JavaScript often runs within an order of magnitude of the speed of its native equivalent, and in optimized subsets runs only 50% slower than native code.</p>
<p>Despite the name, <a href="https://en.wikipedia.org/wiki/JavaScript#History">JavaScript has nothing to do with Java</a>, so the paradigms and patterns used in Java are nothing like JavaScript. <a href="https://jonathanleemartin.com/blog/javascript-make-me-a-triple-function-sandwich/">JavaScript favors functional programming</a>, a programming model for building programs through closures, function composition, argument currying, etc. From a quality perspective, functional-style code is often simpler to test than a class-oriented counterpart (though <a href="https://jonathanleemartin.com/blog/writing-stylish-tests-with-an-rpsec-style-guide/">it doesn‚Äôt have to be</a>).</p>
<h2 id="whatisnodejs">What is Node.js?</h2>
<p>In technicalese, Node.js is a ‚Äúnon-blocking, event-driven I/O runtime.‚Äù Does that read like ‚Äúword soup‚Äù? Let‚Äôs make a sandwich instead.</p>
<p><strong>Traditional backend tech stacks work like a sandwich shop:</strong> for every customer, a sandwich maker will be assigned to you while you instruct them in what toppings you would like. So if the sandwich shop has one sandwich maker, the shop can handle one customer at a time. To serve more customers simultaneously, you just hire more sandwich makers.</p>
<p>This paradigm works great because making sandwiches is fast, and there‚Äôs not much waiting in between adding toppings.</p>
<p><strong>But now imagine a fancy sit-down restaurant.</strong> Instead of getting in-and-out with a sandwich in 3 minutes, customers will likely spend an hour dining. If each customer monopolized a chef‚Äôs time for an entire hour, you‚Äôd need a lot of cooks!</p>
<p>So instead of customers talking directly to a chef, each customer is assigned a waiter. Still, it would be nonsensical for a waiter to be stuck with a customer until they left, because there‚Äôs lots of waiting! The waiter will wait for the customer to be ready to order, for their food to be prepared, etc. But a single waiter can attend to multiple customers over the period of an hour: after they take an order, they forward it to a chef and check on other customers.</p>
<p>But it‚Äôs easy to predict when your waiter will leave you to attend to other customers: they won‚Äôt ask you to ‚Äúhold that thought‚Äù and leave you in the middle of ordering. Instead, they will only leave when you‚Äôve finished placing your order‚Äîthat way, waiters won‚Äôt have to remember what the customer was halfway through ordering.</p>
<p>While waiters are good at helping customers discover new items and validating their menu choices, they can‚Äôt handle lengthy tasks‚Äîotherwise, their other customers could be waiting for a while. Instead, a waiter <em>delegates</em> time-consuming tasks, like food preparation, to other people.</p>
<p>In short, a waiter doesn‚Äôt do any one thing that takes much time.</p>
<p>When the restaurant is clogged with customers, there is now a possible bottleneck: you might not have enough cooks! In such a case, you wouldn‚Äôt employ more waiters to speed up order time‚Äîinstead, you should hire more chefs. However, sometimes exceptional circumstances arise and a waiter needs to leave unexpectedly. To add ‚Äúfault-tolerance,‚Äù you just add more waiters!</p>
<p>Splitting up restaurant duties into labor-intensive food preparation and multitask-style waiting makes sense. And in the world of backend tech stacks, <strong>Node.js is your waiter at a sit-down restaurant!</strong></p>
<h2 id="whatisnodejsgoodat">What is Node.js good at?</h2>
<p>Like a restaurant waiter, <strong>Node.js is exceptionally good at waiting.</strong> For a backend server, this may seem strange‚Äîwhy would the backend wait before responding to a browser‚Äôs HTTP request? Most backends wait for a lot of resources before responding: they fetch data from a database, read a file from disk, or just wait to finish streaming the response back to the browser!</p>
<p>This wouldn‚Äôt be problematic if there was only one request at a time, but if your backend needs to handle 20 requests simultaneously, blocking 19 of the other requests until the first one finishes is not an option. To solve this, most backend stacks rely on multithreading and load balancers.</p>
<p>But why can‚Äôt a single backend process handle multiple requests concurrently, like a waiter, so long as no task takes long? This is the superpower of Node.js: a single Node process can seamlessly handle <a href="http://blog.caustik.com/2012/08/19/node-js-w1m-concurrent-connections/">hundreds of thousands of simultaneous requests</a> by juggling between requests whenever it must wait for a resource (database, reading a file off disk, or networking). This paradigm, called asynchronous or <strong>cooperative multitasking,</strong> allows the backend to <em>predictably</em> make context switches when it gets to a good stopping point, i.e. when it‚Äôs waiting for something. This is in contrast to <strong>preemptive multitasking,</strong> which gives each request handler a slice of time to compute before forcefully switching to another request handler.</p>
<p>It turns out a large category of web services do a lot of waiting by delegating to other services (database, file system, networking), then aggregate the data into a suitable response. Because ‚Äúcontext switches‚Äù between these simultaneous tasks are predictable, memory usage stays very low and there are far fewer worries about thread safety.</p>
<p>Even though your code is single-threaded, you can scale it in the same way you would a restaurant: add more waiters! Or in this case, run more processes (usually, one per CPU core).</p>
<p>So Node supports <strong>cooperative multitasking,</strong> but not through <strong>multithreading.</strong> This isn‚Äôt a disadvantage‚Äîit actually makes programs easier to reason about! What if a waiter could leave a customer in the middle of ordering? They would need to keep track of where they left off ordering. But what if during that time someone persuaded the customer to order something different? Since the code is single-threaded, we don‚Äôt need to worry about thread safety since we know the waiter will only leave off when a customer is done ordering.</p>
<p>This model makes Node particularly well-suited for building realtime services‚Äîa single process can handle <a href="https://github.com/uWebSockets/uWebSockets">many thousands of concurrent WebSocket connections</a> without blowing up memory usage or becoming sluggish.</p>
<h2 id="whatisntnodejsgoodat">What <em>isn‚Äôt</em> Node.js good at?</h2>
<p>As the homepage asserts, Node.js is really good for programs that deal with event-oriented I/O (input/output). This also means that there are a lot of things Node.js is <strong>not</strong> good at.</p>
<p>In particular, Node does its best to make blocking operations impossible: all the core APIs are asynchronous. But despite JavaScript‚Äôs execution speed, you can still ‚Äúblock the Event Loop‚Äù by performing CPU intensive tasks. If your backend needs to analyze data or do complex aggregation and filtering, you will annul Node‚Äôs primary strength.</p>
<p>Thankfully, Node comes with many core APIs that are implemented natively which effectively run on separate threads selected from a thread pool, so you can do a lot of ‚ÄúCPU intensive‚Äù things in Node without blocking. If you need to do some custom intensive computation, you can leverage the <a href="https://github.com/audreyt/node-webworker-threads">WebWorkers</a> API to create thread safe background workers. Or, you can build out specialized microservices, perhaps with Elixir or Rust, and use them as a ‚Äúbackend for your backend.‚Äù</p>
<p>Since Node.js is a general-purpose programming language, a naive HTTP server will not be fault-tolerant (resilient to crashes) out of the box. For a single-threaded server, a process supervisor like <a href="https://github.com/foreverjs/forever">forever</a> will do, but to leverage multi-core CPUs you will want to use the built-in <a href="https://nodejs.org/api/cluster.html">cluster API</a>.</p>
<h2 id="whyisnodesopopular">Why is Node so popular?</h2>
<p>With these caveats in mind, Node.js is an exceptional fit for many backend servers. Its extreme popularity among developers is especially telling, and with good reason:</p>
<ul>
<li>It‚Äôs easy to get caught up in a language‚Äôs elegance, yet overlook the most important aspect of a tech stack: its community support and libraries. JavaScript enjoys the largest community (people and open source libraries) of any language, and Node inherits these benefits with the npm package manager, ‚Äúthe largest ecosystem of open source libraries in the world.‚Äù</li>
<li>With <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_Next_support_in_Mozilla">ES2017</a> (the 2017 release of JavaScript), async programming is incredibly straightforward and readable with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"><code>async</code> functions</a>.</li>
<li>Node adopts new features and APIs rapidly, so developers can enjoy all of the tooling and APIs the <a href="https://github.com/tc39/ecma262">TC39 committee</a> has helped standardize for years in browsers. As a pleasant consequence of the <a href="https://iojs.org/">io.js</a> <a href="https://thenextweb.com/dd/2015/06/16/node-js-and-io-js-are-settling-their-differences-merging-back-together/#.tnw_u0uQXg1w">hostile fork</a>, Node.js is 100% open-source, has an open governance model and is supported by a diverse community of independent contributors and <a href="https://nodejs.org/en/foundation/members/">company backers</a> who frequently contribute to Node‚Äôs fantastic production readiness.</li>
<li>Thanks to this community, you won‚Äôt be alone when you are finally ready to start <a href="https://speakerdeck.com/volkan/scaling-your-node-dot-js-api-like-a-boss">scaling your Node.js powered backend</a>.</li>
</ul>
<p>All told, this means <strong>Node.js is unlikely to stagnate or die out</strong> since it builds on the web platform‚Äôs incredible momentum. And at eight years old, it‚Äôs a safe bet that Node.js will continue to innovate for years to come.</p>
<p><em>Now excuse me, I'm headed to a hibachi steakhouse‚Ä¶</em></p>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Encore, JavaScript! Create an MP3 reader with DataViews + TextDecoder.]]></title><description><![CDATA[Now Playing: Learn to parse MP3 metadata with JavaScript‚Äôs ArrayBuffers, DataViews, TypedArrays and TextDecoder.]]></description><link>https://jonathanleemartin.com/blog/encore-javascript-create-an-mp3-reader-with-dataviews-textdecoder/</link><guid isPermaLink="false">5d476ef72ee5ff3d4aa3caf4</guid><category><![CDATA[JavaScript]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Thu, 23 Mar 2017 12:00:00 GMT</pubDate><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><p><small><em>This post first appeared on the <a href="https://www.bignerdranch.com/blog/encore-javascript-create-an-mp3-reader-with-dataviews-textdecoder/">Big Nerd Ranch blog</a>.</em></small></p>
<p><em>Check out the <a href="https://github.com/nybblr/mp3-reader">finished code on Github</a>.</em></p>
<p>Like all good blog posts, this one started with a <a href="https://twitter.com/nybblr/status/833770058291765248">conversation on Twitter</a>. Giovanni Cort√©s showed off an elegant snippet of Elixir code that leverages destructuring to parse the song metadata (title, author, etc.) from an MP3 audio file.</p>
<p>About this time I was brainstorming new topics for <a href="https://jonathanleemartin.com/books/front-end-web-development/">our web development guide</a> about JavaScript‚Äôs high-performance data types. Although JavaScript‚Äôs destructuring isn‚Äôt as extensive as Elixir‚Äôs, it has great APIs for efficiently operating on large chunks of binary data.</p>
<p>While reading the tweet, I was also enjoying my favorite orchestral piece‚Äî<em>Sn√∂frid,</em> a beautiful melodrama by the Finnish composer Jean Sibelius‚Äîover coffee. So what could be more appropriate during a caffeine high amongst Scandinavian decor than to create an MP3 metadata reader with JavaScript?</p>
<h2 id="gettingstarted">Getting Started</h2>
<p>To compose this masterpiece, we will use some standardized APIs available in both the browser and Node. For simplicity we will build a command-line tool with Node, but apart from reading in a file, the code will run as is in the browser!</p>
<p>MP3 metadata, like the song‚Äôs title and composer, is stored in a format called <strong>‚ÄúID3‚Äù</strong> at the beginning (or end) of an MP3 file. We‚Äôll just pretend it stands for ‚ÄúMP3 information‚Äù since the acronym‚Äôs true origins seem mysterious.</p>
<p>There are several revisions of the ID3 spec. Giovanni‚Äôs lovely Elixir example extracts <a href="http://id3.org/ID3v1">ID3v1 metadata</a> (called ‚ÄúTAG‚Äù) from an MP3 file. The TAG spec is incredibly straightforward to parse since it uses fixed length fields. Unfortunately, it turned out to be too simplistic, so most of the MP3s in your music library use the much more flexible (and complex) <a href="http://id3.org/id3v2.3.0">ID3v2.3.0 spec</a>. This version supports arbitrary length metadata and internationalization via alternate text encodings.</p>
<p>If you‚Äôre interested in seeing an ID3v1 reader, <a href="https://ericbidelman.tumblr.com/post/8343485440/reading-mp3-id3-tags-in-javascript">check out this implementation by Eric Bidelman</a>. His example uses the <a href="https://github.com/jDataView/jDataView">jDataView</a> library, which adds some nice (but non-standard) methods to the <code>DataView</code> API.</p>
<p><strong>We are going to tackle the ID3v2 spec,</strong> so our JavaScript MP3 reader won‚Äôt be an apples-to-apples comparison with the Elixir example, but meanwhile we will explore a few more Web APIs!</p>
<p>Let‚Äôs set up the Node project:</p>
<pre><code class="language-bash"># Create project directory
$ mkdir mp3-reader &amp;&amp; cd mp3-reader

# Init package.json with defaults
$ npm init -y

# Install TextDecoder polyfill
$ npm install --save text-encoding

# Create main file and make it executable
$ touch index.js &amp;&amp; chmod u+x index.js
</code></pre>
<h2 id="readinginafile">Reading in a File</h2>
<p>First off, we need to read in a file. In <code>index.js</code>, we‚Äôll use the core <code>fs</code> library to asynchronously read in the specified MP3 file. This is the <em>only</em> Node specific code‚Äîafter you read in a file, everything else will work in the browser!</p>
<pre><code class="language-javascript">#!/usr/bin/env node
let fs = require('fs');

const file = process.argv[2];

fs.readFile(file, (err, data) =&gt; {

});
</code></pre>
<p>Since this is an executable file, the first line‚Äîcalled a ‚Äú<a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">shebang</a>‚Äù‚Äîinstructs the shell to execute this script with the Node interpreter. Now we can run it in the terminal:</p>
<pre><code class="language-bash">./index.js fixtures/sibelius.mp3
</code></pre>
<p>When we execute <code>index.js</code>, <code>process.argv</code> will look like this:</p>
<pre><code class="language-javascript">[ '/Users/jonathan/.nvm/versions/node/v6.10.0/bin/node',
  '/Users/jonathan/projects/mp3-reader/index.js',
  'fixtures/sibelius.mp3' ]
</code></pre>
<p><code>process.argv</code> is an array of at least two items: the full path to the Node executable and the full path to <code>index.js</code>. Any extra arguments passed to our script will begin at index 2, so <code>process.argv[2]</code> will be the path to the MP3 file we should read.</p>
<p>The <code>fs.readFile()</code> method accepts a callback, which will be invoked with an error argument and a Node <a href="https://nodejs.org/api/buffer.html"><code>Buffer</code></a> object. <code>Buffer</code>s have been around for a while, but they are specific to Node‚Äîyou won‚Äôt find <code>Buffer</code>s in the browser. However, <a href="https://nodejs.org/api/buffer.html#buffer_buffers_and_typedarray">Node has switched the underlying implementation</a> of <code>Buffer</code> to a standardized JavaScript datatype: <code>ArrayBuffer</code>. In fact, <code>Buffer</code> objects have a <code>.buffer</code> property which returns the underlying <code>ArrayBuffer</code>!</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer"><code>ArrayBuffer</code>s</a> are a performant way to store large chunks of data, especially binary data. You‚Äôll find them in graphics APIs like <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a> and in <a href="https://developer.mozilla.org/en-US/docs/Web/API/Transferable">multithreading</a>. Since they‚Äôre part of the core language library, <strong>you can use <code>ArrayBuffer</code>s in both Node.js <em>and</em> the browser!</strong></p>
<p>To grab the Node <code>Buffer</code>‚Äôs underlying <code>ArrayBuffer</code>, we can destructure the <code>data</code> argument, which contains a Node <code>Buffer</code>, to extract just its <code>.buffer</code> property:</p>
<pre><code class="language-javascript">...

fs.readFile(file, (err, data) =&gt; {
  if (err) { throw err; }

  let { buffer } = data;
});
</code></pre>
<p>This fancy destructuring syntax is equivalent to <code>let buffer = data.buffer</code>. Now we‚Äôre ready to do the actual parsing!</p>
<h2 id="parsingtheid3header">Parsing the ID3 Header</h2>
<p>ID3v2 metadata comes at the beginning of the MP3 file and starts off with a 10 byte header. The first 3 bytes should always be the string <code>ID3</code>, followed by 7 more bytes.</p>
<p><img src="https://jonathanleemartin.com/content/images/2017/12/id3-header.png" alt="Layout of ID3 metadata"></p>
<p>The first two bytes after <code>ID3</code> (bytes 4 and 5) are version numbers. However, we can‚Äôt directly access the data in an <code>ArrayBuffer</code>: we need to create a <code>DataView</code> object to ‚Äúview‚Äù that data.</p>
<pre><code class="language-javascript">...

const HEADER_SIZE = 10;

fs.readFile(file, (err, data) =&gt; {
  ...

  let header = new DataView(buffer, 0, HEADER_SIZE);

  let major = header.getUint8(3);
  let minor = header.getUint8(4);
  let version = `ID3v2.${major}.${minor}`;
  console.log(version);
});
</code></pre>
<p><code>DataView</code>s do not contain the data themselves, but they provide a ‚Äúwindow‚Äù to ‚Äúpeer‚Äù into an <code>ArrayBuffer</code>. This means you can create multiple <code>DataView</code>s for the same <code>ArrayBuffer</code>‚Äîa clever design pattern for referencing the same chunk of memory with a different lens.</p>
<p>When creating a <code>DataView</code>, we specify the byte offset of where we want the ‚Äúwindow‚Äù to start and how many bytes afterwards should be visible. While these two arguments are optional, they prevent us from ‚Äúpeering too far‚Äù and will throw useful exceptions if we attempt to access anything beyond these specified boundaries.</p>
<p>To grab the ID3 version numbers, we used the <code>.getUint8()</code> method. This method reads a single byte at the specified position relative to the <code>DataView</code>‚Äôs offset. In this case, it reads bytes 3 and 4 relative to an offset of 0.</p>
<p>The ID3 metadata section can be fairly long, so next we need to know the ID3 metadata‚Äôs total size (in bytes) so we don‚Äôt read too far and begin parsing the actual MP3 audio data.</p>
<pre><code class="language-javascript">...

let synchToInt = synch =&gt; {
  const mask = 0b01111111;
  let b1 = synch &amp; mask;
  let b2 = (synch &gt;&gt; 8) &amp; mask;
  let b3 = (synch &gt;&gt; 16) &amp; mask;
  let b4 = (synch &gt;&gt; 24) &amp; mask;

  return b1 | (b2 &lt;&lt; 7) | (b3 &lt;&lt; 14) | (b4 &lt;&lt; 21);
};

fs.readFile(file, (err, data) =&gt; {
  ...

  let size = synchToInt(header.getUint32(6));
});
</code></pre>
<p>Quite a bit going on there! Let's break this down. We read a 32-bit integer (4 bytes) starting at offset 6 (bytes 7‚Äì10) of the header that tells us how long the rest of the metadata is. Unfortunately, it‚Äôs not just a simple 32-bit integer: it‚Äôs a so-called ‚Äúsynchsafe‚Äù integer.</p>
<p><img src="https://jonathanleemartin.com/content/images/2017/12/synchsafe-integer.png" alt="Synchsafe integers"></p>
<p>A <a href="https://en.wikipedia.org/wiki/Synchsafe">synchsafe integer</a> is essentially a 28-bit integer with a <code>0</code> added after every 7 bits. It‚Äôs pretty weird, but luckily we have low level boolean logic at our fingertips: we‚Äôll just break up the synchsafe integer into 4 bytes, then combine them back with the 8th bit of each byte removed.</p>
<p><img src="https://jonathanleemartin.com/content/images/2017/12/synchsafe-to-integer.png" alt="Converting a synchsafe integer to a regular integer"></p>
<p>Why doesn‚Äôt the ID3 spec just use a regular 32-bit integer? MP3 was designed to be broadcast friendly, so audio players need to be able to play an MP3 from any given spot by watching for the next valid chunk of audio. Each chunk of audio begins with 11 bits set to <code>1</code> called the ‚Äúframe sync.‚Äù By using synchsafe integers in the metadata section, this prevents interference with the ‚Äúframe sync‚Äù mechanism. It‚Äôs still quite possible to have a sequence of 11 true bits elsewhere, but it‚Äôs fairly unlikely and players can easily perform correctness checks.</p>
<p>We‚Äôre done reading the 10-byte ID3 header, now it‚Äôs time to start looping through the ‚Äúframes‚Äù that come next:</p>
<pre><code class="language-javascript">...

fs.readFile(file, (err, data) =&gt; {
  ...

  let offset = HEADER_SIZE;
  let id3Size = HEADER_SIZE + size;

  while (offset &lt; id3Size) {

  }
});
</code></pre>
<p>ID3 metadata is stored in consecutive chunks called ‚Äúframes.‚Äù Each frame represents a separate key-value pair, like the song‚Äôs title or composer. We can read them in by parsing one frame at a time, then skipping by the size of that frame to read the next one until we reach the end of the ID3 metadata. In a moment, we‚Äôll write a function called <code>decodeFrame()</code> to handle this, but if it was implemented we could parse all the frames like such:</p>
<pre><code class="language-javascript">...

fs.readFile(file, (err, data) =&gt; {
  ...

  while (offset &lt; id3Size) {
    let frame = decodeFrame(buffer, offset);
    if (!frame) { break; }
    console.log(`${frame.id}: ${frame.value.length &gt; 200 ? '...' : frame.value}`);
    offset += frame.size;
  }
});
</code></pre>
<h2 id="parsinganid3frame">Parsing an ID3 Frame</h2>
<p>Time to implement <code>decodeFrame()</code>! This function should return an object for one frame (key-value pair) structured like this:</p>
<pre><code class="language-javascript">{ id: 'TIT2',
  value: 'Sn√∂frid (Snowy Peace)',
  lang: 'eng',
  size: 257 }
</code></pre>
<p>Each frame begins with a 10-byte header, then is followed by the frame‚Äôs actual content (the value).</p>
<pre><code class="language-javascript">...

let decodeFrame = (buffer, offset) =&gt; {
  let header = new DataView(buffer, offset, HEADER_SIZE + 1);
  if (header.getUint8(0) === 0) { return; }
};
</code></pre>
<p>After creating an 11-byte <code>DataView</code> (why 11 instead of 10? Hang tight) to inspect the frame‚Äôs header, we checked to make sure the first byte isn‚Äôt a zero, which would indicate there are no more frames to decode. Many MP3 encoders pad the ID3 metadata section with extra <code>0</code>s (usually 2048 bytes of ‚Äúnull-padding‚Äù) to give audio players like iTunes room to insert more metadata without disturbing the rest of the file.</p>
<p>If the frame doesn‚Äôt start with zero, it‚Äôs safe to read in the first part of the header: the 4-byte frame ID. Frames are basically a single key-value pair, and the frame ID is the ‚Äúkey‚Äù of that pair:</p>
<p><img src="https://jonathanleemartin.com/content/images/2017/12/id3-frame.png" alt="ID3 Frame format"></p>
<pre><code class="language-javascript">...

let { TextDecoder } = require('text-encoding');
let decode = (format, string) =&gt; new TextDecoder(format).decode(string);

let decodeFrame = (buffer, offset) =&gt; {
  ...

  let id = decode('ascii', new Uint8Array(buffer, offset, 4));
};
</code></pre>
<p>The 4-character frame ID is encoded as an ASCII string, like <code>TIT2</code> (Title) or <code>TCOM</code> (Composer). To read in multiple bytes at a time, we need a different kind of view called a <code>TypedArray</code>. It‚Äôs not a constructor you‚Äôll invoke directly, rather it refers to a class of fixed size homogeneous arrays. So to read in a list of unsigned 8-bit integers, we create a new <code>Uint8Array</code> typed array. If we wanted to read in signed (negative) numbers, we would use the <code>Int8Array</code> constructor instead, but that makes no sense for reading in ASCII bytes.</p>
<p>It‚Äôs not enough to fetch an array of 4 bytes‚Äîthey need to be interpreted, or ‚Äúdecoded,‚Äù into a string. Frame IDs map directly to ASCII characters, so we invoked the <code>TextDecoder</code> constructor and its <code>.decode()</code> method to convert the byte array to a string.</p>
<p>Earlier we created an 11-byte <code>DataView</code> starting at the frame‚Äôs beginning. After the 4-byte frame ID comes the frame‚Äôs size:</p>
<pre><code class="language-javascript">...

let decodeFrame = (buffer, offset) =&gt; {
  ...

  let size = header.getUint32(4);
  let contentSize = size - 1;
  let encoding = header.getUint8(HEADER_SIZE);

  let contentOffset = offset + HEADER_SIZE + 1;
};
</code></pre>
<p>Bytes at indices 4‚Äì7 represent the rest of the frame‚Äôs size as an unsigned 32-bit integer. We don‚Äôt care about the 2 flag bytes which follow, so we are done decoding the frame header. But since it is only 10 bytes long, why did we read in 11? The first byte after the frame header (the 11th byte, index 10) specifies how the frame‚Äôs content is encoded, so in a way it is part of the frame header. To compensate for this ‚Äúextra header byte,‚Äù we increased the <code>contentOffset</code> and decreased <code>contentSize</code> by <code>1</code>.</p>
<p>This ‚Äúencoding byte‚Äù can be set to <code>0</code>, <code>1</code>, <code>2</code> or <code>3</code>, and maps to a text encoding like <code>ascii</code> or <code>utf-8</code>. This will help immensely, otherwise we might get gobbledygook if we mistakenly interpreted <code>utf-8</code> text as <code>ascii</code>.</p>
<h2 id="decodingstrings">Decoding Strings</h2>
<p>Finally, the frame‚Äôs real content begins at offset 11 of the frame. In addition to the encoding byte, some frames are also prefixed with a language descriptor:</p>
<pre><code class="language-javascript">...

const LANG_FRAMES = [
  'USLT',
  'SYLT',
  'COMM',
  'USER'
];

let decodeFrame = (buffer, offset) =&gt; {
  ...

  let lang;
  if (LANG_FRAMES.includes(id)) {
    lang = decode('ascii', new Uint8Array(buffer, contentOffset, 3));
    contentOffset += 3;
    contentSize -= 3;
  }
};
</code></pre>
<p>The language identifier is a 3 letter ASCII string, like <code>eng</code> or <code>deu</code>. Only certain frame types, like <code>COMM</code> (Comments), have a language identifier. Now onward to the real content!</p>
<pre><code class="language-javascript">...

const ID3_ENCODINGS = [
  'ascii',
  'utf-16',
  'utf-16be',
  'utf-8'
];

let decodeFrame = (buffer, offset) =&gt; {
  ...

  let value = decode(ID3_ENCODINGS[encoding],
    new Uint8Array(buffer, contentOffset, contentSize));
};
</code></pre>
<p>We finally grab the rest of the frame and decode the bytestream based on the encoding byte. For example, when <code>encoding</code> is set to <code>0</code> we interpret the frame‚Äôs content as <code>ascii</code>.</p>
<p>Now we just need to send everything back in a nice package:</p>
<pre><code class="language-javascript">...

let decodeFrame = (buffer, offset) =&gt; {
  ...

  return {
    id, value, lang,
    size: size + HEADER_SIZE
  };
};
</code></pre>
<p>There‚Äôs one catch: the frame size didn‚Äôt include the 10 byte frame header, so we added <code>HEADER_SIZE</code> to the returned size so the <code>while</code> loop can increment its offset by <code>frame.size</code> to hop to the next frame.</p>
<p>Time to run our script! Find an MP3 file and pass it to <code>index.js</code>. If it doesn‚Äôt print out <code>ID3v2.3.0</code>, try another MP3.</p>
<pre><code class="language-bash">$ ./index.js fixtures/sibelius.mp3

ID3v2.3.0
PRIV: ...
TIT2: Sn√∂frid (Snowy Peace), Improvisation for Reciter, Chorus and Orchestra, Op. 29
TPE1: Lahti Symphony Orchestra, Jubilate Choir, Stina Ekblad and Osmo V√§nsk√§
TALB: Sibelius: The Complete Symphonies - Karelia - Lemmink√§inen - Violin Concerto
TCON: Classical
TCOM: Jean Sibelius
TPE3: Osmo V√§nsk√§
TRCK: 38/43
TYER: 2011
COMM: Amazon.com Song ID: 222429669
TPE2: Lahti Symphony Orchestra and Osmo V√§nsk√§
TCOP: 2011 Bis
TPOS: 1/1
APIC: ...
</code></pre>
<p>Hey look! We got the special Unicode characters to interpret correctly. Good ‚Äòol Osmo V√§nsk√§ (the conductor) gets his proper accents for free. If the parser was even one byte off, you‚Äôd get gobbledygook. Or if you mixed your <code>ID3_ENCODINGS</code> a bit, you might find yourself staring at <a href="https://en.wikipedia.org/wiki/Byte_order_mark">byte order marks</a> (BOM) and other gunk not-meant-to-be-seen-by-mortals:</p>
<pre><code>ID3v2.3.0
PRIV: ...
TIT2: «øÔπìn√∂frid (Snowy Peace), Improvisation for Reciter, Chorus and Orchestra, Op. 29ÔøΩ
TPE1: «øÔπåahti Symphony Orchestra, Jubilate Choir, Stina Ekblad and Osmo V√§nsk√§ÔøΩ
TALB: «øÔπìibelius: The Complete Symphonies - Karelia - Lemmink√§inen - Violin ConcertoÔøΩ
TCON: «øÔπÉlassicalÔøΩ
TCOM: «øÔπäean SibeliusÔøΩ
TPE3: «øÔπèsmo V√§nsk√§ÔøΩ
TRCK: «øÔ∏≥8/43ÔøΩ
TYER: «øÔ∏≤011ÔøΩ
COMM: ≈•Êπß‰ÑÄÊ¥ÄÊÑÄÁ®ÄÊºÄÊ∏Ä‚∏ÄÊåÄÊºÄÊ¥Ä‚ÄÄÂåÄÊºÄÊ∏ÄÊúÄ‚ÄÄ‰§Ä‰êÄ„®Ä‚ÄÄ„àÄ„àÄ„àÄ„êÄ„àÄ„§Ä„òÄ„òÄ„§Ä
TPE2: «øÔπåahti Symphony Orchestra and Osmo V√§nsk√§ÔøΩ
TCOP: «øÔ∏≤011 BisÔøΩ
TPOS: «øÔ∏±/1ÔøΩ
APIC: ...
</code></pre>
<p>Boom! You can <a href="https://github.com/nybblr/mp3-reader">download the finished code here</a>.</p>
<h2 id="encore">Encore!</h2>
<p>Thanks to the <code>ArrayBuffer</code>, <code>DataView</code>, <code>TypedArray</code> and <code>TextDecoder</code> APIs, you can easily decode binary file formats. Although dealing with file specs can be notoriously tricky, JavaScript‚Äôs console-friendly ways make it easy to practice <a href="https://en.wikipedia.org/wiki/Exploratory_programming">exploratory programming</a> to work out the kinks and off-by-one errors.</p>
<p>If you need a more extensive MP3 metadata parser for your binary libretti, you‚Äôll probably want to use a library like <a href="https://github.com/aadsm/jsmediatags">JSMediaTags</a>.</p>
<p>And there you have it! A masterful binary performance of Sn√∂frid by the JavaScript Symphony Orchestra, conducted by Node.js.</p>
<blockquote>
<p><em>If you choose me, then you choose the tempest.</em><br>
<em>For the hardy poems of the hero‚Äôs life say:</em><br>
<em>Draw your sword against vile giants,</em><br>
<em>bleed valiantly for the weak,</em><br>
<em>deny yourself with pleasure, never complain,</em><br>
<em>fight the hopeless fight and die nameless.</em><br>
<em>That is the true heroic saga of life.</em></p>
<p>‚ÄîViktor Rydberg</p>
</blockquote>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Asyncing Feeling about JavaScript Generators]]></title><description><![CDATA[Async generator functions have arrived in JavaScript! Iterate over Stream-like data with a for-loop and even rewrite ReactiveX.js. Read on to see what comes .next()‚Ä¶]]></description><link>https://jonathanleemartin.com/blog/asyncing-feeling-about-javascript-generators/</link><guid isPermaLink="false">5d476ef72ee5ff3d4aa3cafd</guid><category><![CDATA[JavaScript]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Wed, 18 Jan 2017 12:00:00 GMT</pubDate><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><p><small><em>This post first appeared on the <a href="https://www.bignerdranch.com/blog/asyncing-feeling-about-javascript-generators/">Big Nerd Ranch blog</a>.</em></small></p>
<p><em>Want the <strong>TL;DR</strong> version? <a href="https://gist.github.com/nybblr/3af62797052c42f7090b4f8614b5e157">Here‚Äôs a gist of all three examples</a>.</em></p>
<p><a href="https://github.com/tc39/proposal-async-iteration">Async generators and async iteration have arrived</a>! Err, they‚Äôve reached <a href="https://tc39.github.io/process-document/">Stage 3</a>, which means they are likely to ship in a future version of JavaScript. Until then, you can enable Stage 3 proposals in <a href="https://babeljs.io/repl/#?presets=stage-3">Babel</a> to try them out in your own projects.</p>
<p>The web is essentially a decentralized app runtime, so subpar language additions have permanent consequences since future standards must remain backwards compatible. So for a feature to be accepted into the ECMAScript standard, it has to be incredibly compelling‚Äîit takes more than snazzy syntax or theoretical elegance for a feature to make the cut.</p>
<p>With that in mind, we should expect async generators and iteration to substantially influence how we architect our future code, yet address a contemporary problem. Let‚Äôs investigate how async generators work and examine the challenges of using them in ‚Äúreal‚Äù codebases.</p>
<h2 id="recaphowasyncgeneratorswork">Recap: How Async Generators Work</h2>
<p>In a nutshell, async generators are like regular generator functions, but they yield Promises. If you aren‚Äôt familiar with ES2015 generator functions, check out Chris Aquino‚Äôs <a href="https://jonathanleemartin.com/blog/generators-rick-astley-and-the-sequence-of-fibonacci/">blog</a>, then watch Jafar Husain‚Äôs excellent talk on <a href="https://www.youtube.com/watch?v=lil4YCCXRYc">Async Programming</a>.</p>
<p>To recap, regular generator functions are basically a cross between the <a href="https://en.wikipedia.org/wiki/Iterator_pattern">Iterator</a> and <a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer</a> patterns. A generator is a pausable function that you can ‚Äústep‚Äù through by calling <code>.next()</code>. You can pull a value out of a generator multiple times with <code>.next()</code>, or push a value into the same function multiple times with <code>.next(valueToPush)</code>. This dual interface allows you to imitate both an Iterator and Observer with the same syntax!</p>
<p>However, generators have a disadvantage: they must <em>immediately</em> (synchronously) return data when <code>.next()</code> is invoked. Put another way, the code that <em>consumes</em> the data by calling <code>.next()</code> is in control of data flow. This is fine when the generator can generate new data on demand, but generators are not a good fit for iterating over asynchronous (or <em>temporal</em>) data sources, where the source itself controls when the next chunk of data is available.</p>
<p>WebSocket messages are a good example of an <em>asynchronous</em> data source. If we had a list of all the messages we would ever receive, we could iterate over them synchronously. But of course, we can‚Äôt know when messages will be received, so we need a mechanism to iterate lazily over messages as they arrive. Async generators and async iteration let us do just that!</p>
<p><strong>TL;DR:</strong> generator functions are for data sources where the data consumer is in control, whereas async generators allow the data source itself to be in control.</p>
<h2 id="simpleexamplegenerateandconsumeanasyncgenerator">Simple Example: Generate and Consume an AsyncGenerator</h2>
<p>Let‚Äôs exercise our async chops with an example. We want to write an async generator function that repeatedly generates a new number after waiting a random number of milliseconds. Over a period of several seconds it might generate five or so numbers starting from 0. Let‚Äôs first write a helper function that generates a Promise to represent a timer:</p>
<pre><code class="language-javascript">// Create a Promise that resolves after ms time
var timer = function(ms) {
  return new Promise(resolve =&gt; {
    setTimeout(resolve, ms);
  });
};
</code></pre>
<p>Calling <code>timer(5000)</code> returns a Promise that will resolve in 5 seconds. Now we‚Äôre ready to write an async generator:</p>
<pre><code class="language-javascript">// Repeatedly generate a number starting
// from 0 after a random amount of time
var source = async function*() {
  var i = 0;
  while (true) {
    await timer(Math.random() * 1000);
    yield i++;
  }
};
</code></pre>
<p>So much complexity hiding behind such elegance! Our async generator function waits a random amount of time, then <code>yield</code>s the next number in the count-up. If we didn‚Äôt have async generators, we could try using a regular generator function to <code>yield</code> Promises like this:</p>
<pre><code class="language-javascript">var source = function*() {
  var i = 0;
  while (true) {
    yield timer(Math.random() * 1000)
      .then(() =&gt; i++);
  }
};
</code></pre>
<p>However, there are some edge cases and boilerplate we‚Äôd have to handle, so it‚Äôs nice to have a dedicated function type! Now we‚Äôre ready to write the consuming code; because we need the <code>await</code> operator, we‚Äôll create an async <code>run()</code> function.</p>
<pre><code class="language-javascript">// Tie everything together
var run = async function() {
  var stream = source();
  for await (let n of stream) {
    console.log(n);
  }
};

run();
// =&gt; 0
// =&gt; 1
// =&gt; 2
// =&gt; 3
// ...
</code></pre>
<p>What magic, and in under 20 lines of code! First, we invoke the <code>source</code> async generator function, which returns a special <code>AsyncGenerator</code> object. Then we use the <code>for await...of</code> loop syntax‚Äîcalled ‚Äúasynchronous iteration‚Äù‚Äîto loop over numbers one-by-one as <code>source</code> generates them.</p>
<p><strong>But we can level up:</strong> suppose we want to square the numbers generated by <code>source</code>. We could square directly inside the <code>for await...of</code> loop, but it‚Äôd be better to ‚Äútransform‚Äù the stream of values outside the loop, similar to using <code>.map()</code> to transform an array of values. It‚Äôs quite straightforward:</p>
<pre><code class="language-javascript">// Return a new async iterator that applies a
// transform to the values from another async generator
var map = async function*(stream, transform) {
  for await (let n of stream) {
    yield transform(n);
  }
};
</code></pre>
<p>Then we just need to add a line to the <code>run()</code> function:</p>
<pre><code class="language-diff"> // Tie everything together
 var run = async function() {
   var stream = source();
+  // Square values generated by source() as they arrive
+  stream = map(stream, n =&gt; n * n);
   for await (let n of stream) {
     console.log(n);
   }
 };
</code></pre>
<p>Now when we <code>run()</code> everything:</p>
<pre><code class="language-javascript">// =&gt; 0
// =&gt; 1
// =&gt; 4
// =&gt; 9
// ...
</code></pre>
<p>Impressive! But perhaps generating counting numbers isn‚Äôt especially innovative.</p>
<h2 id="mediumexamplewriteanasynciteratorforwebsockets">Medium Example: Write an AsyncIterator for WebSockets</h2>
<p>The usual way to respond to incoming WebSocket messages is to attach an event listener:</p>
<pre><code class="language-javascript">var ws = new WebSocket('ws://localhost:3000/');
ws.addEventListener('message', event =&gt; {
  console.log(event.data);
});
</code></pre>
<p>But if we treated WebSocket messages as a stream, it seems natural to ‚Äúiterate‚Äù over messages as they arrive. Unfortunately, WebSockets are not yet async iterable, but we can write our own polyfill in just a few lines. Here‚Äôs what our <code>run()</code> function will look like:</p>
<pre><code class="language-javascript">// Tie everything together
var run = async () =&gt; {
  var ws = new WebSocket('ws://localhost:3000/');
  for await (let message of ws) {
    console.log(message);
  }
};
</code></pre>
<p>Now for that polyfill. You may recall from <a href="https://jonathanleemartin.com/blog/generators-rick-astley-and-the-sequence-of-fibonacci/">Chris Aquino‚Äôs blog series</a> that, for an object to be iterable with the <code>for...of</code> loop, you must define the <code>Symbol.iterator</code> property on that object. Similarly, to make an object async iterable with the <code>for await...of</code> loop, its <code>Symbol.asyncIterator</code> property must be defined. Here‚Äôs an implementation:</p>
<pre><code class="language-javascript">// Add an async iterator to all WebSockets
WebSocket.prototype[Symbol.asyncIterator] = async function*() {
  while(this.readyState !== 3) {
    yield (await oncePromise(this, 'message')).data;
  }
};
</code></pre>
<p>This async iterator waits to receive a message, then <code>yield</code>s the <code>data</code> attribute of the WebSocket‚Äôs <code>MessageEvent</code>. The <code>oncePromise()</code> function is a bit of a hack: it returns a Promise that resolves when an event occurs, then immediately unsubscribes:</p>
<pre><code class="language-javascript">// Generate a Promise that listens only once for an event
var oncePromise = (emitter, event) =&gt; {
  return new Promise(resolve =&gt; {
    var handler = (...args) =&gt; {
      emitter.removeEventListener(event, handler);
      resolve(...args);
    };
    emitter.addEventListener(event, handler);
  });
};
</code></pre>
<p>It seems inefficient, but it really tidies up our async iterator. If you have a chatty WebSocket server running at <a href="http://localhost:3000">http://localhost:3000</a>, you can watch messages stream in by invoking <code>run()</code>:</p>
<pre><code class="language-javascript">run();
// =&gt; &quot;hello&quot;
// =&gt; &quot;sandwich&quot;
// =&gt; &quot;otters&quot;
// ...
</code></pre>
<h2 id="hardexamplerewriterxjs">Hard Example: Rewrite RxJS</h2>
<p>Now for the ultimate challenge. <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">Functional reactive programming</a> (FRP) is all the rage in UI programming, and in JavaScript, <a href="http://reactivex.io/rxjs/manual/overview.html">RxJS</a> is the most popular library for this programming style. RxJS models event sources as <code>Observable</code>s‚Äîthey‚Äôre like an event stream or lazy array that can be modified with familiar array idioms like <code>map()</code> and <code>filter()</code>.</p>
<p>Since FRP complements JavaScript‚Äôs non-blocking philosophy, it‚Äôs possible an <a href="https://github.com/tc39/proposal-observable">RxJS-like API</a> will make it to a future version of JavaScript. Meantime, we can write our own RxJS clone with async generators in just 80 lines of code! Here‚Äôs the challenge:</p>
<ol>
<li>Listen for all click events</li>
<li>Filter down to only clicks on anchor tags</li>
<li>Only allow distinct clicks</li>
<li>Map from click events to a click counter and the click event</li>
<li>Throttle clicks to once every 500ms</li>
<li>Print the click counter and event</li>
</ol>
<p>This type of problem is right in RxJS‚Äôs wheelhouse, so we‚Äôll try to replicate its approach. Here‚Äôs how we‚Äôll exercise our implementation:</p>
<pre><code class="language-javascript">// Tie everything together
var run = async () =&gt; {
  var i = 0;
  var clicks = streamify('click', document.querySelector('body'));

  clicks = filter(clicks, e =&gt; e.target.matches('a'));
  clicks = distinct(clicks, e =&gt; e.target);
  clicks = map(clicks, e =&gt; [i++, e]);
  clicks = throttle(clicks, 500);

  subscribe(clicks, ([ id, click ]) =&gt; {
    console.log(id);
    console.log(click);
    click.preventDefault();
  });
};

run();
</code></pre>
<p>To make this work, we need to write six functions: <code>streamify()</code>, <code>filter()</code>, <code>distinct()</code>, <code>map()</code>, <code>throttle()</code> and <code>subscribe()</code>.</p>
<pre><code class="language-javascript">// Turn any event emitter into a stream
var streamify = async function*(event, element) {
  while (true) {
    yield await oncePromise(element, event);
  }
};
</code></pre>
<p><code>streamify()</code> is just like the WebSocket async iterator: <code>oncePromise()</code> uses <code>.addEventListener()</code> to listen once for an event, then resolves the Promise. By looping with <code>while (true)</code>, we can listen for events indefinitely.</p>
<pre><code class="language-javascript">// Only pass along events that meet a condition
var filter = async function*(stream, test) {
  for await (var event of stream) {
    if (test(event)) {
      yield event;
    }
  }
};
</code></pre>
<p><code>filter()</code> only <code>yield</code>s events that pass the test. <code>map()</code> is almost identical:</p>
<pre><code class="language-javascript">// Transform every event of the stream
var map = async function*(stream, transform) {
  for await (var event of stream) {
    yield transform(event);
  }
};
</code></pre>
<p>Instead of testing before yielding, <code>map()</code> simply transforms the event before yielding. <code>distinct()</code> shows one of the superpowers of async generators: they can persist state with local variables!</p>
<pre><code class="language-javascript">var identity = e =&gt; e;

// Only pass along events that differ from the last one
var distinct = async function*(stream, extract = identity) {
  var lastVal;
  var thisVal;
  for await (var event of stream) {
    thisVal = extract(event);
    if (thisVal !== lastVal) {
      lastVal = thisVal;
      yield event;
    }
  }
};
</code></pre>
<p>Last, the mighty <code>throttle()</code> function resembles <code>distinct()</code>: it tracks the timestamp of the last event and only <code>yield</code>s it if a certain amount of time has passed since the last <code>yield</code>ed event.</p>
<pre><code class="language-javascript">// Only pass along event if some time has passed since the last one
var throttle = async function*(stream, delay) {
  var lastTime;
  var thisTime;
  for await (var event of stream) {
    thisTime = (new Date()).getTime();
    if (!lastTime || thisTime - lastTime &gt; delay) {
      lastTime = thisTime;
      yield event;
    }
  }
};
</code></pre>
<p>Finally, we need to print out the click event and counter for every event that made it this far. <code>subscribe()</code> is trivial: it just loops over every event and runs the callback, no <code>yield</code>s necessary.</p>
<pre><code class="language-javascript">// Invoke a callback every time an event arrives
var subscribe = async (stream, callback) =&gt; {
  for await (var event of stream) {
    callback(event);
  }
};
</code></pre>
<p>And with that, we‚Äôve written our own functional reactive pipeline!</p>
<p><a href="https://gist.github.com/nybblr/3af62797052c42f7090b4f8614b5e157">Check out the gist</a> if you want to try out any of these examples.</p>
<h2 id="challenges">Challenges</h2>
<p>Async generators are pretty awesome. Whereas generator functions allow us to pull data out of an iterator, async generators let us iterate over data that is ‚Äúpushed‚Äù to us. They‚Äôre a great abstraction for asynchronous data structures. However, there are some caveats.</p>
<p>First, implementing support for the <code>for await...of</code> on objects is a bit gnarly unless you avoid <code>yield</code> and <code>await</code>. Notably, converting anything with <code>.addEventListener()</code> is tricky because you can‚Äôt use the <code>yield</code> operator within the callback:</p>
<pre><code class="language-javascript">var streamify = async function*(event, element) {
  element.addEventListener(event, e =&gt; {
    // This doesn't work because yield is being
    // called from inside another function.
    yield e;
  });
};
</code></pre>
<p>Similarly, you can‚Äôt use <code>yield</code> within <code>.forEach()</code> or other functional methods. This is an inherent limitation since there‚Äôs no guarantee <code>yield</code> won‚Äôt be used <em>after</em> the generator has already finished.</p>
<p>To sidestep this, we wrote the <code>oncePromise()</code> helper. Apart from potential performance issues, it‚Äôs important to note that Promise callbacks always execute after the current callstack has finished. In browsers that run Promise callbacks as <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">microtasks</a>, this shouldn‚Äôt cause issues, but some Promise polyfills won‚Äôt run the callbacks until the next run of the event loop. Consequently, invoking the <code>.preventDefault()</code> method may have no effect since the DOM event may have already bubbled to the browser.</p>
<p>JavaScript now has several asynchronous stream datatypes: <code>Stream</code>, <code>AsyncGenerator</code> and eventually <code>Observable</code>. While all three fall into the continuum of ‚Äúpushed‚Äù data sources, there are subtle semantic differences in how they handle back pressure and control the underlying resource. If you‚Äôre interested in the finer facets of functional reactive semantics, check out the <a href="https://github.com/kriskowal/gtor">General Theory of Reactivity</a>.</p>
<h2 id="moretocome">More to Come</h2>
<p>In the arms race for language features, JavaScript is no slacker. Destructuring in ES2015, async functions in ES2016, and now async iteration enable JavaScript to elegantly tackle the complexities of UI and I/O programming without resorting to the usual unpredictability of multi-threading.</p>
<p>And there‚Äôs much more to come! So keep an eye on the blog and the <a href="https://github.com/tc39/proposals">TC39 proposals repo</a> for new goodies. Meantime, you can start using async generator functions in your own code by <a href="https://babeljs.io/repl/#?presets=stage-3">enabling Stage 3 proposals in Babel</a>.</p>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[JavaScript, make me a Triple Function Sandwich]]></title><description><![CDATA[Since JavaScript is unrelated to Java, many OOP patterns are not idiomatic to JavaScript. So how do you solve common OOP-like problems? It might be time to invite Functional Programming for lunch!]]></description><link>https://jonathanleemartin.com/blog/javascript-make-me-a-triple-function-sandwich/</link><guid isPermaLink="false">5d476ef72ee5ff3d4aa3caf2</guid><category><![CDATA[JavaScript]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Mon, 05 Dec 2016 12:00:00 GMT</pubDate><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><p><small><em>This post first appeared on the <a href="https://www.bignerdranch.com/blog/javascript-make-me-a-triple-function-sandwich/">Big Nerd Ranch blog</a>.</em></small></p>
<p>You probably knew that despite the name and superficially similar syntax, <strong>JavaScript is unrelated to Java.</strong> The unfortunate name ‚ÄúJavaScript‚Äù originated when the company responsible for creating JavaScript‚ÄîNetscape Communications‚Äî<a href="https://en.wikipedia.org/wiki/JavaScript#History">entered into a license agreement with Sun</a> in 1995. Thus, many of the design patterns you might know from Java, Ruby or other class-oriented programming languages are not idiomatic to JavaScript.</p>
<p>So what design patterns <em>are</em> idiomatic to JavaScript?</p>
<p>JavaScript‚Äôs object-oriented behavior imitates <a href="https://en.wikipedia.org/wiki/Self_(programming_language)">Self</a> (a dialect of <a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a>), but the overall programming paradigm is heavily influenced by its functional programming heritage. Moreover, JavaScript has some unique functional patterns of its own hiding in plain sight throughout popular libraries and Web APIs.</p>
<p>Let‚Äôs dissect two in-the-wild patterns from the JavaScript ecosystem‚Äîwe‚Äôll call them the <strong>Function Factory Function</strong> and <strong>Triple Function Sandwich.</strong></p>
<h2 id="functionfactoryfunction">Function Factory Function</h2>
<p>The <strong>Function Factory Function</strong> is a function that follows the <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">Factory method pattern</a>, but returns a new function. Most Factories return objects, but thanks to first-class functions in JavaScript, it‚Äôs common for the Factory to build a function. In functional terminology, FFFs are often an example of a <a href="https://en.wikipedia.org/wiki/Higher-order_function">Higher-order Function</a>.</p>
<p>If you‚Äôve used the <code>Array.prototype.sort</code> function, you probably used a higher-order function to generate another function that can sort a list of objects by a particular property:</p>
<pre><code class="language-javascript">var Sorter = extract =&gt; {
  return (a, b) =&gt; {
    var av = extract(a),
        bv = extract(b);

    return av &lt; bv ? -1 : (av &gt; bv ? 1 : 0);
  };
};

var people = [
  { name: 'Alex', age: 36 },
  { name: 'Beth', age: 30 },
  { name: 'Chris', age: 27 }
];

var sortByAge = Sorter(p =&gt; p.age);

people.sort(sortByAge).map(p =&gt; p.name);
// =&gt; [&quot;Chris&quot;, &quot;Beth&quot;, &quot;Alex&quot;]
</code></pre>
<p>The Function Factory Function follows a similar structure, but unlike a higher-order function, it doesn't require a function as an argument. Here's an example of an FFF used to generate middleware in <a href="http://koajs.com/">Koa</a> (a Node.js web framework):</p>
<pre><code class="language-javascript">var Koa = require('koa');
var compress = require('koa-compress');
var serve = require('koa-static');

var app = new Koa();

app.use(compress());
app.use(serve('./app'));
</code></pre>
<p>If Koa was more OOPsy, calling <code>compress()</code> and <code>serve()</code> would probably generate objects, but in functional programming we can <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">capture local variables</a> as state and return a function with access to those variables. This way, we are still applying the principle of <a href="https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)">Encapsulation</a>, but without objects!</p>
<p>How would we use the Function Factory Function pattern in our own code? Suppose we are building a Single Page App (SPA) for the next version of Google Docs, and we want to prevent the user from navigating to another document if there are unsaved changes. If the router fired a <code>beforetransition</code> event, it would be nice if we could ‚Äúlock‚Äù the page and make sure the user really wants to navigate away before allowing the transition. We could write a <code>lock()</code> Function Factory Function to tidy this up; here‚Äôs how we might use it:</p>
<pre><code class="language-javascript">var unlock = lock(ask =&gt; {
  if (checkUnsavedChanges() &amp;&amp;
      ask('You will lose changes!')) {
    discardEdits();
  }
});

// ...once this page is no longer around
// and we need to clean up after ourselves:
unlock();
</code></pre>
<p>The <code>lock()</code> function generates a new function called <code>unlock()</code> that can be invoked to stop watching for page transitions. This will be useful if the user navigates away from this document and this page needs to be deactivated.</p>
<p>Using <code>lock()</code> can tidy things up nicely: if the user attempts to navigate away from the document, we can check if there are any edits, and if there are we can <code>ask()</code> the user if they are okay with losing changes. If they are, we can discard those edits and move on.</p>
<p>We could implement the <code>lock()</code> function like this:</p>
<pre><code class="language-javascript">var $window = $(window);
var lock = cb =&gt; {
  var handler = event =&gt; {
    var abort = () =&gt; {
      event.preventDefault();
    };

    var ask = message =&gt; {
      var okay = window.confirm(message);
      if (!okay) { abort(); }
      return okay;
    };

    cb(ask);
  };

  $window.on('beforetransition', handler);
  return () =&gt; {
    $window.off('beforetransition', handler);
  };
}
</code></pre>
<p>Whenever the user attempts to transition away from the document, we execute the callback and pass in a helper function called <code>ask()</code> to prompt the user. If the user cancels, we <code>.preventDefault()</code> on the event to cancel the transition.</p>
<p>It‚Äôs a nice micro API that can tidy up gnarly code elsewhere! This pattern is an elegant alternative to a class-oriented approach where we would attach state and the unlock method to an object. Incidentally, the <code>lock()</code> function is also an example of the next design pattern: the Triple Function Sandwich.</p>
<h2 id="triplefunctionsandwich">Triple Function Sandwich</h2>
<p>Used Promises lately? You‚Äôre writing a <strong>Triple Function Sandwich!</strong></p>
<pre><code class="language-javascript">var promise = new Promise(function(resolve, reject) {
  setTimeout(resolve, 1000);
});

promise.then(() =&gt; {
  console.log(&quot;It's been a second.&quot;);
});
</code></pre>
<p>Take a look at all the nested functions: we are invoking the <code>Promise()</code> function by passing it a function that will be invoked and passed yet another function <code>resolve()</code> as an argument. Usually you see this kind of code when a callback needs to be executed asynchronously, but that's not the case for the <code>Promise()</code> function‚Äîit will immediately run the given callback:</p>
<pre><code class="language-javascript">console.log('1');
var promise = new Promise(function(resolve, reject) {
  console.log('2');
});
console.log('3');

// =&gt; 1
// =&gt; 2
// =&gt; 3
</code></pre>
<p>So if the callback isn‚Äôt being run asynchronously, why the sandwich? Function sandwiches are a form of cooperative programming: they allow one function to cede control to another function (your callback), but provide a public API for modifying the calling function‚Äôs behavior.</p>
<p>We can use this pattern ourselves to create an async-friendly for-loop! Suppose we want to iterate over a list of numbers and print each one-by-one after waiting for a few seconds. Standard loops in JavaScript run as fast as they can, so to wait between iterations we will need to write our own <code>iterate()</code> function. Here‚Äôs how we would use it:</p>
<pre><code class="language-javascript">var list = [1,2,3,4,5,6,7,8,9];
var promise = iterate(list, (curr, next, quit) =&gt; {
  console.log(curr);
  if (curr &lt; 3) {
    setTimeout(next, curr * 1000);
  } else {
    quit();
  }
});

promise.then(finished =&gt; {
  if (finished) {
    console.log('All done!');
  } else {
    console.log('Done, but exited early.');
  }
});

// =&gt; 1
// =&gt; 2
// =&gt; 3
// =&gt; Done, but exited early.
</code></pre>
<p>This example will immediately print <code>1</code>, then 1 second later it will print <code>2</code>, 2 seconds later it will print <code>3</code> and <code>quit()</code> the loop, and <code>'Done, but exited early.</code> will be printed. Our callback function receives three arguments to control the loop: <code>curr</code> which contains the current element of the list, <code>next()</code> which advances to the next iteration of the loop, and <code>quit()</code> which exits the loop prematurely.</p>
<p>The <code>iterate()</code> function itself returns a Promise that will resolve once it finishes iterating over the list. This Promise will resolve to <code>true</code> if the loop finished iterating over all the elements, or <code>false</code> if the <code>quit()</code> function was invoked to exit the loop early. Notice the Triple Function Sandwich is not as obvious: the sandwich starts with <code>iterate()</code>, the second argument is a function, and the second parameter of that function, <code>next()</code>, is also a function.</p>
<p>Despite this complex behavior, <code>iterate()</code> only takes a few lines of code to implement!</p>
<pre><code class="language-javascript">var iterate = (list, cb) =&gt; {
  return new Promise(resolve =&gt; {
    var counter = 0;
    var length = list.length;

    var quit = () =&gt; {
      resolve(false);
    }

    var next = () =&gt; {
      if (counter &lt; length) {
        cb(list[counter++], next, quit);
      } else {
        resolve(true);
      }
    }

    next();
  });
};
</code></pre>
<p><code>iterate()</code> initializes a counter variable, defines a few functions, then kicks off iteration by calling <code>next()</code>. Every time <code>next()</code> is invoked, it executes <code>cb()</code> and passes in the current element, <code>next()</code> itself, and the <code>quit()</code> function. If it has finished iterating, it resolves the overall Promise to <code>true</code>.</p>
<p>If we had written this same code in a more OOPsy style, it might look like:</p>
<pre><code class="language-javascript">var Iterator = function(list, cb) {
  this.list = list;
  this.cb = cb;
  this.counter = 0;
  this.length = list.length;
  this.promise = new Promise(
    resolve =&gt; { this.resolve = resolve; }
  );
};
Iterator.prototype.quit = function() {
  this.resolve(false);
};
Iterator.prototype.next = function() {
  if (this.counter &lt; this.length) {
    this.cb(this.list[this.counter++]);
  } else {
    this.resolve(true);
  }
};
Iterator.prototype.start = Iterator.prototype.next;

var list = [1,2,3,4,5,6,7,8,9];
var iterator = new Iterator(list, (curr) =&gt; {
  console.log(curr);
  if (curr &lt; 3) {
    setTimeout(() =&gt; iterator.next(), curr * 1000);
  } else {
    iterator.quit();
  }
});
iterator.start();

iterator.promise.then(finished =&gt; {
  if (finished) {
    console.log('All done!');
  } else {
    console.log('Done, but exited early.');
  }
});
</code></pre>
<p>Looks a little clumsy in comparison. Both versions solve the same problem with a form of cooperative programming: the former by encoding state in local variables and ‚Äúpushing‚Äù in a public API to the callback, and the latter by creating a special object with state and methods. Interestingly, this example shows that Encapsulation is not just an OOP principle‚Äîthe functional approach also hides its state (local variables) and provides a public API for modifying that state.</p>
<p>The Triple Function Sandwich is not just for async programming! If you find yourself resorting to an object-oriented approach when you need to break down a function into several steps while preserving state, you might just try a bite of the Triple Function Sandwich. Both approaches provide encapsulation and solve cooperative programming problems, but the functional approach is a thing of beauty that does credit to JavaScript‚Äôs hidden elegance.</p>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Metrics, Metrics: How We Improved our Website Performance, Part 2]]></title><description><![CDATA[Last time, we covered web performance metrics for measuring a website's health. In this post, we continue down the rabbit hole of web optimization and the steps we took to improve our site's performance.]]></description><link>https://jonathanleemartin.com/blog/metrics-metrics-how-we-improved-website-performance-part-2/</link><guid isPermaLink="false">5d476ef72ee5ff3d4aa3caff</guid><category><![CDATA[Web]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Fri, 25 Sep 2015 12:00:00 GMT</pubDate><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><p><small><em>This post first appeared on the <a href="https://www.bignerdranch.com/blog/metrics-metrics-how-we-improved-website-performance-part-2/">Big Nerd Ranch blog</a>.</em></small></p>
<p><em>In Part 2, we continue down the rabbit hole of web optimization. Make sure to check out <a href="https://www.bignerdranch.com/blog/metrics-metrics-how-we-improved-website-performance-part-1/">Part 1</a> for background on the metrics we‚Äôll be investigating!</em></p>
<h2 id="howdowelevelup">How do we level up?</h2>
<p>Although our site was certainly not slow (thanks to the static build), several metrics showed it could benefit from web optimizations.</p>
<table>
<thead>
<tr>
<th>Page</th>
<th>PageSpeed Score</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.bignerdranch.com/">https://www.bignerdranch.com/</a></td>
<td>61/100</td>
</tr>
<tr>
<td><a href="https://www.bignerdranch.com/blog/">https://www.bignerdranch.com/blog/</a></td>
<td>56/100</td>
</tr>
<tr>
<td><a href="https://www.bignerdranch.com/work/">https://www.bignerdranch.com/work/</a></td>
<td>65/100</td>
</tr>
</tbody>
</table>
<p>Our top three pages were hefty for a site that's primarily text-based:</p>
<table>
<thead>
<tr>
<th>Page</th>
<th>Total Page Weight</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.bignerdranch.com/">https://www.bignerdranch.com/</a></td>
<td>1.7 MB</td>
</tr>
<tr>
<td><a href="https://www.bignerdranch.com/blog/">https://www.bignerdranch.com/blog/</a></td>
<td>844 KB</td>
</tr>
<tr>
<td><a href="https://www.bignerdranch.com/blog/any-blog-post/">https://www.bignerdranch.com/blog/any-blog-post/</a></td>
<td>830 KB</td>
</tr>
</tbody>
</table>
<p>A total page weight of 1.7 MB for the homepage could negatively impact our mobile users (an ever-growing audience), especially for those browsing on their data plan.</p>
<h2 id="whatdidyoudo">What Did You Do?</h2>
<p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css">Blocking resources</a> like scripts and stylesheets are the primary bottleneck in the <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/">critical rendering path</a> and <strong>Time-To-First-Render</strong>, so our first priority was to tidy up blocking resources. We audited our usage of <a href="http://modernizr.com/">Modernizr</a> and found we were using only one test, so we inlined it. As for the blocking stylesheet, we just minified it with Sass‚Äôs compact mode for a quick win. With those changes, we reduced the ‚Äúblocking weight‚Äù by 33% across all pages.</p>
<p>So what? The faster blocking resources are downloaded (and stop blocking), the sooner the page will be rendered. That will significantly reduce <strong>Time-To-Visual-Completeness</strong>.</p>
<p><img src="https://jonathanleemartin.com/content/images/2017/12/bnr-waterfall.png" alt="Waterfall in Chrome Profiler" title="Resource load times and timeline"></p>
<h3 id="images">Images</h3>
<p>Next, to speed up <strong>Time-To-Visual-Completeness,</strong> we targeted the size and number of non-blocking requests, like images and JavaScript. We used <a href="https://github.com/toy/image_optim">image_optim</a> to losslessly shrink PNGs, JPEGs and even SVGs; since images are our heaviest asset, this cut down size dramatically (sometimes as much as 90%) by taking advantage of LUTs and nuking metadata. The homepage banner was particularly large, so we opted for lossy compression to cut the size in half. The quality difference is almost unnoticeable, so it was a worthwhile tradeoff.</p>
<h3 id="javascript">JavaScript</h3>
<p>Script optimization took a little more thoughtfulness: we were already minifying scripts, but different pages loaded up to five files (libraries and ‚Äúsprinkles‚Äù of interactivity). jQuery and its host of plugins comprised the largest payload, so we scoured Google Analytics to determine which versions of Internet Explorer we needed to support.</p>
<p>IE9 and below accounted for 5% of our traffic on top pages, but on pages that depended on jQuery (those with forms like our <a href="https://www.bignerdranch.com/contact/">Contact page</a>), IE9‚Äì made up less than 4% of traffic (only a fraction of those visitors used the form). Armed with these statistics, we opted to support IE10+ with jQuery 2. Still, this only shaved 10 KB, and jQuery‚Äôs advanced features were really only used by forms.</p>
<p>However, by dropping IE9‚Äì support, we were able to drop <a href="http://zeptojs.com/">Zepto.js</a> into all our pages. At 25 KB, Zepto is <em>tiiiny;</em> the remaining pages with forms pull in jQuery 2, but all other pages can opt for the economical Zepto library instead.</p>
<p>Our own JavaScript got some tidying: latency was the limiting reagent for our (very small, &lt;6 KB overall) scripts, so we opted to concatenate all our JavaScript into a single script. We also made sure to wrap all the files in an <a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression">IIFE</a> to help the minifier tighten up variable names. In the process, we discovered some unnecessary requests, like blog searching and external API calls.</p>
<h3 id="html">HTML</h3>
<p>For completeness, we added na√Øve HTML minification. To get the most out of this step, you should use a whitespace-sensitive templating language like <a href="http://slim-lang.com/">Slim</a> or <a href="http://jade-lang.com/">Jade</a>. Still, with GZIP compression enabled, the win was minor and made economical sense only because it was a quick addition.</p>
<h3 id="servertweaks">Server tweaks</h3>
<p>After optimizing actual resource size, static servers like Apache and Nginx can help further reduce over-the-wire size and the number of requests.</p>
<p>We enabled compression (<strong>DEFLATE</strong> and <strong>GZIP</strong>) for all text-based resources:</p>
<pre><code class="language-apacheconf">&lt;IfModule mod_deflate.c&gt;

  # Force compression for mangled headers.
  # http://developer.yahoo.com/blogs/ydn/posts/2010/12/pushing-beyond-gzipping
  &lt;IfModule mod_setenvif.c&gt;
    &lt;IfModule mod_headers.c&gt;
      SetEnvIfNoCase ^(Accept-EncodXng|X-cept-Encoding|X{15}|~{15}|-{15})$ ^((gzip|deflate)\s*,?\s*)+|[X~-]{4,13}$ HAVE_Accept-Encoding
      RequestHeader append Accept-Encoding &quot;gzip,deflate&quot; env=HAVE_Accept-Encoding
    &lt;/IfModule&gt;
  &lt;/IfModule&gt;

  # Compress all output labeled with one of the following MIME-types
  # (for Apache versions below 2.3.7, you don‚Äôt need to enable `mod_filter`
  #  and can remove the `&lt;IfModule mod_filter.c&gt;` and `&lt;/IfModule&gt;` lines
  #  as `AddOutputFilterByType` is still in the core directives).
  AddOutputFilterByType DEFLATE application/atom+xml \
                                application/javascript \
                                application/json \
                                application/rss+xml \
                                application/vnd.ms-fontobject \
                                application/x-font-ttf \
                                application/x-web-app-manifest+json \
                                application/xhtml+xml \
                                application/xml \
                                font/opentype \
                                image/svg+xml \
                                image/x-icon \
                                text/css \
                                text/html \
                                text/plain \
                                text/x-component \
                                text/xml

&lt;/IfModule&gt;
</code></pre>
<p>Since we enabled cache busting (e.g. <code>main-1de29262b1ca.js</code>), we bumped the <code>Cache-Control</code> header for all non-HTML files to the maximum allowed value of one year. Since the filename of scripts and stylesheets changes when their contents change, users always receive the latest version, but request it only when necessary.</p>
<pre><code class="language-apacheconf">&lt;IfModule mod_headers.c&gt;
  &lt;FilesMatch &quot;(?i)\.(css|js|ico|png|gif|svg|jpg|jpeg|eot|ttf|woff)$&quot;&gt;
    Header set Cache-Control &quot;max-age=31536000, public&quot;
  &lt;/FilesMatch&gt;
&lt;/IfModule&gt;
</code></pre>
<h2 id="showmethenumbers">Show Me the Numbers!</h2>
<p>We expected dramatic improvement across various metrics after enabling GZIP and aggressive caching. With blocking scripts nuked from the head, <strong>Time-To-Visual-Completeness</strong> should drop to within our 2-second goal.</p>
<h3 id="pageweight">Page weight</h3>
<p><em>Sizes are of GZIPed resources.</em></p>
<table>
<thead>
<tr>
<th>Page</th>
<th>Resource type</th>
<th>Before</th>
<th>After</th>
<th>Percent</th>
</tr>
</thead>
<tbody>
<tr>
<td>All</td>
<td>Blocking (JS/CSS)</td>
<td>21.2 KB</td>
<td>14.7 KB</td>
<td>31% smaller</td>
</tr>
<tr>
<td><a href="https://www.bignerdranch.com/">https://www.bignerdranch.com/</a></td>
<td>Scripts</td>
<td>39.8 KB</td>
<td>11.9 KB</td>
<td>70% smaller</td>
</tr>
<tr>
<td><a href="https://www.bignerdranch.com/">https://www.bignerdranch.com/</a></td>
<td>Images</td>
<td>1.1 MB</td>
<td>751 KB</td>
<td>27% smaller</td>
</tr>
<tr>
<td><a href="https://www.bignerdranch.com/blog/">https://www.bignerdranch.com/blog/</a></td>
<td>All + search</td>
<td>844 KB</td>
<td>411 KB</td>
<td>51% smaller</td>
</tr>
<tr>
<td><a href="https://www.bignerdranch.com/blog/any-blog-post/">https://www.bignerdranch.com/blog/any-blog-post/</a></td>
<td>All</td>
<td>830 KB</td>
<td>532 KB</td>
<td>36% smaller</td>
</tr>
</tbody>
</table>
<p><strong>We cut our average page weight in half!</strong></p>
<h3 id="googlepagespeedscore">Google PageSpeed score</h3>
<p>Scores are for mobile platforms.</p>
<table>
<thead>
<tr>
<th>Page</th>
<th>Before</th>
<th>After</th>
<th>Improvement</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.bignerdranch.com/">https://www.bignerdranch.com/</a></td>
<td>61/100</td>
<td>86/100</td>
<td>+25</td>
</tr>
<tr>
<td><a href="https://www.bignerdranch.com/blog/">https://www.bignerdranch.com/blog/</a></td>
<td>56/100</td>
<td>84/100</td>
<td>+28</td>
</tr>
<tr>
<td><a href="https://www.bignerdranch.com/work/">https://www.bignerdranch.com/work/</a></td>
<td>65/100</td>
<td>89/100</td>
<td>+24</td>
</tr>
</tbody>
</table>
<p>We addressed all high-priority issues in PageSpeed, and the outstanding low-priority issues are from the Twitter widget. On desktop, our pages score in the mid-90s.</p>
<h3 id="webpagetest">WebPageTest</h3>
<p>Bolded links indicate repeat visits to the page (caching performance).</p>
<table>
<thead>
<tr>
<th>Page</th>
<th>Total Load Time</th>
<th>Time To First Byte</th>
<th>Time To Visual Completeness</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.bignerdranch.com/">https://www.bignerdranch.com/</a></td>
<td>2.185s</td>
<td>0.210s</td>
<td>1.996s</td>
</tr>
<tr>
<td><strong><a href="https://www.bignerdranch.com/">https://www.bignerdranch.com/</a></strong></td>
<td>1.314s</td>
<td>0.573s</td>
<td>0.669s</td>
</tr>
<tr>
<td><a href="https://www.bignerdranch.com/blog/">https://www.bignerdranch.com/blog/</a></td>
<td>2.071s</td>
<td>0.188s</td>
<td>0.696s</td>
</tr>
<tr>
<td><strong><a href="https://www.bignerdranch.com/blog/">https://www.bignerdranch.com/blog/</a></strong></td>
<td>0.850s</td>
<td>0.244s</td>
<td>0.371s</td>
</tr>
<tr>
<td><a href="https://www.bignerdranch.com/work/">https://www.bignerdranch.com/work/</a></td>
<td>2.606s</td>
<td>0.395s</td>
<td>1.088s</td>
</tr>
<tr>
<td><strong><a href="https://www.bignerdranch.com/work/">https://www.bignerdranch.com/work/</a></strong></td>
<td>0.618s</td>
<td>0.207s</td>
<td>0.331s</td>
</tr>
</tbody>
</table>
<p>TTFB tends to be noisy (ranging from 200 to 600 milliseconds), and thus <strong>Total Load Time</strong> varies drastically. However, the most important metric, <strong>Time-To-Visual-Completeness</strong>, is now consistently under 2 seconds for new visitors on all pages. And thanks to more aggressive caching, repeat visitors will wait less than half a second to view the latest content.</p>
<h2 id="thatsawrap">That‚Äôs a Wrap</h2>
<p>The results of the audit proved delightful: we cut the average page weight in half and significantly improved the Time-To-Visual-Completeness. In the future, we will be evaluating other optimizations for <a href="https://www.bignerdranch.com/">bignerdranch.com</a>:</p>
<ul>
<li><strong>Inline core CSS styles:</strong> our stylesheet still blocks the parser, but inlining can complicate source code.</li>
<li><strong>Switch to <a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> and <a href="https://github.com/jakubpawlowicz/clean-css">Clean CSS</a></strong> instead of relying on Sass‚Äôs compact mode.</li>
<li><strong>Serve assets over CDNs</strong> or inject proxies to optimize delivery.</li>
<li><strong>Use SVG sprites</strong> for various logos, like social media icons.</li>
<li><strong>Switch to <a href="http://nginx.org/">Nginx</a></strong> from Apache. Nginx is compiled with modules, so it tends to use less memory and is <a href="http://wiki.dreamhost.com/Web_Server_Performance_Comparison">better with heavy traffic</a>. Since our site is static, the server is the limiting reagent in TTFB.</li>
<li><strong>Enable SPDY and HTTP2</strong> to further cut down latency with request multiplexing.</li>
<li><strong><code>mod_pagespeed</code></strong> to automate CSS inlining and other improvements.</li>
<li><strong>Speedier Node-based build.</strong> Jekyll greatly improved our internal publishing process, but we‚Äôve felt some major architectural frustrations. We foresee bringing our expertise with Node-based pipelines to our internal build process.</li>
</ul>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Metrics, Metrics: How We Improved our Website Performance]]></title><description><![CDATA[Developers geek out on numbers, designers labor over information visualization, and ops + marketing love upward trends. Web developers, too, love upward trends in web performance graphs, like time-to-first-load and info gleaned from Google Analytics.]]></description><link>https://jonathanleemartin.com/blog/metrics-metrics-how-we-improved-website-performance-part-1/</link><guid isPermaLink="false">5d476ef72ee5ff3d4aa3cb00</guid><category><![CDATA[Web]]></category><dc:creator><![CDATA[Jonathan Lee Martin]]></dc:creator><pubDate>Fri, 04 Sep 2015 12:00:00 GMT</pubDate><content:encoded><![CDATA[<!--kg-card-begin: markdown--><!--kg-card-begin: markdown--><p><small><em>This post first appeared on the <a href="https://www.bignerdranch.com/blog/metrics-metrics-how-we-improved-website-performance-part-1/">Big Nerd Ranch blog</a>.</em></small></p>
<p>Our Nerds love graphs. Developers geek out on numbers, designers labor over information visualization, and ops + marketing love upward trends.</p>
<p>Web developers, too, love upward trends, particularly in web optimization. We derive excitement from web performance graphs, like time-to-first-load and info gleaned from Google Analytics.</p>
<h2 id="countthecost">Count the Cost</h2>
<p>The web‚Äôs humble beginnings left many with the impression that performance is not all that important for the web. However, analytics would beg to differ.</p>
<p>A load time above 3 seconds <a href="https://blog.kissmetrics.com/loading-time/">could cost you <strong>40%</strong> of your traffic</a>, and it‚Äôs unlikely those users will return. Just an extra 1-second delay can cost about 7% in conversions (or, equivalently, sales).</p>
<p>Visitors who stumble upon your site from search engines are especially vulnerable: even if your result ranks high, people will just click on the next result if your page takes more than 2 seconds to load, and they will likely avoid your site in the future!</p>
<p>A slow site could also affect your standing with search engines. In February, <a href="http://googlewebmastercentral.blogspot.com/2015/02/finding-more-mobile-friendly-search.html">Google added mobile ‚Äúfriendliness‚Äù as a ranking factor</a>; but since 2010, PageSpeed score has been part of ranking.</p>
<p>So PageSpeed-Driven-Optimization may not be such a bad thing after all, especially if the information you disseminate is readily available from competing sources.</p>
<p>Still, it‚Äôs easy to go overboard with optimization. Premature optimization is a velocity-killing rabbit hole that drains the lives of products and company budgets. So when should optimization become a priority? Will shaving a few bytes noticeably improve the user experience?</p>
<h2 id="measuretwicecutonce">Measure Twice, Cut Once</h2>
<blockquote>
<p>‚ÄúWhat‚Äôs measured improves.‚Äù ‚Äì Peter F. Drucker</p>
</blockquote>
<p>Before diving into the ‚Äúbucket-list‚Äù of optimization techniques, you need to have a comprehensive idea of how our site currently performs.</p>
<p>To qualify performance, you need to determine which metrics are important to you, or which affect your market.</p>
<p>There are a number of general metrics that are useful on most sites.</p>
<ul>
<li><strong>Time-To-First-Byte (TTFB):</strong> The time from the first HTTP request to the first byte of the response.</li>
<li><strong>Time-To-First-Render (TTFR):</strong> The time before the browser first renders the page. This varies from browser to browser, but is generally after the HTML page and resources in the <code>&lt;head&gt;</code> tag have finished downloading.</li>
<li><strong>Time-To-Visual-Completeness (TTVC):</strong> The time it takes for the main elements of the page (e.g., content and images, but not ads or widgets) to load and remain visually static (e.g., styles are loaded and parsed).</li>
<li><strong>Time-To-First-Interaction (TTFI):</strong> The time elapsed before the app is fully interactive (e.g., scripts are loaded and executed). This metric is useful in full-fledged web apps.</li>
</ul>
<p>These higher-level metrics are all facets of ‚Äúperceptual‚Äù performance, but for the average user, Time-To-Visual-Completeness will be the most important. TTVC is often a reference to above-the-fold TTVC, although many <a href="http://thereisnopagefold.com/">convincingly argue</a> that <a href="https://blog.kissmetrics.com/why-the-fold-is-a-myth/">there is no such thing</a>. For our audit, we concurred with the ‚Äúno-fold‚Äù opinion.</p>
<p>Why TTVC? A user‚Äôs <em>perception</em> of site speed is a great determinant for how likely they will visit again, better than <em>Time-To-Load-Absolutely-Everything</em>. While in actuality it may take some time to load all of the page‚Äôs resources like JavaScript and analytics, the user will be more likely to convert or make a purchase if the page <em>feels</em> like it finished loading quickly (by prioritizing content and basic styles).</p>
<p>We can improve these perceptual metrics by addressing smaller constituents. We primarily rely on three tools for in-depth performance auditing:</p>
<ul>
<li><a href="https://developers.google.com/speed/pagespeed/">Google PageSpeed</a></li>
<li><a href="https://developer.chrome.com/devtools">Chrome Profiler</a></li>
<li><a href="http://www.webpagetest.org/">WebPageTest</a></li>
</ul>
<p>How do you qualify improvement and goals? The first part is easy: just use the same metrics against your top pages! We targeted main landing pages, which coincidentally covered the different layouts of our site:</p>
<ul>
<li><a href="https://www.bignerdranch.com/">Our home page</a></li>
<li><a href="https://www.bignerdranch.com/blog/">Our blog's landing page</a></li>
<li><a href="https://www.bignerdranch.com/blog/server-side-validation-in-your-ember-application/">A sample blog entry</a></li>
<li><a href="https://www.bignerdranch.com/work/">We Develop</a></li>
<li><a href="https://www.bignerdranch.com/training/">We Teach</a></li>
<li><a href="https://www.bignerdranch.com/books/">We Write</a></li>
</ul>
<p>When optimizing your own site, you should set your goals based on your marketing and current standing. We aimed to get PageSpeed scores near the 90s (green zone) and reduce TTVC to 2 seconds.</p>
<h2 id="whatarethehurdles">What Are the Hurdles?</h2>
<p>Modern browsers are incredibly sophisticated and diverse, but they share some basic similarities when it comes to page loading. The speed of this loading process depends on the <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/">critical rendering path</a>.</p>
<p>As the HTML source is streamed, the parser begins building the DOM. As soon as it discovers a script or stylesheet, it blocks the parsing process and dispatches a request for the resource. Only after the request completes does it continue building the DOM.</p>
<p>Some browsers continue parsing the document looking for other resources (images, or fonts in stylesheets), but it still blocks the DOM. Usually, these resources are scripts and stylesheets in the <code>&lt;head&gt;</code> tag (often labeled ‚Äúblocking‚Äù resources). To speed up TTFR, we need to get rid of blocking resources and shrink remaining blocking resources.</p>
<p>Shrinking resources can provide a major boost, but it would be better to avoid extra requests altogether. Most pages are made of ~75 small resources; at this size, latency (TTFB for a particular resource) far outweighs the actual time it takes to transmit the resource.</p>
<p>To reduce latency, we needed to cut server response time and the number of requests. The latter can be done with image sprites, CSS/JS concatenation and caching techniques.</p>
<h2 id="whatnow">What Now?</h2>
<p>In theory, we understand where our site‚Äôs bottlenecks are, so we should be well on our way to making it snappier! But beyond wishing bytes away, what techniques can we use to speed up the critical rendering path, and ultimately Time-To-Visual-Completeness?</p>
<p>Next time, we‚Äôll <a href="https://www.bignerdranch.com/blog/metrics-metrics-how-we-improved-website-performance-part-2/">apply optimization techniques and examine the results</a>.</p>
<!--kg-card-end: markdown--><!--kg-card-end: markdown-->]]></content:encoded></item></channel></rss>