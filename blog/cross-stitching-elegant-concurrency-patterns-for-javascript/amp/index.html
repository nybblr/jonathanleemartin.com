<!DOCTYPE html>
<html ⚡>
<head>
    <meta charset="utf-8">

    <title>Cross Stitching: Elegant Concurrency Patterns for JavaScript</title>

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">

    <meta name="description" content="JavaScript is well-suited for managing concurrency, and with the help of the Async IIFE design pattern, you can elegantly architecture highly concurrent web apps and back-ends." />
    <link rel="shortcut icon" href="/favicon.png" type="image/png" />
    <link rel="canonical" href="https://www.bignerdranch.com/blog/cross-stitching-elegant-concurrency-patterns-for-javascript/" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    
    <meta property="og:site_name" content="tl;dr" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Cross Stitching: Elegant Concurrency Patterns for JavaScript" />
    <meta property="og:description" content="You&#x27;ve probably heard statements like &quot;JavaScript is a toy language, it doesn&#x27;t support multithreading!&quot; But in fact, JavaScript is tailor-made for concurrency. You&#x27;ll need some patterns to write concurrent code that is performant and readable. Enter the Async IIFE." />
    <meta property="og:url" content="https://www.bignerdranch.com/blog/cross-stitching-elegant-concurrency-patterns-for-javascript/" />
    <meta property="article:published_time" content="2017-06-01T12:00:00.000Z" />
    <meta property="article:modified_time" content="2019-08-09T16:03:26.000Z" />
    <meta property="article:tag" content="JavaScript" />
    
    <meta property="article:publisher" content="https://www.facebook.com/yellowscale" />
    <meta property="article:author" content="https://www.facebook.com/yellowscale" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Cross Stitching: Elegant Concurrency Patterns for JavaScript" />
    <meta name="twitter:description" content="You&#x27;ve probably heard statements like &quot;JavaScript is a toy language, it doesn&#x27;t support multithreading!&quot; But in fact, JavaScript is tailor-made for concurrency. You&#x27;ll need some patterns to write concurrent code that is performant and readable. Enter the Async IIFE." />
    <meta name="twitter:url" content="https://www.bignerdranch.com/blog/cross-stitching-elegant-concurrency-patterns-for-javascript/" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Jonathan Lee Martin" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="JavaScript" />
    <meta name="twitter:site" content="@nybblr" />
    <meta name="twitter:creator" content="@nybblr" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "tl;dr",
        "logo": {
            "@type": "ImageObject",
            "url": "https://jonathanleemartin.com/content/images/2019/08/logo.png",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Jonathan Lee Martin",
        "image": {
            "@type": "ImageObject",
            "url": "//www.gravatar.com/avatar/6dc50195bf39376a9154e48d6b5df778?s=250&d=mm&r=x",
            "width": 250,
            "height": 250
        },
        "url": "https://jonathanleemartin.com/author/jonathan/",
        "sameAs": [
            "https://jonathanleemartin.com/",
            "https://www.facebook.com/yellowscale",
            "https://twitter.com/nybblr"
        ]
    },
    "headline": "Cross Stitching: Elegant Concurrency Patterns for JavaScript",
    "url": "https://jonathanleemartin.com/blog/cross-stitching-elegant-concurrency-patterns-for-javascript/",
    "datePublished": "2017-06-01T12:00:00.000Z",
    "dateModified": "2019-08-09T16:03:26.000Z",
    "keywords": "JavaScript",
    "description": "You&#x27;ve probably heard statements like &quot;JavaScript is a toy language, it doesn&#x27;t support multithreading!&quot; But in fact, JavaScript is tailor-made for concurrency. You&#x27;ll need some patterns to write concurrent code that is performant and readable. Enter the Async IIFE.",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://jonathanleemartin.com/"
    }
}
    </script>

    <meta name="generator" content="Ghost 2.27" />
    <link rel="alternate" type="application/rss+xml" title="tl;dr" href="https://jonathanleemartin.com/rss/" />

    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,600,400" />
    <style amp-custom>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}h1{margin:0.67em 0;font-size:2em}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{position:relative;vertical-align:baseline;font-size:75%;line-height:0}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}amp-img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace, monospace;font-size:1em}button,input,optgroup,select,textarea{margin:0;color:inherit;font:inherit}button{overflow:visible}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{cursor:pointer;-webkit-appearance:button}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}input{line-height:normal}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height:auto}input[type="search"]{-webkit-appearance:textfield}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{margin:0 2px;padding:0.35em 0.625em 0.75em;border:1px solid #c0c0c0}legend{padding:0;border:0}textarea{overflow:auto}optgroup{font-weight:bold}table{border-spacing:0;border-collapse:collapse}td,th{padding:0}html{max-height:100%;height:100%;font-size:62.5%;-webkit-tap-highlight-color:rgba(0, 0, 0, 0)}body{max-height:100%;height:100%;color:#3a4145;background:#f4f8fb;letter-spacing:0.01rem;font-family:"Merriweather", serif;font-size:1.8rem;line-height:1.75em;text-rendering:geometricPrecision;-webkit-font-feature-settings:"kern" 1;-moz-font-feature-settings:"kern" 1;-o-font-feature-settings:"kern" 1}::-moz-selection{background:#d6edff}::selection{background:#d6edff}h1,h2,h3,h4,h5,h6{margin:0 0 0.3em 0;color:#2e2e2e;font-family:"Open Sans", sans-serif;line-height:1.15em;text-rendering:geometricPrecision;-webkit-font-feature-settings:"dlig" 1, "liga" 1, "lnum" 1, "kern" 1;-moz-font-feature-settings:"dlig" 1, "liga" 1, "lnum" 1, "kern" 1;-o-font-feature-settings:"dlig" 1, "liga" 1, "lnum" 1, "kern" 1}h1{text-indent:-2px;letter-spacing:-1px;font-size:2.6rem}h2{letter-spacing:0;font-size:2.4rem}h3{letter-spacing:-0.6px;font-size:2.1rem}h4{font-size:1.9rem}h5{font-size:1.8rem}h6{font-size:1.8rem}a{color:#4a4a4a}a:hover{color:#111}p,ul,ol,dl{margin:0 0 2.5rem 0;font-size:1.5rem;text-rendering:geometricPrecision;-webkit-font-feature-settings:"liga" 1, "onum" 1, "kern" 1;-moz-font-feature-settings:"liga" 1, "onum" 1, "kern" 1;-o-font-feature-settings:"liga" 1, "onum" 1, "kern" 1}ol,ul{padding-left:2em}ol ol,ul ul,ul ol,ol ul{margin:0 0 0.4em 0;padding-left:2em}dl dt{float:left;clear:left;overflow:hidden;margin-bottom:1em;width:180px;text-align:right;text-overflow:ellipsis;white-space:nowrap;font-weight:700}dl dd{margin-bottom:1em;margin-left:200px}li{margin:0.4em 0}li li{margin:0}hr{display:block;margin:1.75em 0;padding:0;height:1px;border:0;border-top:#efefef 1px solid}blockquote{box-sizing:border-box;margin:1.75em 0 1.75em 0;padding:0 0 0 1.75em;border-left:#4a4a4a 0.4em solid;-moz-box-sizing:border-box}blockquote p{margin:0.8em 0;font-style:italic}blockquote small{display:inline-block;margin:0.8em 0 0.8em 1.5em;color:#ccc;font-size:0.9em}blockquote small:before{content:"\2014 \00A0"}blockquote cite{font-weight:700}blockquote cite a{font-weight:normal}mark{background-color:#fdffb6}code,tt{padding:1px 3px;border:#e3edf3 1px solid;background:#f7fafb;border-radius:2px;white-space:pre-wrap;font-family:Inconsolata, monospace, sans-serif;font-size:0.85em;font-feature-settings:"liga" 0;-webkit-font-feature-settings:"liga" 0;-moz-font-feature-settings:"liga" 0}pre{overflow:auto;box-sizing:border-box;margin:0 0 1.75em 0;padding:10px;width:100%;border:#e3edf3 1px solid;background:#f7fafb;border-radius:3px;white-space:pre;font-family:Inconsolata, monospace, sans-serif;font-size:0.9em;-moz-box-sizing:border-box}pre code,pre tt{padding:0;border:none;background:transparent;white-space:pre-wrap;font-size:inherit}kbd{display:inline-block;margin-bottom:0.4em;padding:1px 8px;border:#ccc 1px solid;background:#f4f4f4;border-radius:4px;box-shadow:0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 0 #fff inset;color:#666;text-shadow:#fff 0 1px 0;font-size:0.9em;font-weight:700}table{box-sizing:border-box;margin:1.75em 0;max-width:100%;width:100%;background-color:transparent;-moz-box-sizing:border-box}table th,table td{padding:8px;border-top:#efefef 1px solid;vertical-align:top;text-align:left;line-height:20px}table th{color:#000}table caption + thead tr:first-child th,table caption + thead tr:first-child td,table colgroup + thead tr:first-child th,table colgroup + thead tr:first-child td,table thead:first-child tr:first-child th,table thead:first-child tr:first-child td{border-top:0}table tbody + tbody{border-top:#efefef 2px solid}table table table{background-color:#fff}table tbody > tr:nth-child(odd) > td,table tbody > tr:nth-child(odd) > th{background-color:#f6f6f6}table.plain tbody > tr:nth-child(odd) > td,table.plain tbody > tr:nth-child(odd) > th{background:transparent}iframe,amp-iframe,.fluid-width-video-wrapper{display:block;margin:1.75em 0}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper amp-iframe{margin:0}textarea,select,input{margin:0 0 5px 0;padding:6px 9px;width:260px;outline:0;border:#e7eef2 1px solid;background:#fff;border-radius:4px;box-shadow:none;font-family:"Open Sans", sans-serif;font-size:1.6rem;line-height:1.4em;font-weight:100;-webkit-appearance:none}textarea{min-width:250px;min-height:80px;max-width:340px;width:100%;height:auto}input[type="text"]:focus,input[type="email"]:focus,input[type="search"]:focus,input[type="tel"]:focus,input[type="url"]:focus,input[type="password"]:focus,input[type="number"]:focus,input[type="date"]:focus,input[type="month"]:focus,input[type="week"]:focus,input[type="time"]:focus,input[type="datetime"]:focus,input[type="datetime-local"]:focus,textarea:focus{outline:none;outline-width:0;border:#bbc7cc 1px solid;background:#fff}select{width:270px;height:30px;line-height:30px}.clearfix:before,.clearfix:after{content:" ";display:table}.clearfix:after{clear:both}.clearfix{zoom:1}.main-header{position:relative;display:table;overflow:hidden;box-sizing:border-box;width:100%;height:50px;background:#5ba4e5 no-repeat center center;background-size:cover;text-align:left;-webkit-box-sizing:border-box;-moz-box-sizing:border-box}.content{background:#fff;padding-top:15px}.blog-title,.content{margin:auto;max-width:600px}.blog-title a{display:block;padding-right:16px;padding-left:16px;height:50px;color:#fff;text-decoration:none;font-family:"Open Sans", sans-serif;font-size:16px;line-height:50px;font-weight:600}.post{position:relative;margin-top:0;margin-right:16px;margin-left:16px;padding-bottom:0;max-width:100%;border-bottom:#ebf2f6 1px solid;word-wrap:break-word;font-size:0.95em;line-height:1.65em}.post-header{margin-bottom:1rem}.post-title{margin-bottom:0}.post-title a{text-decoration:none}.post-meta{display:block;margin:3px 0 0 0;color:#9eabb3;font-family:"Open Sans", sans-serif;font-size:1.3rem;line-height:2.2rem}.post-meta a{color:#9eabb3;text-decoration:none}.post-meta a:hover{text-decoration:underline}.post-meta .author{margin:0;font-size:1.3rem;line-height:1.3em}.post-date{display:inline-block;text-transform:uppercase;white-space:nowrap;font-size:1.2rem;line-height:1.2em}.post-image{margin:0;padding-top:3rem;padding-bottom:30px;border-top:1px #E8E8E8 solid}.post-content amp-img,.post-content amp-anim{position:relative;left:50%;display:block;padding:0;min-width:0;max-width:112%;width:calc(100% + 32px);height:auto;transform:translateX(-50%);-webkit-transform:translateX(-50%);-ms-transform:translateX(-50%)}.footnotes{font-size:1.3rem;line-height:1.6em;font-style:italic}.footnotes li{margin:0.6rem 0}.footnotes p{margin:0}.footnotes p a:last-child{text-decoration:none}.site-footer{position:relative;margin:0 auto 20px auto;padding:1rem 15px;max-width:600px;color:rgba(0,0,0,0.5);font-family:"Open Sans", sans-serif;font-size:1.1rem;line-height:1.75em}.site-footer a{color:rgba(0,0,0,0.5);text-decoration:none;font-weight:bold}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.poweredby{display:block;float:right;width:45%;text-align:right}.copyright{display:block;float:left;width:45%}</style>

    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>

    

</head>

<body class="amp-template">
    <header class="main-header">
        <nav class="blog-title">
            <a href="https://jonathanleemartin.com">tl;dr</a>
        </nav>
    </header>

    <main class="content" role="main">
        <article class="post">

            <header class="post-header">
                <h1 class="post-title">Cross Stitching: Elegant Concurrency Patterns for JavaScript</h1>
                <section class="post-meta">
                    <p class="author">by <a href="/author/jonathan/">Jonathan Lee Martin</a></p>
                    <time class="post-date" datetime="2017-06-01">2017-06-01</time>
                </section>
            </header>
            <section class="post-content">

                <p><small><em>This post first appeared on the <a href="https://www.bignerdranch.com/blog/cross-stitching-elegant-concurrency-patterns-for-javascript/">Big Nerd Ranch blog</a>.</em></small></p>
<p><em>"JavaScript is single-threaded, so it doesn't scale. JavaScript is a toy language because it doesn't support multithreading."</em> Outside (and inside) the web community, statements like these are common.</p>
<p>And in a way, it's true: JavaScript’s event loop means your program does <strong>one thing at a time.</strong> This intentional design decision shields us from an entire class of multithreading woes, but it has also birthed the misconception that JavaScript can’t handle concurrency.</p>
<p>But in fact, JavaScript's design is well-suited for solving a plethora of concurrency problems without succumbing to the "gotchas" of other multithreaded languages. You might say that JavaScript is single-threaded… just so it can be multithreaded!</p>
<h2 id="recapconcurrency">Recap: Concurrency</h2>
<p>You may want to do some homework if "<a href="https://en.wikipedia.org/wiki/Concurrent_computing">concurrency</a>" and "<a href="https://en.wikipedia.org/wiki/Parallel_computing">parallelism</a>" are new to your vocabulary. <strong>TL;DR:</strong> for simple programs, we usually write "sequential" or ("serial") code: one step executes at a time, and must complete before the next step begins. If JavaScript could perform a "blocking" AJAX request with <code>ajaxSync()</code>, serial code might look like this:</p>
<pre><code class="language-javascript">console.log('About to make a request.');
let json = ajaxSync('https://api.google.com/search.json');
console.log(json);
console.log('Finished the request.');

/*
  =&gt; About to make a request.
  ... AJAX request runs ...
  ... a couple seconds later ...
  ... AJAX request finishes ...
  =&gt; { all: ['the', 'things'] }
  =&gt; Finished the request.
*/
</code></pre>
<p>Until the AJAX request completes, JavaScript pauses (or "blocks") any lines below from executing. In contrast, concurrency is when the execution of one series of steps can overlap another series of steps. In JavaScript, concurrency is often accomplished with async Web APIs and a callback:</p>
<pre><code class="language-javascript">console.log('About to make a request.');
ajaxAsync('https://api.google.com/search.json', json =&gt; {
  console.log(json);
  console.log('Finished the request.');
});
console.log('Started the request.');

/*
  =&gt; About to make a request.
  ... AJAX request runs in the background ...
  =&gt; Started the request.
  ... a couple seconds later ...
  ... AJAX requests finishes ...
  =&gt; { all: ['the', 'things'] }
  =&gt; Finished the request.
*/
</code></pre>
<p>In this second version, the AJAX request only "blocks" the code <em>inside</em> the callback (logging the AJAX response), but the JavaScript runtime will go on executing lines after the AJAX request.</p>
<h2 id="recapeventloop">Recap: Event Loop</h2>
<p>The JavaScript runtime uses a mechanism, called the "<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">event loop</a>," to keep track of all in-progress async operations so it can notify your program when an operation finishes. If you are unfamiliar with the event loop, check out Philip Robert's exceptional 20 minute overview from ScotlandJS: "<a href="https://vimeo.com/96425312">Help, I'm stuck in an event-loop</a>."</p>
<p>Thanks to the event loop, a single thread can perform an admirable amount of work concurrently. But why not just reach for multithreading?</p>
<p>Software is harder to write (and debug) when it constantly switches between different tasks through multithreading. So unlike many languages, JavaScript finishes one thing at a time—a constraint called "run-to-completion"—and queues up other things to do in the background. Once the current task is done, it grabs the next chunk of work off the queue and executes to completion.</p>
<p>Since the JavaScript runtime never interrupts code that is already executing on the call stack, you can be sure that shared state (like global variables) won't randomly change mid-function—<a href="https://en.wikipedia.org/wiki/Reentrancy_(computing)">reentrancy</a> isn't even a thing! Run-to-completion makes it easy to reason about highly concurrent code, for which reason Node.js is so popular for backend programming.</p>
<p>Although your JavaScript code is single-threaded and only does one thing at a time, <em>the JavaScript Runtime and Web APIs are multithreaded!</em> When you pass a callback function to <code>setTimeout()</code> or start an AJAX request with <code>fetch()</code>, you are essentially spinning up a background thread in the runtime. Once that background thread completes, and once the current call stack finishes executing, your callback function is pushed onto the (now empty) call stack and run-to-completion. So your JavaScript code itself is single-threaded, but it <em>orchestrates</em> legions of threads!</p>
<p>However, we need some patterns to write concurrent code that is performant <em>and</em> readable.</p>
<h2 id="recappromisechaining">Recap: Promise Chaining</h2>
<p>Suppose we are building a media library app in the browser and are writing a function called <code>updateMP3Meta()</code> that will read in an MP3 file, parse out some <a href="https://jonathanleemartin.com/blog/encore-javascript-create-an-mp3-reader-with-dataviews-textdecoder/">ID3 metadata</a> (e.g. song title, composer, artist) and update a matching <code>Song</code> record in the database. Assuming the <code>read()</code>, <code>parseMP3()</code> and <code>Song.findByName()</code> functions return <code>Promise</code>s, we could implement it like this:</p>
<pre><code class="language-javascript">let read     = (path) =&gt; { ... }; // returns a Promise
let parseMP3 = (file) =&gt; { ... }; // returns a Promise
let Song = {
  findByName(name) { ... } // returns a Promise
};

let updateMP3Meta = (path) =&gt; {
  return read(path)
    .then(file =&gt; {
      return parseMP3(file).then(meta =&gt; {
        return Song.findByName(file.name).then(song =&gt; {
          Object.assign(song, meta);
          return song.save();
        });
      });
    });
};
</code></pre>
<p>It does the job, but nested <code>.then()</code> callbacks quickly turn into callback hell and obscure intent… and bugs. We might try using <code>Promise</code> chaining to flatten the callback chain:</p>
<pre><code class="language-javascript">let updateMP3Meta = (path) =&gt; {
  return read(path)
    .then(file =&gt; parseMP3(file))
    .then(meta =&gt; Song.findByName(file.name))
    .then(song =&gt; {
      Object.assign(song, meta);
      return song.save();
    });
};
</code></pre>
<p>This reads nicely, but unfortunately it won't work: we can't access the <code>file</code> variable from the second <code>.then()</code> callback, nor <code>meta</code> from the third <code>.then()</code> anymore! <code>Promise</code> chaining can tame callback hell, but only by forfeiting JavaScript's closure superpowers. It's hardly ideal—local variables are the bread-and-butter of state management in functional programming.</p>
<h2 id="recapasyncfunctions">Recap: Async Functions</h2>
<p>Luckily, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">ES2017 <code>async</code> functions</a> merge the benefits of both approaches. Rewriting our <code>updateMP3Meta()</code> as an <code>async</code> function yields:</p>
<pre><code class="language-javascript">let updateMP3Meta = async (path) =&gt; {
  let file = await read(path);
  let meta = await parseMP3(file);
  let song = await Song.findByName(file.name);
  Object.assign(song, meta);
  return song.save();
};
</code></pre>
<p>Hurray! <code>async</code> functions give us local scoping back without descending into callback hell.</p>
<p>However, <code>updateMP3Meta()</code> unnecessarily forces some things to run serially. In particular, MP3 parsing and searching the database for a matching <code>Song</code> can actually be done in parallel; but the <code>await</code> operator forces <code>Song.findByName()</code> to run only after <code>parseMP3()</code> finishes.</p>
<h2 id="workinginparallel">Working in Parallel</h2>
<p>To get the most out of our single-threaded program, we need to invoke JavaScript's event loop superpowers. We can queue two async operations and wait for both to complete:</p>
<pre><code class="language-javascript">let updateMP3Meta = (path) =&gt; {
  return read(path)
    .then(file =&gt; {
      return Promise.all([
        parseMP3(file),
        Song.findByName(file.name)
      ]);
    })
    .then(([meta, song]) =&gt; {
      Object.assign(song, meta);
      return song.save();
    });
};
</code></pre>
<p>We used <code>Promise.all()</code> to wait for concurrent operations to finish, then aggregated the results to update the <code>Song</code>. <code>Promise.all()</code> works just fine for a few concurrent spots, but code quickly devolves when you alternate between chunks of code that can be executed concurrently and others that are serial. This intrinsic ugliness is not much improved with <code>async</code> functions:</p>
<pre><code class="language-javascript">let updateMP3Meta = async (path) =&gt; {
  let file = await read(path);
  let metaPromise = parseMP3(file);
  let songPromise = Song.findByName(file.name);

  let meta = await metaPromise;
  let song = await songPromise;

  Object.assign(song, meta);
  return song.save();
};
</code></pre>
<p>Instead of using an inline <code>await</code>, we used <code>[meta|song]Promise</code> local variables to begin an operation without blocking, then <code>await</code> both promises. While <code>async</code> functions make concurrent code easier to read, there is an underlying structural ugliness: we are manually telling JavaScript what parts can run concurrently, and when it should block for serial code. It's okay for a spot or two, but when multiple chunks of serial code can be run concurrently, it gets incredibly unruly.</p>
<p>We are essentially deriving the <a href="https://en.wikipedia.org/wiki/Dependency_graph#Deriving_an_evaluation_order">evaluation order of a dependency tree</a>… and hardcoding the solution. This means "minor" changes, like swapping out a synchronous API for an async one, will cause drastic rewrites. That's a code smell!</p>
<h2 id="realcode">Real Code</h2>
<p>To demonstrate this underlying ugliness, let's try a more complex example. I recently worked on an <a href="https://jonathanleemartin.com/blog/encore-javascript-create-an-mp3-reader-with-dataviews-textdecoder/">MP3 importer</a> in JavaScript that involved a fair amount of async work. (Check out <a href="https://jonathanleemartin.com/blog/encore-javascript-create-an-mp3-reader-with-dataviews-textdecoder/">my blog post</a> or the <a href="https://github.com/bignerdranch/id3-meta">parser source code</a> if you're interested in working with binary data and text encodings.)</p>
<p>The main function takes in a <code>File</code> object (from drag-and-drop), loads it into an <code>ArrayBuffer</code>, parses MP3 metadata, computes the MP3's duration, creates an <code>Album</code> in <code>IndexedDB</code> if one doesn't already exist, and finally creates a new <code>Song</code>:</p>
<pre><code class="language-javascript">import parser from 'id3-meta';
import read from './file-reader';
import getDuration from './duration';
import { mapSongMeta, mapAlbumMeta } from './meta';
import importAlbum from './album-importer';
import importSong from './song-importer';

export default async (file) =&gt; {
  // Read the file
  let buffer = await read(file);

  // Parse out the ID3 metadata
  let meta = await parser(file);
  let songMeta = mapSongMeta(meta);
  let albumMeta = mapAlbumMeta(meta);

  // Compute the duration
  let duration = await getDuration(buffer);

  // Import the album
  let albumId = await importAlbum(albumMeta);

  // Import the song
  let songId = await importSong({
    ...songMeta, albumId, file, duration, meta
  });

  return songId;
};
</code></pre>
<p>This looks straightforward enough, but we're forcing some async operations to run sequentially that can be executed concurrently. In particular, we could compute <code>getDuration()</code> at the same time that we parse the MP3 and import a new album. However, both operations will need to finish before invoking <code>importSong()</code>.</p>
<p>Our first try might look like this:</p>
<pre><code class="language-javascript">export default async (file) =&gt; {
  // Read the file
  let buffer = await read(file);

  // Compute the duration
  let durationPromise = getDuration(buffer);

  // Parse out the ID3 metadata
  let metaPromise = parser(file);
  let meta = await metaPromise;

  let songMeta = mapSongMeta(meta);
  let albumMeta = mapAlbumMeta(meta);

  // Import the album
  let albumIdPromise = importAlbum(albumMeta);

  let duration = await durationPromise;
  let albumId = await albumIdPromise;

  // Import the song
  let songId = await importSong({
    ...songMeta, albumId, file, duration, meta
  });

  return songId;
};
</code></pre>
<p>That took a fair amount of brain tetris to get the order of <code>await</code>s right: if we hadn't moved <code>getDuration()</code> up a few lines in the function, we would have created a poor solution since <code>importAlbum()</code> only depends on <code>albumMeta</code>, which only depends on <code>meta</code>. But this solution is still suboptimal! <code>getDuration()</code> depends on <code>buffer</code>, but <code>parser()</code> could be executing at the same time as <code>read()</code>. To get the best solution, we would have to use <code>Promise.all()</code> and <code>.then()</code>s.</p>
<p>To solve the underlying problem without evaluating a dependency graph by hand, we need to define groups of serial steps (which execute one-by-one in a blocking fashion), and combine those groups concurrently.</p>
<p>What if there was a way to define such a dependency graph that's readable, doesn't break closures, doesn't resort to <code>.then()</code>, and doesn't require a library?</p>
<h2 id="asynciifes">Async IIFEs</h2>
<p>That's where <strong>async IIFEs</strong> come in. For every group of serial (dependent) operations, we'll wrap them up into a micro API called a "task":</p>
<pre><code class="language-javascript">let myTask = (async () =&gt; {
  let other = await otherTask;
  let result = await doCompute(other.thing);
  return result;
})();
</code></pre>
<p>Since all <code>async</code> functions return a <code>Promise</code>, the <code>myTask</code> local variable contains a <code>Promise</code> that will resolve to <code>result</code>. I prefer to call these <code>*Task</code> instead of <code>*Promise</code>. Inside the async IIFE, operations are sequential, but outside we aren't blocking anything. Furthermore, inside a task we can wait on other tasks to finish, like <code>otherTask</code>, which could be another async IIFE.</p>
<p>Let's turn the <code>getDuration()</code> section into a task called <code>durationTask</code>:</p>
<pre><code class="language-javascript">let durationTask = (async () =&gt; {
  let buffer = await readTask;
  let duration = await getDuration(buffer);
  return duration;
})();
</code></pre>
<p>Since these tasks are defined inline, they have access to variables in the outer closure, including other tasks!</p>
<h2 id="refactoringintoasynctasks">Refactoring into Async Tasks</h2>
<p>Let's refactor the entire importer with async IIFEs, or "tasks":</p>
<pre><code class="language-javascript">export default async (file) =&gt; {
  // Read the file
  let readTask = read(file);

  // Parse out the ID3 metadata
  let metaTask = (async () =&gt; {
    let meta = await parser(file);
    let songMeta = mapSongMeta(meta);
    let albumMeta = mapAlbumMeta(meta);
    return { meta, songMeta, albumMeta };
  })();

  // Import the album
  let albumImportTask = (async () =&gt; {
    let { albumMeta } = await metaTask;
    let albumId = await importAlbum(albumMeta);
    return albumId;
  })();

  // Compute the duration
  let durationTask = (async () =&gt; {
    let buffer = await readTask;
    let duration = await getDuration(buffer);
    return duration;
  })();

  // Import the song
  let songImportTask = (async () =&gt; {
    let albumId = await albumImportTask;
    let { meta, songMeta } = await metaTask;
    let duration = await durationTask;

    let songId = await importSong({
      ...songMeta, albumId, file, duration, meta
    });

    return songId;
  })();

  let songId = await songImportTask;

  return songId;
};
</code></pre>
<p>Now reading the file, computing duration, parsing metadata and database querying will automatically run concurrently or serially—we were even able to leave <code>getDuration()</code> in its original spot! By declaring tasks and <code>await</code>ing them inside other tasks, we defined a dependency graph for the runtime and let it <em>discover</em> the optimal solution for us.</p>
<p>Suppose we wanted to add another step to the import process, like retrieving album artwork from a web service:</p>
<pre><code class="language-javascript">// Look up album artwork from a web service
let albumArtwork = await fetchAlbumArtwork(albumMeta);
</code></pre>
<p>Prior to the async IIFE refactor, adding this feature would have triggered a lot of changes throughout the file, but now we can add it with just a small isolated chunk of additions!</p>
<pre><code class="language-diff">+// Look up album artwork from a web service
+let artworkTask = (async () =&gt; {
+  let { albumMeta } = await metaTask;
+  let artwork = await fetchAlbumArtwork(albumMeta);
+  return artwork;
+})();

 // Import the album
 let albumImportTask = (async () =&gt; {
+  let artwork = await artworkTask;
   let { albumMeta } = await metaTask;
-  let albumId = await importAlbum(albumMeta);
+  let albumId = await importAlbum({ artwork, ...albumMeta });
   return albumId;
 })();
</code></pre>
<p>Tasks are declarative, so managing concurrent vs. serial execution order becomes an "execution detail" instead of an "implementation detail"!</p>
<p>What if we revamped our <code>parser()</code> function so it could synchronously parse an <code>ArrayBuffer</code> instead of a <code>File</code> object? Before this would have triggered a cascade of line reordering, but now the change is trivial:</p>
<pre><code class="language-diff"> // Parse out the ID3 metadata
 let metaTask = (async () =&gt; {
+  let buffer = await readTask;
-  let meta = await parser(file);
+  let meta = parser(buffer);
   let songMeta = mapSongMeta(meta);
   let albumMeta = mapAlbumMeta(meta);
   return { meta, songMeta, albumMeta };
 })();
</code></pre>
<h2 id="objections">Objections</h2>
<p>It's tempting to take shortcuts and solve the dependency graph yourself. For example, after our changes to <code>parser()</code> above, all of the tasks depend on the file being read in, so you <em>could</em> block the entire function with <code>await read(file)</code> to save a few lines. However, these areas are likely to change, and organizing into serial tasks provides other benefits: these micro APIs make it is easier to read, debug, extract and reason about a complex chunk of concurrency.</p>
<p>Since we wrapped these tasks into async IIFEs, why not extract them into dedicated functions? For the same reason we couldn't use <code>Promise</code> chaining: we have to give up nested closures and lexically scoped variables. Extracting tasks into top level functions also begs a design question: <em>if all these operations were synchronous, would we still perform this extraction?</em></p>
<p>If you find yourself extracting <code>async</code> functions (as we did with <code>importAlbum()</code> and <code>importSong()</code>) because of their complexity or reusability, bravo! But ultimately, design principles for breaking down functions should be independent of whether the code is async vs. sync.</p>
<p>Also, splitting functions or moving them too far from their context makes code harder to grasp, <a href="https://jonathanleemartin.com/blog/youre-killin-me-smalls-are-small-objects-good/">as Josh discusses in his post about extracting methods</a>.</p>
<h2 id="moretocome">More to Come</h2>
<p>Functional programming is well-suited to multithreading because it minimizes shared state and opts for local variables as the de facto state mechanism. And thanks to JavaScript's event loop, we can deal with shared state by <em>merging</em> results inside a single thread.</p>
<p>Next time, we'll examine functional patterns for throttling concurrency on a single thread, then wrap up with techniques for efficiently managing a cluster of Web Workers… without worrying a shred about "thread safety."</p>


            </section>

        </article>
    </main>
    <footer class="site-footer clearfix">
        <section class="copyright"><a href="https://jonathanleemartin.com">tl;dr</a> &copy; 2019</section>
        <section class="poweredby">Proudly published with <a href="https://ghost.org">Ghost</a></section>
    </footer>
</body>
</html>
