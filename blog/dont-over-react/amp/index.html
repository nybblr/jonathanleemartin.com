<!DOCTYPE html>
<html ⚡>
<head>
    <meta charset="utf-8">

    <title>Don’t Over React! Render Binary Data with Class.</title>

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">

    <meta name="description" content="Eventually, your React web app will accept file uploads. JavaScript has exceptional APIs for handling chunks of binary data, but the interaction with React can cause some major performance hiccups. Discover the performance implications of 5 different ways to work with user-submitted binary data!" />
    <link rel="shortcut icon" href="/favicon.png" type="image/png" />
    <link rel="canonical" href="https://jonathanleemartin.com/blog/dont-over-react/" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    
    <meta property="og:site_name" content="tl;dr" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Don’t Over React! Render Binary Data with Class." />
    <meta property="og:description" content="Eventually, your React web app will accept file uploads. JavaScript has exceptional APIs for handling chunks of binary data, but the interaction with React can cause some major performance hiccups. Discover the performance implications of 5 different ways to work with user-submitted binary data!" />
    <meta property="og:url" content="https://jonathanleemartin.com/blog/dont-over-react/" />
    <meta property="article:published_time" content="2017-12-05T12:00:00.000Z" />
    <meta property="article:modified_time" content="2019-08-12T15:56:39.000Z" />
    <meta property="article:tag" content="React" />
    <meta property="article:tag" content="JavaScript" />
    
    <meta property="article:publisher" content="https://www.facebook.com/yellowscale" />
    <meta property="article:author" content="https://www.facebook.com/yellowscale" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Don’t Over React! Render Binary Data with Class." />
    <meta name="twitter:description" content="Eventually, your React web app will accept file uploads. JavaScript has exceptional APIs for handling chunks of binary data, but the interaction with React can cause some major performance hiccups. Discover the performance implications of 5 different ways to work with user-submitted binary data!" />
    <meta name="twitter:url" content="https://jonathanleemartin.com/blog/dont-over-react/" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Jonathan Lee Martin" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="React, JavaScript" />
    <meta name="twitter:site" content="@nybblr" />
    <meta name="twitter:creator" content="@nybblr" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "tl;dr",
        "logo": {
            "@type": "ImageObject",
            "url": "https://jonathanleemartin.com/content/images/2019/08/logo.png",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Jonathan Lee Martin",
        "image": {
            "@type": "ImageObject",
            "url": "//www.gravatar.com/avatar/6dc50195bf39376a9154e48d6b5df778?s=250&d=mm&r=x",
            "width": 250,
            "height": 250
        },
        "url": "https://jonathanleemartin.com/author/jonathan/",
        "sameAs": [
            "https://jonathanleemartin.com/",
            "https://www.facebook.com/yellowscale",
            "https://twitter.com/nybblr"
        ]
    },
    "headline": "Don’t Over React! Render Binary Data with Class.",
    "url": "https://jonathanleemartin.com/blog/dont-over-react/",
    "datePublished": "2017-12-05T12:00:00.000Z",
    "dateModified": "2019-08-12T15:56:39.000Z",
    "keywords": "React, JavaScript",
    "description": "Eventually, your React web app will accept file uploads. JavaScript has exceptional APIs for handling chunks of binary data, but the interaction with React can cause some major performance hiccups. Discover the performance implications of 5 different ways to work with user-submitted binary data!",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://jonathanleemartin.com/"
    }
}
    </script>

    <meta name="generator" content="Ghost 2.27" />
    <link rel="alternate" type="application/rss+xml" title="tl;dr" href="" />

    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,600,400" />
    <style amp-custom>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}h1{margin:0.67em 0;font-size:2em}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{position:relative;vertical-align:baseline;font-size:75%;line-height:0}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}amp-img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace, monospace;font-size:1em}button,input,optgroup,select,textarea{margin:0;color:inherit;font:inherit}button{overflow:visible}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{cursor:pointer;-webkit-appearance:button}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}input{line-height:normal}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height:auto}input[type="search"]{-webkit-appearance:textfield}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{margin:0 2px;padding:0.35em 0.625em 0.75em;border:1px solid #c0c0c0}legend{padding:0;border:0}textarea{overflow:auto}optgroup{font-weight:bold}table{border-spacing:0;border-collapse:collapse}td,th{padding:0}html{max-height:100%;height:100%;font-size:62.5%;-webkit-tap-highlight-color:rgba(0, 0, 0, 0)}body{max-height:100%;height:100%;color:#3a4145;background:#f4f8fb;letter-spacing:0.01rem;font-family:"Merriweather", serif;font-size:1.8rem;line-height:1.75em;text-rendering:geometricPrecision;-webkit-font-feature-settings:"kern" 1;-moz-font-feature-settings:"kern" 1;-o-font-feature-settings:"kern" 1}::-moz-selection{background:#d6edff}::selection{background:#d6edff}h1,h2,h3,h4,h5,h6{margin:0 0 0.3em 0;color:#2e2e2e;font-family:"Open Sans", sans-serif;line-height:1.15em;text-rendering:geometricPrecision;-webkit-font-feature-settings:"dlig" 1, "liga" 1, "lnum" 1, "kern" 1;-moz-font-feature-settings:"dlig" 1, "liga" 1, "lnum" 1, "kern" 1;-o-font-feature-settings:"dlig" 1, "liga" 1, "lnum" 1, "kern" 1}h1{text-indent:-2px;letter-spacing:-1px;font-size:2.6rem}h2{letter-spacing:0;font-size:2.4rem}h3{letter-spacing:-0.6px;font-size:2.1rem}h4{font-size:1.9rem}h5{font-size:1.8rem}h6{font-size:1.8rem}a{color:#4a4a4a}a:hover{color:#111}p,ul,ol,dl{margin:0 0 2.5rem 0;font-size:1.5rem;text-rendering:geometricPrecision;-webkit-font-feature-settings:"liga" 1, "onum" 1, "kern" 1;-moz-font-feature-settings:"liga" 1, "onum" 1, "kern" 1;-o-font-feature-settings:"liga" 1, "onum" 1, "kern" 1}ol,ul{padding-left:2em}ol ol,ul ul,ul ol,ol ul{margin:0 0 0.4em 0;padding-left:2em}dl dt{float:left;clear:left;overflow:hidden;margin-bottom:1em;width:180px;text-align:right;text-overflow:ellipsis;white-space:nowrap;font-weight:700}dl dd{margin-bottom:1em;margin-left:200px}li{margin:0.4em 0}li li{margin:0}hr{display:block;margin:1.75em 0;padding:0;height:1px;border:0;border-top:#efefef 1px solid}blockquote{box-sizing:border-box;margin:1.75em 0 1.75em 0;padding:0 0 0 1.75em;border-left:#4a4a4a 0.4em solid;-moz-box-sizing:border-box}blockquote p{margin:0.8em 0;font-style:italic}blockquote small{display:inline-block;margin:0.8em 0 0.8em 1.5em;color:#ccc;font-size:0.9em}blockquote small:before{content:"\2014 \00A0"}blockquote cite{font-weight:700}blockquote cite a{font-weight:normal}mark{background-color:#fdffb6}code,tt{padding:1px 3px;border:#e3edf3 1px solid;background:#f7fafb;border-radius:2px;white-space:pre-wrap;font-family:Inconsolata, monospace, sans-serif;font-size:0.85em;font-feature-settings:"liga" 0;-webkit-font-feature-settings:"liga" 0;-moz-font-feature-settings:"liga" 0}pre{overflow:auto;box-sizing:border-box;margin:0 0 1.75em 0;padding:10px;width:100%;border:#e3edf3 1px solid;background:#f7fafb;border-radius:3px;white-space:pre;font-family:Inconsolata, monospace, sans-serif;font-size:0.9em;-moz-box-sizing:border-box}pre code,pre tt{padding:0;border:none;background:transparent;white-space:pre-wrap;font-size:inherit}kbd{display:inline-block;margin-bottom:0.4em;padding:1px 8px;border:#ccc 1px solid;background:#f4f4f4;border-radius:4px;box-shadow:0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 0 #fff inset;color:#666;text-shadow:#fff 0 1px 0;font-size:0.9em;font-weight:700}table{box-sizing:border-box;margin:1.75em 0;max-width:100%;width:100%;background-color:transparent;-moz-box-sizing:border-box}table th,table td{padding:8px;border-top:#efefef 1px solid;vertical-align:top;text-align:left;line-height:20px}table th{color:#000}table caption + thead tr:first-child th,table caption + thead tr:first-child td,table colgroup + thead tr:first-child th,table colgroup + thead tr:first-child td,table thead:first-child tr:first-child th,table thead:first-child tr:first-child td{border-top:0}table tbody + tbody{border-top:#efefef 2px solid}table table table{background-color:#fff}table tbody > tr:nth-child(odd) > td,table tbody > tr:nth-child(odd) > th{background-color:#f6f6f6}table.plain tbody > tr:nth-child(odd) > td,table.plain tbody > tr:nth-child(odd) > th{background:transparent}iframe,amp-iframe,.fluid-width-video-wrapper{display:block;margin:1.75em 0}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper amp-iframe{margin:0}textarea,select,input{margin:0 0 5px 0;padding:6px 9px;width:260px;outline:0;border:#e7eef2 1px solid;background:#fff;border-radius:4px;box-shadow:none;font-family:"Open Sans", sans-serif;font-size:1.6rem;line-height:1.4em;font-weight:100;-webkit-appearance:none}textarea{min-width:250px;min-height:80px;max-width:340px;width:100%;height:auto}input[type="text"]:focus,input[type="email"]:focus,input[type="search"]:focus,input[type="tel"]:focus,input[type="url"]:focus,input[type="password"]:focus,input[type="number"]:focus,input[type="date"]:focus,input[type="month"]:focus,input[type="week"]:focus,input[type="time"]:focus,input[type="datetime"]:focus,input[type="datetime-local"]:focus,textarea:focus{outline:none;outline-width:0;border:#bbc7cc 1px solid;background:#fff}select{width:270px;height:30px;line-height:30px}.clearfix:before,.clearfix:after{content:" ";display:table}.clearfix:after{clear:both}.clearfix{zoom:1}.main-header{position:relative;display:table;overflow:hidden;box-sizing:border-box;width:100%;height:50px;background:#5ba4e5 no-repeat center center;background-size:cover;text-align:left;-webkit-box-sizing:border-box;-moz-box-sizing:border-box}.content{background:#fff;padding-top:15px}.blog-title,.content{margin:auto;max-width:600px}.blog-title a{display:block;padding-right:16px;padding-left:16px;height:50px;color:#fff;text-decoration:none;font-family:"Open Sans", sans-serif;font-size:16px;line-height:50px;font-weight:600}.post{position:relative;margin-top:0;margin-right:16px;margin-left:16px;padding-bottom:0;max-width:100%;border-bottom:#ebf2f6 1px solid;word-wrap:break-word;font-size:0.95em;line-height:1.65em}.post-header{margin-bottom:1rem}.post-title{margin-bottom:0}.post-title a{text-decoration:none}.post-meta{display:block;margin:3px 0 0 0;color:#9eabb3;font-family:"Open Sans", sans-serif;font-size:1.3rem;line-height:2.2rem}.post-meta a{color:#9eabb3;text-decoration:none}.post-meta a:hover{text-decoration:underline}.post-meta .author{margin:0;font-size:1.3rem;line-height:1.3em}.post-date{display:inline-block;text-transform:uppercase;white-space:nowrap;font-size:1.2rem;line-height:1.2em}.post-image{margin:0;padding-top:3rem;padding-bottom:30px;border-top:1px #E8E8E8 solid}.post-content amp-img,.post-content amp-anim{position:relative;left:50%;display:block;padding:0;min-width:0;max-width:112%;width:calc(100% + 32px);height:auto;transform:translateX(-50%);-webkit-transform:translateX(-50%);-ms-transform:translateX(-50%)}.footnotes{font-size:1.3rem;line-height:1.6em;font-style:italic}.footnotes li{margin:0.6rem 0}.footnotes p{margin:0}.footnotes p a:last-child{text-decoration:none}.site-footer{position:relative;margin:0 auto 20px auto;padding:1rem 15px;max-width:600px;color:rgba(0,0,0,0.5);font-family:"Open Sans", sans-serif;font-size:1.1rem;line-height:1.75em}.site-footer a{color:rgba(0,0,0,0.5);text-decoration:none;font-weight:bold}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.poweredby{display:block;float:right;width:45%;text-align:right}.copyright{display:block;float:left;width:45%}</style>

    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>

    

</head>

<body class="amp-template">
    <header class="main-header">
        <nav class="blog-title">
            <a href="https://jonathanleemartin.com">tl;dr</a>
        </nav>
    </header>

    <main class="content" role="main">
        <article class="post">

            <header class="post-header">
                <h1 class="post-title">Don’t Over React! Render Binary Data with Class.</h1>
                <section class="post-meta">
                    <p class="author">by <a href="/author/jonathan/">Jonathan Lee Martin</a></p>
                    <time class="post-date" datetime="2017-12-05">2017-12-05</time>
                </section>
            </header>
            <section class="post-content">

                <p><small><em>This post first appeared on the <a href="https://www.bignerdranch.com/blog/dont-over-react/">Big Nerd Ranch blog</a>.</em></small></p>
<p>Sooner or later, your React web app will probably accept file uploads—perhaps to change out a user’s avatar or share images on a social site.</p>
<p>In modern browsers, the story for <a href="https://jonathanleemartin.com/blog/encore-javascript-create-an-mp3-reader-with-dataviews-textdecoder/">working with binary data is downright impressive</a> thanks to objects like <code>File</code>, <code>Blob</code> and <code>ArrayBuffer</code>. You can even store large complex binary data directly in the browser with <code>IndexedDB</code>!</p>
<p>But working with binary data in a sandboxed tab is different from how a backend or native desktop app handles it. If you read in a 5MB image to a <code>String</code>, you will probably crash the tab. Read in 10 images simultaneously and you may crash the browser!</p>
<p>Luckily, JavaScript exposes natively implemented APIs to handle chunks of binary data. With some creativity, you can have the user’s browser pull its own weight, like <a href="https://gist.github.com/nybblr/d6073b742976104113a0597fbf159e0b">resizing images on the front-end before upload</a>. But before you create your own React-powered Hipstergram, it’s important to understand the performance implications of binary data in a web app.</p>
<h2 id="recapfileobjectsandblobs">Recap: File Objects and Blobs</h2>
<p>The browser can’t directly access the file system for security reasons, but users can drop files into the browser with drag-and-drop.</p>
<p>Here’s a barebones React component that accepts a file, like an image:</p>
<pre><code class="language-jsx">let Drop = () =&gt;
  &lt;div onDragOver={e =&gt; e.preventDefault()}
       onDrop={e =&gt; {
         e.preventDefault()
         let file = e.dataTransfer.files[0]
         console.log(file)
       } }
  &gt;
    ...
  &lt;/div&gt;
</code></pre>
<p>Once the user drags-and-drops an image onto this <code>&lt;Drop&gt;</code> component, they probably expect to see a thumbnail-sized preview in the browser. The browser provides access to read in the file contents in a few formats like a <code>String</code> or <code>ArrayBuffer</code>, but each image could be 5 MB; drop 10 in the browser and you have 50 MB strings in memory!</p>
<p>So instead of directly returning a <code>String</code> or <code>ArrayBuffer</code>, the browser returns a <code>Blob</code> object. A <code>Blob</code> is essentially a pointer to a data source—it could point to a file on disk, an <code>ArrayBuffer</code>, streaming data, etc. Specifically, the <code>e.dataTransfer.files</code> array holds one or more <code>File</code> objects, which are <code>Blob</code>s with some extra metadata. <code>File</code> objects come with a few more properties, like the source file’s name.</p>
<p>To display the image in the DOM, e.g. with an <code>&lt;img /&gt;</code> tag, you can ask the browser for an ephemeral URL to the <code>Blob</code> object. This URL will only be valid while the tab is open:</p>
<pre><code class="language-jsx">...
let file = e.dataTransfer.files[0]
let url = URL.createObjectURL(file)
console.log(url)
// =&gt; "blob:http://localhost:3000/266c0711-76dd-4a24-af1f-46a8014204ff"
</code></pre>
<p>You can use a <code>blob:</code> URL wherever you would put any other URL—like <code>http://localhost:3000/images/logo.png</code>—and it just works!</p>
<h2 id="thetroublewithjustrerender">The Trouble with “Just Rerender”</h2>
<p>How do you use <code>blob:</code> URLs in React? Here’s a simple React app that accepts a dropped image and renders it on screen:</p>
<pre><code class="language-jsx">class App extends Component {
  state = { file: null }

  onDrag = event =&gt; {
    event.preventDefault()
  }

  onDrop = event =&gt; {
    event.preventDefault()
    let file = event.dataTransfer.files[0]
    this.setState({ file })
  }

  render() {
    let { file } = this.state
    let url = file &amp;&amp; URL.createObjectURL(file)

    return (
      &lt;div onDragOver={this.onDrag} onDrop={this.onDrop}&gt;
        &lt;p&gt;Drop an image!&lt;/p&gt;
        &lt;img src={url} /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>The <code>App</code> component starts without any file; when an image file is dropped onto the <code>&lt;div&gt;</code> element, it updates the state and rerenders with a <code>Blob</code> URL. Easy peasy!</p>
<p>But what happens if this component’s props or state changes? Let’s add a counter that changes 10 times a second:</p>
<pre><code class="language-diff"> class App extends Component {
-  state = { file: null }
+  state = { file: null, counter: 0 }

+  refresh = () =&gt; {
+    this.setState(({ counter }) =&gt; ({ counter: counter + 1 }))
+  }

+  componentDidMount() {
+    this.timer = setInterval(this.refresh, 100)
+  }

+  componentWillUnmount() {
+    clearInterval(this.timer)
+  }

   onDrag = event =&gt; {
     event.preventDefault()
   }

   onDrop = event =&gt; {
     event.preventDefault()
     let file = event.dataTransfer.files[0]
     this.setState({ file })
   }

   render() {
     let { file } = this.state
     let url = file &amp;&amp; URL.createObjectURL(file)

     return (
       &lt;div onDragOver={this.onDrag} onDrop={this.onDrop}&gt;
         &lt;p&gt;Drop an image!&lt;/p&gt;
         &lt;img src={url} /&gt;
       &lt;/div&gt;
     )
   }
 }
</code></pre>
<p>This forces React to rerender the <code>&lt;App&gt;</code> component 10 times a second. That’s fine since React is designed to handle this well, but there’s a problem: the <code>blob:</code> URL changes on every rerender! We can confirm this from the Sources panel in Chrome:</p>
<p></p>
<p>It seems the inline call to <code>URL.createObjectURL()</code> creates tons of extra <code>blob:</code> URLs that never get cleaned up: we’re leaking memory! Changing the URL every single rerender also causes the DOM to change, so sometimes the image will flicker since the browser’s caching mechanism doesn’t know the old and new <code>blob:</code> URLs point to the same image.</p>
<p></p>
<p>At a rerender rate of just 10 times a second, CPU usage explodes to an entire core and bloats memory usage. Eventually garbage collection will catch up, but at the cost of even more CPU usage.</p>
<h2 id="solution1memoizeinclasscomponent">Solution #1: Memoize in Class Component</h2>
<p>For our trivial example, we can introduce an easy fix: just create the <code>Blob</code> URL once and store it in the <code>&lt;App&gt;</code> component’s state:</p>
<pre><code class="language-diff"> class App extends Component {
-  state = { file: null, counter: 0 }
+  state = { url: '', counter: 0 }

   ...

   onDrop = event =&gt; {
     event.preventDefault()
     let file = event.dataTransfer.files[0]
-    this.setState({ file })
+    this.setState({ url: URL.createObjectURL(file) })
   }

   render() {
-    let { file } = this.state
-    let url = file &amp;&amp; URL.createObjectURL(file)
+    let { url } = this.state

     return (
       ...
     )
   }
 }
</code></pre>
<p>That totally works, but only if you plan to do nothing else with the data. After the file is dropped, you will likely need to pass the original <code>Blob</code> object around to other React components, perhaps to store it in <code>IndexedDB</code> or upload it with <code>FormData</code>.</p>
<h2 id="solution2itsjustanobjectaddaproperty">Solution #2: It’s Just an Object, Add a Property!</h2>
<p>What if we just passed around the immutable <code>Blob</code> object, but added a <code>url</code> property to it with the memoized <code>Blob</code> URL?</p>
<pre><code class="language-diff"> class App extends Component {
   ...

   render() {
     let { file } = this.state
-    let url = file &amp;&amp; URL.createObjectURL(file)
+    let url = file &amp;&amp; blobUrl(file)

     return (
       ...
     )
   }
 }
</code></pre>
<pre><code class="language-jsx">let blobUrl = blob =&gt; {
  if (!blob.url) {
    blob.url = URL.createObjectURL(blob)
  }
  return blob.url
}
</code></pre>
<p>That one change brings down CPU usage to near zero! But… we <a href="https://jonathanleemartin.com/blog/dont-over-react/TODO/josh-justice-link-to-principle">violated a design principle</a> by modifying an object—the <code>Blob</code> object—from an API that we don’t own.</p>
<h2 id="solution3globalvariable">Solution #3: Global Variable</h2>
<p>What if we passed around the <code>Blob</code> object, but instead of modifying it, we stored the generated <code>Blob</code> URL in a big lookup table that only the <code>blobUrl()</code> function can access?</p>
<p>Sounds like a global variable, right?</p>
<pre><code class="language-jsx">let hash = file =&gt; `${file.name}:${file.type}:${file.size}`

let urls = {}
let blobUrl = blob =&gt; {
  let key = hash(blob)
  if (!urls[key]) {
    urls[key] = URL.createObjectURL(blob)
  }
  return urls[key]
}
</code></pre>
<p>It’s a great idea, but difficult to execute because the keys in a Plain Ol’ JavaScript Object must be strings, so we can only make a best effort at creating a collision-resistant key per <code>Blob</code> object.</p>
<p>While this will likely work for <code>File</code> objects, it won’t do for <code>Blob</code> objects: they don't have a <code>.name</code> property, so the likelihood of a key collision would be much higher.</p>
<p>The only real way to create a unique hash per <code>Blob</code> object is to tag each <code>Blob</code> object with a unique ID, but then we’re back to modifying the <code>Blob</code> object. However, we’re on the right track.</p>
<h2 id="solution4es2015maps">Solution #4: ES2015 Maps</h2>
<p>We need a map type that accepts objects as keys. The POJO won’t do that, but the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code> datatype</a> introduced in ES2015 will! Each object has a unique identity because it has its own pointer (place in memory). The <code>Map</code> datatype uses that pointer as the key, so entries are guaranteed to be collision-free!</p>
<pre><code class="language-jsx">let urls = new Map()

let blobUrl = blob =&gt; {
  if (urls.has(blob)) {
    return urls.get(blob)
  } else {
    let url = URL.createObjectURL(blob)
    urls.set(blob, url)
    return url
  }
}
</code></pre>
<p>Boom! But we introduced a subtle problem: <strong>we’re leaking memory.</strong></p>
<p>That’s right! In JavaScript we normally don’t manually manage memory, but that doesn’t “free” you from thinking about memory management!</p>
<p>JavaScript employs several strategies and heuristics for efficient garbage collection (like <a href="https://en.wikipedia.org/wiki/Reference_counting">reference counting</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management">generational garbage collection</a>), but we can assume that objects are garbage collected when they are no longer “reachable.”</p>
<p>The <code>urls</code> local variable is in scope and reachable during the app’s entire lifetime. All keys and values in a <code>Map</code> stick around explicitly until removed. So unless we explicitly delete entries from the <code>Map</code>, the <code>Blob</code> objects <em>and</em> <code>blob:</code> URLs will always be reachable—they’ll never be garbage collected. We’re leaking memory!</p>
<h2 id="solution5es2015weakmaps">Solution #5: ES2015 WeakMaps</h2>
<p>What if we had a <code>Map</code> datatype that doesn’t prevent the keys from being garbage collected, and automatically deletes the key-value pair once the object becomes unreachable?</p>
<p>That’s precisely what a <code>WeakMap</code> does! It allows us to associate data with an object, but without modifying the original object. A <code>WeakMap</code> behaves like <a href="https://en.wikipedia.org/wiki/Weak_reference">weak references</a> do in Swift and Objective C. Think of them as a noncommittal friend: “If no one needs you, neither do I.”</p>
<pre><code class="language-diff">-let urls = new Map()
+let urls = new WeakMap()

 let blobUrl = blob =&gt; {
   if (urls.has(blob)) {
     return urls.get(blob)
   } else {
     let url = URL.createObjectURL(blob)
     urls.set(blob, url)
     return url
   }
 }
</code></pre>
<p><code>WeakMap</code>s are a great way for third-party libraries to “tag” external objects without modifying them. They’re especially useful for adding application-wide memoization.</p>
<p>Here’s the final solution for performant, flicker-free <code>Blob</code> previews:</p>
<pre><code class="language-jsx">let urls = new WeakMap()

let blobUrl = blob =&gt; {
  if (urls.has(blob)) {
    return urls.get(blob)
  } else {
    let url = URL.createObjectURL(blob)
    urls.set(blob, url)
    return url
  }
}

class App extends Component {
  state = { file: null, counter: 0 }

  refresh = () =&gt; {
    this.setState(({ counter }) =&gt; ({ counter: counter + 1 }))
  }

  componentDidMount() {
    this.timer = setInterval(this.refresh, 100)
  }

  componentWillUnmount() {
    clearInterval(this.timer)
  }

  onDrag = event =&gt; {
    event.preventDefault()
  }

  onDrop = event =&gt; {
    event.preventDefault()
    let file = event.dataTransfer.files[0]
    this.setState({ file })
  }

  render() {
    let { file } = this.state
    let url = file &amp;&amp; blobUrl(file)

    return (
      &lt;div onDragOver={this.onDrag} onDrop={this.onDrop}&gt;
        &lt;p&gt;Drop an image!&lt;/p&gt;
        &lt;img src={url} /&gt;
      &lt;/div&gt;
    )
  }
}
</code></pre>
<p>To reuse <code>blob:</code> URLs throughout your React application, just extract <code>blobUrl()</code> to its own utility file and invoke it directly from any component’s <code>render()</code> method! Or better yet, <a href="https://www.bignerdranch.com/blog/destroy-all-classes-turn-react-components-inside-out-with-functional-programming/">use stateless functional components</a>.</p>
<h2 id="wrapup">Wrap-Up</h2>
<p>JavaScript is well-equipped to deal efficiently with large chunks of memory, but you have to determine the best way to represent them. When possible, it’s best to use <code>Blob</code> URLs to keep them outside the JavaScript VM’s memory. Objects stored in global variables will never be garbage collected, but <code>WeakMap</code>s are a great solution to <a href="https://en.wikipedia.org/wiki/Reference_counting#reference_cycle">break reference cycles</a>.</p>
<p>ES2015 data structures like <code>WeakMap</code>s and <a href="https://www.bignerdranch.com/blog/cross-stitching-elegant-concurrency-patterns-for-javascript/">ES2017 async functions</a> highlight just how dedicated the JavaScript language is to high-performance modern application development!</p>


            </section>

        </article>
    </main>
    <footer class="site-footer clearfix">
        <section class="copyright"><a href="https://jonathanleemartin.com">tl;dr</a> &copy; 2019</section>
        <section class="poweredby">Proudly published with <a href="https://ghost.org">Ghost</a></section>
    </footer>
</body>
</html>
