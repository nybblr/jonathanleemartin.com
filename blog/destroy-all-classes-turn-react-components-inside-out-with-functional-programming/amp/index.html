<!DOCTYPE html>
<html ⚡>
<head>
    <meta charset="utf-8">

    <title>DESTROY ALL CLASSES: Turn React Components Inside Out with Functional Programming</title>

    <meta name="HandheldFriendly" content="True" />
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">

    <meta name="description" content="A real-world example of refactoring a React Native component into stateless functional components and higher-order components, in 5 steps." />
    <link rel="shortcut icon" href="/favicon.png" type="image/png" />
    <link rel="canonical" href="https://www.bignerdranch.com/blog/destroy-all-classes-turn-react-components-inside-out-with-functional-programming/" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    
    <meta property="og:site_name" content="tl;dr" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="DESTROY ALL CLASSES: Turn React Components Inside Out with Functional Programming" />
    <meta property="og:description" content="With React&#x27;s stateless functional components you can create ambitious apps that are 98% plain ol&#x27; JavaScript. In this real-world example, we&#x27;ll use functional programming and higher-order components to turn class-based React Components into stateless functional components." />
    <meta property="og:url" content="https://www.bignerdranch.com/blog/destroy-all-classes-turn-react-components-inside-out-with-functional-programming/" />
    <meta property="article:published_time" content="2017-07-19T12:00:00.000Z" />
    <meta property="article:modified_time" content="2019-08-09T16:02:54.000Z" />
    <meta property="article:tag" content="React" />
    <meta property="article:tag" content="JavaScript" />
    
    <meta property="article:publisher" content="https://www.facebook.com/yellowscale" />
    <meta property="article:author" content="https://www.facebook.com/yellowscale" />
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="DESTROY ALL CLASSES: Turn React Components Inside Out with Functional Programming" />
    <meta name="twitter:description" content="With React&#x27;s stateless functional components you can create ambitious apps that are 98% plain ol&#x27; JavaScript. In this real-world example, we&#x27;ll use functional programming and higher-order components to turn class-based React Components into stateless functional components." />
    <meta name="twitter:url" content="https://www.bignerdranch.com/blog/destroy-all-classes-turn-react-components-inside-out-with-functional-programming/" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Jonathan Lee Martin" />
    <meta name="twitter:label2" content="Filed under" />
    <meta name="twitter:data2" content="React, JavaScript" />
    <meta name="twitter:site" content="@nybblr" />
    <meta name="twitter:creator" content="@nybblr" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "tl;dr",
        "logo": {
            "@type": "ImageObject",
            "url": "https://jonathanleemartin.com/content/images/2019/08/logo.png",
            "width": 60,
            "height": 60
        }
    },
    "author": {
        "@type": "Person",
        "name": "Jonathan Lee Martin",
        "image": {
            "@type": "ImageObject",
            "url": "//www.gravatar.com/avatar/6dc50195bf39376a9154e48d6b5df778?s=250&d=mm&r=x",
            "width": 250,
            "height": 250
        },
        "url": "https://jonathanleemartin.com/author/jonathan/",
        "sameAs": [
            "https://jonathanleemartin.com/",
            "https://www.facebook.com/yellowscale",
            "https://twitter.com/nybblr"
        ]
    },
    "headline": "DESTROY ALL CLASSES: Turn React Components Inside Out with Functional Programming",
    "url": "https://jonathanleemartin.com/blog/destroy-all-classes-turn-react-components-inside-out-with-functional-programming/",
    "datePublished": "2017-07-19T12:00:00.000Z",
    "dateModified": "2019-08-09T16:02:54.000Z",
    "keywords": "React, JavaScript",
    "description": "With React&#x27;s stateless functional components you can create ambitious apps that are 98% plain ol&#x27; JavaScript. In this real-world example, we&#x27;ll use functional programming and higher-order components to turn class-based React Components into stateless functional components.",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "https://jonathanleemartin.com/"
    }
}
    </script>

    <meta name="generator" content="Ghost 2.27" />
    <link rel="alternate" type="application/rss+xml" title="tl;dr" href="https://jonathanleemartin.com/rss/" />

    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Merriweather:300,700,700italic,300italic|Open+Sans:700,600,400" />
    <style amp-custom>html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:bold}dfn{font-style:italic}h1{margin:0.67em 0;font-size:2em}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{position:relative;vertical-align:baseline;font-size:75%;line-height:0}sup{top:-0.5em}sub{bottom:-0.25em}img{border:0}amp-img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace, monospace;font-size:1em}button,input,optgroup,select,textarea{margin:0;color:inherit;font:inherit}button{overflow:visible}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{cursor:pointer;-webkit-appearance:button}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}input{line-height:normal}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height:auto}input[type="search"]{-webkit-appearance:textfield}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{margin:0 2px;padding:0.35em 0.625em 0.75em;border:1px solid #c0c0c0}legend{padding:0;border:0}textarea{overflow:auto}optgroup{font-weight:bold}table{border-spacing:0;border-collapse:collapse}td,th{padding:0}html{max-height:100%;height:100%;font-size:62.5%;-webkit-tap-highlight-color:rgba(0, 0, 0, 0)}body{max-height:100%;height:100%;color:#3a4145;background:#f4f8fb;letter-spacing:0.01rem;font-family:"Merriweather", serif;font-size:1.8rem;line-height:1.75em;text-rendering:geometricPrecision;-webkit-font-feature-settings:"kern" 1;-moz-font-feature-settings:"kern" 1;-o-font-feature-settings:"kern" 1}::-moz-selection{background:#d6edff}::selection{background:#d6edff}h1,h2,h3,h4,h5,h6{margin:0 0 0.3em 0;color:#2e2e2e;font-family:"Open Sans", sans-serif;line-height:1.15em;text-rendering:geometricPrecision;-webkit-font-feature-settings:"dlig" 1, "liga" 1, "lnum" 1, "kern" 1;-moz-font-feature-settings:"dlig" 1, "liga" 1, "lnum" 1, "kern" 1;-o-font-feature-settings:"dlig" 1, "liga" 1, "lnum" 1, "kern" 1}h1{text-indent:-2px;letter-spacing:-1px;font-size:2.6rem}h2{letter-spacing:0;font-size:2.4rem}h3{letter-spacing:-0.6px;font-size:2.1rem}h4{font-size:1.9rem}h5{font-size:1.8rem}h6{font-size:1.8rem}a{color:#4a4a4a}a:hover{color:#111}p,ul,ol,dl{margin:0 0 2.5rem 0;font-size:1.5rem;text-rendering:geometricPrecision;-webkit-font-feature-settings:"liga" 1, "onum" 1, "kern" 1;-moz-font-feature-settings:"liga" 1, "onum" 1, "kern" 1;-o-font-feature-settings:"liga" 1, "onum" 1, "kern" 1}ol,ul{padding-left:2em}ol ol,ul ul,ul ol,ol ul{margin:0 0 0.4em 0;padding-left:2em}dl dt{float:left;clear:left;overflow:hidden;margin-bottom:1em;width:180px;text-align:right;text-overflow:ellipsis;white-space:nowrap;font-weight:700}dl dd{margin-bottom:1em;margin-left:200px}li{margin:0.4em 0}li li{margin:0}hr{display:block;margin:1.75em 0;padding:0;height:1px;border:0;border-top:#efefef 1px solid}blockquote{box-sizing:border-box;margin:1.75em 0 1.75em 0;padding:0 0 0 1.75em;border-left:#4a4a4a 0.4em solid;-moz-box-sizing:border-box}blockquote p{margin:0.8em 0;font-style:italic}blockquote small{display:inline-block;margin:0.8em 0 0.8em 1.5em;color:#ccc;font-size:0.9em}blockquote small:before{content:"\2014 \00A0"}blockquote cite{font-weight:700}blockquote cite a{font-weight:normal}mark{background-color:#fdffb6}code,tt{padding:1px 3px;border:#e3edf3 1px solid;background:#f7fafb;border-radius:2px;white-space:pre-wrap;font-family:Inconsolata, monospace, sans-serif;font-size:0.85em;font-feature-settings:"liga" 0;-webkit-font-feature-settings:"liga" 0;-moz-font-feature-settings:"liga" 0}pre{overflow:auto;box-sizing:border-box;margin:0 0 1.75em 0;padding:10px;width:100%;border:#e3edf3 1px solid;background:#f7fafb;border-radius:3px;white-space:pre;font-family:Inconsolata, monospace, sans-serif;font-size:0.9em;-moz-box-sizing:border-box}pre code,pre tt{padding:0;border:none;background:transparent;white-space:pre-wrap;font-size:inherit}kbd{display:inline-block;margin-bottom:0.4em;padding:1px 8px;border:#ccc 1px solid;background:#f4f4f4;border-radius:4px;box-shadow:0 1px 0 rgba(0, 0, 0, 0.2), 0 1px 0 0 #fff inset;color:#666;text-shadow:#fff 0 1px 0;font-size:0.9em;font-weight:700}table{box-sizing:border-box;margin:1.75em 0;max-width:100%;width:100%;background-color:transparent;-moz-box-sizing:border-box}table th,table td{padding:8px;border-top:#efefef 1px solid;vertical-align:top;text-align:left;line-height:20px}table th{color:#000}table caption + thead tr:first-child th,table caption + thead tr:first-child td,table colgroup + thead tr:first-child th,table colgroup + thead tr:first-child td,table thead:first-child tr:first-child th,table thead:first-child tr:first-child td{border-top:0}table tbody + tbody{border-top:#efefef 2px solid}table table table{background-color:#fff}table tbody > tr:nth-child(odd) > td,table tbody > tr:nth-child(odd) > th{background-color:#f6f6f6}table.plain tbody > tr:nth-child(odd) > td,table.plain tbody > tr:nth-child(odd) > th{background:transparent}iframe,amp-iframe,.fluid-width-video-wrapper{display:block;margin:1.75em 0}.fluid-width-video-wrapper iframe,.fluid-width-video-wrapper amp-iframe{margin:0}textarea,select,input{margin:0 0 5px 0;padding:6px 9px;width:260px;outline:0;border:#e7eef2 1px solid;background:#fff;border-radius:4px;box-shadow:none;font-family:"Open Sans", sans-serif;font-size:1.6rem;line-height:1.4em;font-weight:100;-webkit-appearance:none}textarea{min-width:250px;min-height:80px;max-width:340px;width:100%;height:auto}input[type="text"]:focus,input[type="email"]:focus,input[type="search"]:focus,input[type="tel"]:focus,input[type="url"]:focus,input[type="password"]:focus,input[type="number"]:focus,input[type="date"]:focus,input[type="month"]:focus,input[type="week"]:focus,input[type="time"]:focus,input[type="datetime"]:focus,input[type="datetime-local"]:focus,textarea:focus{outline:none;outline-width:0;border:#bbc7cc 1px solid;background:#fff}select{width:270px;height:30px;line-height:30px}.clearfix:before,.clearfix:after{content:" ";display:table}.clearfix:after{clear:both}.clearfix{zoom:1}.main-header{position:relative;display:table;overflow:hidden;box-sizing:border-box;width:100%;height:50px;background:#5ba4e5 no-repeat center center;background-size:cover;text-align:left;-webkit-box-sizing:border-box;-moz-box-sizing:border-box}.content{background:#fff;padding-top:15px}.blog-title,.content{margin:auto;max-width:600px}.blog-title a{display:block;padding-right:16px;padding-left:16px;height:50px;color:#fff;text-decoration:none;font-family:"Open Sans", sans-serif;font-size:16px;line-height:50px;font-weight:600}.post{position:relative;margin-top:0;margin-right:16px;margin-left:16px;padding-bottom:0;max-width:100%;border-bottom:#ebf2f6 1px solid;word-wrap:break-word;font-size:0.95em;line-height:1.65em}.post-header{margin-bottom:1rem}.post-title{margin-bottom:0}.post-title a{text-decoration:none}.post-meta{display:block;margin:3px 0 0 0;color:#9eabb3;font-family:"Open Sans", sans-serif;font-size:1.3rem;line-height:2.2rem}.post-meta a{color:#9eabb3;text-decoration:none}.post-meta a:hover{text-decoration:underline}.post-meta .author{margin:0;font-size:1.3rem;line-height:1.3em}.post-date{display:inline-block;text-transform:uppercase;white-space:nowrap;font-size:1.2rem;line-height:1.2em}.post-image{margin:0;padding-top:3rem;padding-bottom:30px;border-top:1px #E8E8E8 solid}.post-content amp-img,.post-content amp-anim{position:relative;left:50%;display:block;padding:0;min-width:0;max-width:112%;width:calc(100% + 32px);height:auto;transform:translateX(-50%);-webkit-transform:translateX(-50%);-ms-transform:translateX(-50%)}.footnotes{font-size:1.3rem;line-height:1.6em;font-style:italic}.footnotes li{margin:0.6rem 0}.footnotes p{margin:0}.footnotes p a:last-child{text-decoration:none}.site-footer{position:relative;margin:0 auto 20px auto;padding:1rem 15px;max-width:600px;color:rgba(0,0,0,0.5);font-family:"Open Sans", sans-serif;font-size:1.1rem;line-height:1.75em}.site-footer a{color:rgba(0,0,0,0.5);text-decoration:none;font-weight:bold}.site-footer a:hover{border-bottom:#bbc7cc 1px solid}.poweredby{display:block;float:right;width:45%;text-align:right}.copyright{display:block;float:left;width:45%}</style>

    <style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript>
    <script async src="https://cdn.ampproject.org/v0.js"></script>

    

</head>

<body class="amp-template">
    <header class="main-header">
        <nav class="blog-title">
            <a href="https://jonathanleemartin.com">tl;dr</a>
        </nav>
    </header>

    <main class="content" role="main">
        <article class="post">

            <header class="post-header">
                <h1 class="post-title">DESTROY ALL CLASSES: Turn React Components Inside Out with Functional Programming</h1>
                <section class="post-meta">
                    <p class="author">by <a href="/author/jonathan/">Jonathan Lee Martin</a></p>
                    <time class="post-date" datetime="2017-07-19">2017-07-19</time>
                </section>
            </header>
            <section class="post-content">

                <p><small><em>This post first appeared on the <a href="https://www.bignerdranch.com/blog/destroy-all-classes-turn-react-components-inside-out-with-functional-programming/">Big Nerd Ranch blog</a>.</em></small></p>
<p><em>A real-world example of refactoring a class-based component from a React Native app into stateless functional components and higher-order components, in 5 steps.</em></p>
<p><a href="https://facebook.github.io/react/">React</a> is pretty awesome, and with <a href="https://facebook.github.io/react/docs/components-and-props.html#functional-and-class-components">stateless functional components</a> you can create ambitious apps that are 98% plain ol' JavaScript (optionally JSX), and are very <em>lightly</em> coupled to the framework.</p>
<p>Minimizing the surface area between React and your codebase has amazing benefits:</p>
<ol>
<li>Framework updates will have little effect on your code.</li>
<li>You can easily write isolated unit tests, instead of UI integration tests.</li>
</ol>
<p>There's an important catch to stateless functional components: you can't use state or lifecycle hooks. However, this design encourages component purity and makes it trivial to test our components — after all, it's just a function that maps data to virtual DOM!</p>
<blockquote>
<p>“Great, but I'm not building a static page — I need state, so I can’t use stateless functional components!”</p>
</blockquote>
<p>In a well-written React app, stateless functional components will cover most of your UI code, but an app's complexity typically relates to state management. To help bug-proof the remainder of our codebase, we are going to turn class-based React Components into stateless functional components with <strong>functional programming</strong> and <strong>higher-order components</strong> (HOC) to isolate state from our pure components.</p>
<p>If you aren't familiar with higher-order components, you may want to check out <a href="https://facebook.github.io/react/docs/higher-order-components.html">the official React guides</a> first.</p>
<h2 id="whatarethebenefits">What are the benefits?</h2>
<p>Why will destroying all classes with functional programming and higher-order components improve your codebase?</p>
<p>Imagine an app where all state is isolated, the rest of your app is a pure function of that state, and each layer of your component tree is trivial to debug directly from the React DevTools. Relish the thought of reliable hot module reloading in your React Native app.</p>
<p>Higher-order components are the ultimate incarnation of <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">composition over inheritance</a>, and in the process of turning our class components inside-out, subtle dependencies and nasty bugs pop right to the surface.</p>
<p>By avoiding classes, we can prevent a super common source of bugs: <strong>hidden state.</strong> We’ll also find testing gets easier as the software boundaries become self-evident.</p>
<p>Because higher-order components add behavior through composition, you can reuse complex state logic across different UIs and test it in isolation! For example, you can share a data fetching higher-order component between your React web app and React Native app.</p>
<h2 id="examplerefactoringareactnativecomponent">Example: Refactoring a React Native component</h2>
<p>Let's look at a real-world example from a React Native project. The <code>VideoPage</code> component is a screen in the mobile app that fetches videos from a backend API and displays them as a list. The component has been tidied up a bit to remove distractions, but is unchanged structurally.</p>
<pre><code class="language-jsx">import React, { Component } from 'react'
import { ScrollView, Text, View } from 'react-native'

import Loading from 'components/loading'
import Video from 'components/video'
import API from 'services/api'

class VideoPage extends Component {
  constructor(props) {
    super(props)
    this.state = { data: null }
  }

  async fetchData(id) {
    let res = await API.getVideos(id)
    let json = await res.json()
    this.setState({ data: json.videos })
  }

  componentWillMount() {
    this.fetchData(this.props.id)
  }

  renderVideo(video) {
    return (
      &lt;Video key={video.id} data={video} /&gt;
    )
  }

  renderVideoList() {
    if (this.state.data.videos.length &gt; 0) {
      return this.state.data.videos.map(video =&gt;
        this.renderVideo(video)
      )
    } else {
      return (
        &lt;View&gt;
          &lt;Text&gt;No videos found&lt;/Text&gt;
        &lt;/View&gt;
      )
    }
  }

  buildPage() {
    if (this.state.data) {
      return (
        &lt;ScrollView&gt;
          &lt;View&gt;
            &lt;Text&gt;{this.state.data.title}&lt;/Text&gt;
            { this.state.data.description ? &lt;Text&gt;{this.state.data.description}&lt;/Text&gt; : null }
          &lt;/View&gt;
          &lt;View&gt;
            {this.renderVideoList()}
          &lt;/View&gt;
        &lt;/ScrollView&gt;
      )
    } else {
      return &lt;Loading /&gt;
    }
  }

  render() {
    return this.buildPage()
  }
}

export default VideoPage
</code></pre>
<p>At 65 lines of code, the <code>VideoPage</code> component is pretty simple, but hides a lot of edge cases. Although there's some syntactic noise that could be removed to bring down the line count a bit, the deeper issue is the high branching complexity and conflation of responsibilities. This single component fetches data, branches on load status and video count, and renders the list of videos. It's tricky to test these behaviors and views in isolation, extract behaviors (like data fetching) for reuse or add performance optimizations.</p>
<p>Rather than jump to the end solution, it's more instructive to see the process. Here's our <em>five-step roadmap</em> to turn <code>VideoPage</code> inside out and <em>destroy all classes!</em></p>
<ol>
<li><strong>Turn instance methods into stateless functional components</strong></li>
<li><strong>Extract remaining instance methods to plain functions</strong></li>
<li><strong>Extract branching complexity with higher-order components</strong></li>
<li><strong>Create a data fetching higher-order component</strong></li>
<li><strong>Compose behaviors into a single <code>enhance()</code> function</strong></li>
</ol>
<h3 id="1turninstancemethodsintostatelessfunctionalcomponents">1. Turn instance methods into stateless functional components</h3>
<p>Our first step is to cut down on instance methods, so let's start by extracting <code>.buildPage()</code>, <code>.renderVideo()</code> and <code>.renderVideoList()</code> from the <code>VideoPage</code> class and make them top-level functions.</p>
<pre><code class="language-diff"> class VideoPage extends Component {
   ...

-  renderVideo(video) {
-    ...
-  }

-  renderVideoList() {
-    ...
-  }

-  buildPage() {
-    ...
-  }

   ...
 }

+let renderVideo = video =&gt; {
+  ...
+}

+let renderVideoList = () =&gt; {
+  ...
+}

+let buildPage = () =&gt; {
+  ...
+}
</code></pre>
<p>Hmm, those look like components now! Let's rename <code>renderVideoList()</code> and inline <code>renderVideo()</code>.</p>
<pre><code class="language-diff">-let renderVideo = video =&gt; { ... }

-let renderVideoList = () =&gt; {
+let VideoList = () =&gt; {
   if (this.state.data.videos.length &gt; 0) {
     return this.state.data.videos.map(video =&gt;
-      this.renderVideo(video)
+      &lt;Video key={video.id} data={video} /&gt;
     )
   } else {
</code></pre>
<p>Now that the new <code>VideoList</code> component doesn't have access to <code>this</code>, we need to directly pass the data it needs as props. A quick scan through the code shows we just need the list of <code>videos</code>.</p>
<pre><code class="language-diff">-let VideoList = () =&gt; {
+let VideoList = ({ videos }) =&gt; {
-  if (this.state.data.videos.length &gt; 0) {
+  if (videos.length &gt; 0) {
-    return this.state.data.videos.map(video =&gt;
+    return videos.map(video =&gt;
</code></pre>
<p>Hey look, we have a pure component now! Let's do the same to <code>buildPage()</code>, which is really the heart of the <code>VideoPage</code> component.</p>
<pre><code class="language-diff">-let buildPage = () =&gt; {
+let VideoPage = ({ data }) =&gt; {
-  if (this.state.data) {
+  if (data) {
     return (
       &lt;ScrollView&gt;
         &lt;View&gt;
-          &lt;Text&gt;{this.state.data.title}&lt;/Text&gt;
+          &lt;Text&gt;{data.title}&lt;/Text&gt;
-          { this.state.data.description ? &lt;Text&gt;{this.state.data.description}&lt;/Text&gt; : null }
+          { data.description ? &lt;Text&gt;{data.description}&lt;/Text&gt; : null }
         &lt;/View&gt;
         &lt;View&gt;
-          {this.renderVideoList()}
+          &lt;VideoList videos={data.videos} /&gt;
         &lt;/View&gt;
       &lt;/ScrollView&gt;
     )
</code></pre>
<p>To finish wiring things up, let's rename the original <code>VideoPage</code> class component to <code>VideoPageContainer</code> and change the <code>render()</code> method to return our new stateless functional <code>VideoPage</code> component.</p>
<pre><code class="language-diff">-class VideoPage extends Component {
+class VideoPageContainer extends Component {

   ...

   render() {
-    return this.buildPage()
+    return &lt;VideoPage data={this.state.data} /&gt;
   }
 }

-export default VideoPage
+export default VideoPageContainer
</code></pre>
<p>So far, here's what we have:</p>
<pre><code class="language-jsx">import React, { Component } from 'react'
import { ScrollView, Text, View } from 'react-native'

import Loading from 'components/loading'
import Video from 'components/video'
import API from 'services/api'

class VideoPageContainer extends Component {
  constructor(props) {
    super(props)
    this.state = { data: null }
  }

  async fetchData(id) {
    let res = await API.getVideos(id)
    let json = await res.json()
    this.setState({ data: json.videos })
  }

  componentWillMount() {
    this.fetchData(this.props.id)
  }

  render() {
    return &lt;VideoPage data={this.state.data} /&gt;
  }
}

let VideoList = ({ videos }) =&gt; {
  if (videos.length &gt; 0) {
    return videos.map(video =&gt;
      &lt;Video key={video.id} data={video} /&gt;
    )
  } else {
    return (
      &lt;View&gt;
        &lt;Text&gt;No videos found&lt;/Text&gt;
      &lt;/View&gt;
    )
  }
}

let VideoPage = ({ data }) =&gt; {
  if (data) {
    return (
      &lt;ScrollView&gt;
        &lt;View&gt;
          &lt;Text&gt;{data.title}&lt;/Text&gt;
          { data.description ? &lt;Text&gt;{data.description}&lt;/Text&gt; : null }
        &lt;/View&gt;
        &lt;View&gt;
          &lt;VideoList videos={data.videos} /&gt;
        &lt;/View&gt;
      &lt;/ScrollView&gt;
    )
  } else {
    return &lt;Loading /&gt;
  }
}

export default VideoPageContainer
</code></pre>
<p>We have successfully split the monolithic <code>VideoPage</code> component into several subcomponents, most of which are pure and stateless. This dichotomy of <a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0">smart vs. dumb components</a> will set the stage nicely for further refactoring.</p>
<h3 id="2extractremaininginstancemethodstoplainfunctions">2. Extract remaining instance methods to plain functions</h3>
<p>What about the remaining instance methods? Let's move the <code>.fetchData()</code> method outside the class to a top-level function and rewire <code>componentDidMount()</code> to invoke it.</p>
<pre><code class="language-diff">-  componentWillMount() {
+  async componentWillMount() {
-    this.fetchData(this.props.id)
+    this.setState({ data: await model(this.props) })
   }
 }

 ...

-async fetchData(id) {
+let model = async ({ id }) =&gt; {
   let res = await API.getVideos(id)
   let json = await res.json()
-  this.setState({ data: json.videos })
+  return json.videos
 }
</code></pre>
<p>Since we need the lifecycle hook to instantiate data fetching, we can't pull out the <code>.componentWillMount()</code> method, but at least the logic for how to fetch the data is extracted.</p>
<h3 id="3extractbranchingcomplexitywithhigherordercomponents">3. Extract branching complexity with higher-order components</h3>
<p>The <code>VideoList</code> component could stand to be broken down into subcomponents so it's easier to debug the <code>if</code> branches. Let's extract the two cases into their own stateless functional components:</p>
<pre><code class="language-diff">+let VideoListBase = ({ videos }) =&gt;
+  &lt;View&gt;
+    { videos.map(video =&gt;
+      &lt;Video key={video.id} data={video} /&gt;
+    ) }
+  &lt;/View&gt;
+
+let NoVideosFound = () =&gt;
+  &lt;View&gt;
+    &lt;Text&gt;No videos found&lt;/Text&gt;
+  &lt;/View&gt;
+
 let VideoList = ({ videos }) =&gt; {
   if (videos.length &gt; 0) {
-    return videos.map(video =&gt;
-      &lt;Video key={video.id} data={video} /&gt;
-    )
+    return &lt;VideoListBase videos={videos} /&gt;
   } else {
-    return (
-      &lt;View&gt;
-        &lt;Text&gt;No videos found&lt;/Text&gt;
-      &lt;/View&gt;
-    )
+    return &lt;NoVideosFound /&gt;
   }
 }
</code></pre>
<p>Hmm, the current <code>VideoList</code> component is nothing more than an <code>if</code> statement, which is a common component <em>behavior.</em> And thanks to functional programming, behaviors are easy to reuse through higher-order components.</p>
<p>There's a great library for reusable behavior like branching: <a href="https://github.com/acdlite/recompose">Recompose</a>. It's a <em>lightly</em> coupled utility library for creating higher-order <em>components</em> (which are really just higher-order <em>functions</em>).</p>
<p>Let's replace <code>VideoList</code> with the <code>branch</code> higher-order component.</p>
<pre><code class="language-diff">+import { branch, renderComponent } from 'recompose'

-let VideoList = ({ videos }) =&gt; {
-  if (videos.length &gt; 0) {
-    return &lt;VideoListBase videos={videos} /&gt;
-  } else {
-    return &lt;NoVideosFound /&gt;
-  }
-}
+let VideoList = branch(
+  ({ videos }) =&gt; videos.length === 0,
+  renderComponent(NoVideosFound)
+)(VideoListBase)
</code></pre>
<p>When there are no videos, the <code>branch()</code> higher-order component will render the <code>NoVideosFound</code> component. Otherwise, it will render <code>VideoListBase</code>.</p>
<p>A higher-order component is usually curried. The first invocation accepts any number of configuration arguments — like a test function — and the second invocation accepts only one argument: the base component to wrap. Currying doesn't seem to gain us anything yet, but later when we stack several higher-order components together, the currying convention will save us some boilerplate and make testing really elegant.</p>
<p>Take a look at some of these <a href="https://github.com/acdlite/recompose/wiki/Recipes">Recompose recipes</a> for more inspiration.</p>
<h3 id="4createadatafetchinghigherordercomponent">4. Create a data fetching higher-order component</h3>
<p>We're nearly done! <code>VideoPageContainer</code> is now a generic, reusable "smart component" that fetches data asynchronously and passes it as a prop to another component. Let's turn <code>VideoPageContainer</code> into our own higher-order component, called <code>withModel()</code>:</p>
<pre><code class="language-diff">+let withModel = (model, initial) =&gt; BaseComponent =&gt;
-  class VideoPageContainer extends Component {
+  class WithModel extends Component {
     constructor(props) {
       super(props)
-      this.state = { data: null }
+      this.state = { data: initial }
     }

     ...

     render() {
-      return &lt;VideoPage data={this.state.data} /&gt;
+      return &lt;BaseComponent data={this.state.data} /&gt;
     }
   }
 }
</code></pre>
<p>The function signature of <code>withModel()</code> indicates that the first invocation should provide a function for fetching the necessary data, followed by an initial value for the data while it is loading. The second invocation takes the component to wrap, and returns a brand new component with data fetching behavior.</p>
<p>To use <code>withModel()</code>, let's invoke it with the <code>VideoPage</code> stateless functional component and export the result.</p>
<pre><code class="language-diff">-export default VideoPageContainer
+export default withModel(model, null)(VideoPage)
</code></pre>
<p>The <code>withModel()</code> higher-order component will definitely be useful for other components in the app, so it should be moved to its own file!</p>
<h3 id="5composebehaviorsintoasingleenhancefunction">5. Compose behaviors into a single <code>enhance()</code> function</h3>
<p>Currying the <code>withModel()</code> higher-order component has an elegant benefit: we can stack more "behaviors" with Recompose utilities! Similar to our work with the <code>VideoList</code> and <code>NoVideosFound</code> components, let's extract the <code>if (data)</code> edge cases from <code>VideoPage</code> with the <code>branch()</code> higher-order component to render the <code>Loading</code> component while the data is being fetched:</p>
<pre><code class="language-diff">-import { branch, renderComponent } from 'recompose'
+import { branch, renderComponent, compose } from 'recompose'

 ...

-let VideoPage = ({ data }) =&gt; {
+let VideoPage = ({ data }) =&gt;
-  if (data) {
-    return (
   &lt;ScrollView&gt;
     ...
   &lt;/ScrollView&gt;
-    )
-  } else {
-    return &lt;Loading /&gt;
-  }
-}

+export let enhance = compose(
+  withModel(model, null),
+  branch(
+    ({ data }) =&gt; !data,
+    renderComponent(Loading)
+  )
+)

-export default withModel(model, null)(VideoPage)
+export default enhance(VideoPage)
</code></pre>
<p>The <code>compose()</code> utility saves us from deeply nested parentheses and linearizes stacked behaviors into a single function, conventionally called <code>enhance()</code>. Hurray for clean <code>git diff</code>s!</p>
<p>And now the <code>VideoPage</code> "dumb component" focuses solely on the happy path: when there is data and at least one video to display. By reading the <code>enhance</code> function from top to bottom, we can quickly parse out other behaviors or even add new ones, e.g. performance optimizations with <a href="https://github.com/acdlite/recompose/blob/master/docs/API.md#onlyupdateforkeys"><code>onlyUpdateForKeys()</code></a>.</p>
<h2 id="finalresult">Final result</h2>
<p>After a few more tweaks, here is the <strong>completed <code>VideoPage</code> component</strong> in 52 lines of code (also <a href="https://github.com/nybblr/destroy-all-classes">on Github</a>):</p>
<pre><code class="language-jsx">import React from 'react'
import { ScrollView, Text, View } from 'react-native'
import { compose, branch, renderComponent } from 'recompose'

import Loading from 'components/loading'
import Video from 'components/video'
import API from 'services/api'
import withModel from 'lib/with-model'

let VideoPage = ({ data }) =&gt;
  &lt;ScrollView&gt;
    &lt;View&gt;
      &lt;Text&gt;{data.title}&lt;/Text&gt;
      { data.description ? &lt;Text&gt;{data.description}&lt;/Text&gt; : null }
    &lt;/View&gt;
    &lt;View&gt;
      &lt;VideoList videos={data.videos} /&gt;
    &lt;/View&gt;
  &lt;/ScrollView&gt;

let VideoListBase = ({ videos }) =&gt;
  &lt;View&gt;
    { videos.map(video =&gt;
      &lt;Video key={video.id} data={video} /&gt;
    ) }
  &lt;/View&gt;

let NoVideosFound = () =&gt;
  &lt;View&gt;
    &lt;Text&gt;No videos found&lt;/Text&gt;
  &lt;/View&gt;

let VideoList = branch(
  ({ videos }) =&gt; videos.length === 0,
  renderComponent(NoVideosFound)
)(VideoListBase)

let model = async ({ id }) =&gt; {
  let res = await API.getVideos(id)
  let json = await res.json()
  return json.videos
}

export let enhance = compose(
  withModel(model, null),
  branch(
    ({ data }) =&gt; !data,
    renderComponent(Loading)
  )
)

export default enhance(VideoPage)
</code></pre>
<p>Not bad! At a glance, we can see the happy path for rendering <code>VideoPage</code>, how it fetches data, and how it handles the load state. When we add new behaviors in the future, we will only <em>add</em> new code instead of <em>modifying</em> existing code. So in a way, <em>functional programming helps you write immutable code!</em></p>
<p>Interestingly, every component and function (except <code>model()</code>) is an arrow function with an implied return. This isn't just about syntactic noise: the implied return makes it harder to sneak in side effects! The code looks like a strict "data in, data out" pipeline. The implied return also discourages you from assigning to local variables, so it is hard for ugly interfaces to hide when all destructuring must happen in the parameter list. And to add impure behaviors like performance optimization or handlers, you are naturally forced to use higher-order components.</p>
<p>We can even test the component's <code>enhance</code>r in isolation by stubbing out the <code>VideoPage</code> component:</p>
<pre><code class="language-jsx">import { enhance } from 'components/video-page'

it('renders when there is data', () =&gt; {
  let Stub = () =&gt; &lt;a&gt;TDD FTW&lt;/a&gt;

  let Enhanced = enhance(Stub)

  /* Perform assertions! */
})
</code></pre>
<p>Back when rendering was tangled up in instance methods, our only hope of extracting behaviors was through inheritance, e.g. mixins. But now we can reuse behaviors through straightforward function composition. The inside-out transformation also highlights that <code>VideoList</code> should be extracted to its own module, <code>video-list.js</code>.</p>
<h2 id="itsawraperrsandwich">It's a wrap, err, sandwich</h2>
<p>Functional programming recipes and patterns go a long way to creating elegant, resilient and test-friendly code by minimizing the surface area between our code and the framework. Whether you are creating a React web app or React Native app, higher-order components are a particularly powerful technique because they encourage <em>composition over inheritance.</em></p>
<p>With functional programming, we can build React components that resemble a tasty sandwich, where we can peel back each ingredient and debug layer-by-layer.</p>
<p>By contrast, class-based components are a burrito wrap with potato salad.</p>


            </section>

        </article>
    </main>
    <footer class="site-footer clearfix">
        <section class="copyright"><a href="https://jonathanleemartin.com">tl;dr</a> &copy; 2019</section>
        <section class="poweredby">Proudly published with <a href="https://ghost.org">Ghost</a></section>
    </footer>
</body>
</html>
